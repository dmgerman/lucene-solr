begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.search.join
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|join
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Explanation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FilterWeight
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Scorer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ScorerSupplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TwoPhaseIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Weight
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_comment
comment|/**  * This query requires that you index  * children and parent docs as a single block, using the  * {@link IndexWriter#addDocuments IndexWriter.addDocuments()} or {@link  * IndexWriter#updateDocuments IndexWriter.updateDocuments()} API.  In each block, the  * child documents must appear first, ending with the parent  * document.  At search time you provide a Filter  * identifying the parents, however this Filter must provide  * an {@link BitSet} per sub-reader.  *  *<p>Once the block index is built, use this query to wrap  * any sub-query matching only child docs and join matches in that  * child document space up to the parent document space.  * You can then use this Query as a clause with  * other queries in the parent document space.</p>  *  *<p>See {@link ToChildBlockJoinQuery} if you need to join  * in the reverse order.  *  *<p>The child documents must be orthogonal to the parent  * documents: the wrapped child query must never  * return a parent document.</p>  *  *<p>See {@link org.apache.lucene.search.join} for an  * overview.</p>  *  * @lucene.experimental  */
end_comment

begin_class
DECL|class|ToParentBlockJoinQuery
specifier|public
class|class
name|ToParentBlockJoinQuery
extends|extends
name|Query
block|{
DECL|field|parentsFilter
specifier|private
specifier|final
name|BitSetProducer
name|parentsFilter
decl_stmt|;
DECL|field|childQuery
specifier|private
specifier|final
name|Query
name|childQuery
decl_stmt|;
DECL|field|scoreMode
specifier|private
specifier|final
name|ScoreMode
name|scoreMode
decl_stmt|;
comment|/** Create a ToParentBlockJoinQuery.    *    * @param childQuery Query matching child documents.    * @param parentsFilter Filter identifying the parent documents.    * @param scoreMode How to aggregate multiple child scores    * into a single parent score.    **/
DECL|method|ToParentBlockJoinQuery
specifier|public
name|ToParentBlockJoinQuery
parameter_list|(
name|Query
name|childQuery
parameter_list|,
name|BitSetProducer
name|parentsFilter
parameter_list|,
name|ScoreMode
name|scoreMode
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|childQuery
operator|=
name|childQuery
expr_stmt|;
name|this
operator|.
name|parentsFilter
operator|=
name|parentsFilter
expr_stmt|;
name|this
operator|.
name|scoreMode
operator|=
name|scoreMode
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createWeight
specifier|public
name|Weight
name|createWeight
parameter_list|(
name|IndexSearcher
name|searcher
parameter_list|,
name|boolean
name|needsScores
parameter_list|,
name|float
name|boost
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|BlockJoinWeight
argument_list|(
name|this
argument_list|,
name|childQuery
operator|.
name|createWeight
argument_list|(
name|searcher
argument_list|,
name|needsScores
argument_list|,
name|boost
argument_list|)
argument_list|,
name|parentsFilter
argument_list|,
name|needsScores
condition|?
name|scoreMode
else|:
name|ScoreMode
operator|.
name|None
argument_list|)
return|;
block|}
comment|/** Return our child query. */
DECL|method|getChildQuery
specifier|public
name|Query
name|getChildQuery
parameter_list|()
block|{
return|return
name|childQuery
return|;
block|}
DECL|class|BlockJoinWeight
specifier|private
specifier|static
class|class
name|BlockJoinWeight
extends|extends
name|FilterWeight
block|{
DECL|field|parentsFilter
specifier|private
specifier|final
name|BitSetProducer
name|parentsFilter
decl_stmt|;
DECL|field|scoreMode
specifier|private
specifier|final
name|ScoreMode
name|scoreMode
decl_stmt|;
DECL|method|BlockJoinWeight
specifier|public
name|BlockJoinWeight
parameter_list|(
name|Query
name|joinQuery
parameter_list|,
name|Weight
name|childWeight
parameter_list|,
name|BitSetProducer
name|parentsFilter
parameter_list|,
name|ScoreMode
name|scoreMode
parameter_list|)
block|{
name|super
argument_list|(
name|joinQuery
argument_list|,
name|childWeight
argument_list|)
expr_stmt|;
name|this
operator|.
name|parentsFilter
operator|=
name|parentsFilter
expr_stmt|;
name|this
operator|.
name|scoreMode
operator|=
name|scoreMode
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|scorer
specifier|public
name|Scorer
name|scorer
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ScorerSupplier
name|scorerSupplier
init|=
name|scorerSupplier
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|scorerSupplier
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|scorerSupplier
operator|.
name|get
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|// NOTE: acceptDocs applies (and is checked) only in the
comment|// parent document space
annotation|@
name|Override
DECL|method|scorerSupplier
specifier|public
name|ScorerSupplier
name|scorerSupplier
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ScorerSupplier
name|childScorerSupplier
init|=
name|in
operator|.
name|scorerSupplier
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|childScorerSupplier
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// NOTE: this does not take accept docs into account, the responsibility
comment|// to not match deleted docs is on the scorer
specifier|final
name|BitSet
name|parents
init|=
name|parentsFilter
operator|.
name|getBitSet
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|parents
operator|==
literal|null
condition|)
block|{
comment|// No matches
return|return
literal|null
return|;
block|}
return|return
operator|new
name|ScorerSupplier
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Scorer
name|get
parameter_list|(
name|boolean
name|randomAccess
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|BlockJoinScorer
argument_list|(
name|BlockJoinWeight
operator|.
name|this
argument_list|,
name|childScorerSupplier
operator|.
name|get
argument_list|(
name|randomAccess
argument_list|)
argument_list|,
name|parents
argument_list|,
name|scoreMode
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|childScorerSupplier
operator|.
name|cost
argument_list|()
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|explain
specifier|public
name|Explanation
name|explain
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockJoinScorer
name|scorer
init|=
operator|(
name|BlockJoinScorer
operator|)
name|scorer
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|scorer
operator|!=
literal|null
operator|&&
name|scorer
operator|.
name|iterator
argument_list|()
operator|.
name|advance
argument_list|(
name|doc
argument_list|)
operator|==
name|doc
condition|)
block|{
return|return
name|scorer
operator|.
name|explain
argument_list|(
name|context
argument_list|,
name|in
argument_list|)
return|;
block|}
return|return
name|Explanation
operator|.
name|noMatch
argument_list|(
literal|"Not a match"
argument_list|)
return|;
block|}
block|}
DECL|class|ParentApproximation
specifier|private
specifier|static
class|class
name|ParentApproximation
extends|extends
name|DocIdSetIterator
block|{
DECL|field|childApproximation
specifier|private
specifier|final
name|DocIdSetIterator
name|childApproximation
decl_stmt|;
DECL|field|parentBits
specifier|private
specifier|final
name|BitSet
name|parentBits
decl_stmt|;
DECL|field|doc
specifier|private
name|int
name|doc
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|ParentApproximation
name|ParentApproximation
parameter_list|(
name|DocIdSetIterator
name|childApproximation
parameter_list|,
name|BitSet
name|parentBits
parameter_list|)
block|{
name|this
operator|.
name|childApproximation
operator|=
name|childApproximation
expr_stmt|;
name|this
operator|.
name|parentBits
operator|=
name|parentBits
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|advance
argument_list|(
name|doc
operator|+
literal|1
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|target
operator|>=
name|parentBits
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
specifier|final
name|int
name|firstChildTarget
init|=
name|target
operator|==
literal|0
condition|?
literal|0
else|:
name|parentBits
operator|.
name|prevSetBit
argument_list|(
name|target
operator|-
literal|1
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|childDoc
init|=
name|childApproximation
operator|.
name|docID
argument_list|()
decl_stmt|;
if|if
condition|(
name|childDoc
operator|<
name|firstChildTarget
condition|)
block|{
name|childDoc
operator|=
name|childApproximation
operator|.
name|advance
argument_list|(
name|firstChildTarget
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|childDoc
operator|>=
name|parentBits
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
return|return
name|doc
operator|=
name|parentBits
operator|.
name|nextSetBit
argument_list|(
name|childDoc
operator|+
literal|1
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|childApproximation
operator|.
name|cost
argument_list|()
return|;
block|}
block|}
DECL|class|ParentTwoPhase
specifier|private
specifier|static
class|class
name|ParentTwoPhase
extends|extends
name|TwoPhaseIterator
block|{
DECL|field|parentApproximation
specifier|private
specifier|final
name|ParentApproximation
name|parentApproximation
decl_stmt|;
DECL|field|childApproximation
specifier|private
specifier|final
name|DocIdSetIterator
name|childApproximation
decl_stmt|;
DECL|field|childTwoPhase
specifier|private
specifier|final
name|TwoPhaseIterator
name|childTwoPhase
decl_stmt|;
DECL|method|ParentTwoPhase
name|ParentTwoPhase
parameter_list|(
name|ParentApproximation
name|parentApproximation
parameter_list|,
name|TwoPhaseIterator
name|childTwoPhase
parameter_list|)
block|{
name|super
argument_list|(
name|parentApproximation
argument_list|)
expr_stmt|;
name|this
operator|.
name|parentApproximation
operator|=
name|parentApproximation
expr_stmt|;
name|this
operator|.
name|childApproximation
operator|=
name|childTwoPhase
operator|.
name|approximation
argument_list|()
expr_stmt|;
name|this
operator|.
name|childTwoPhase
operator|=
name|childTwoPhase
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|childApproximation
operator|.
name|docID
argument_list|()
operator|<
name|parentApproximation
operator|.
name|docID
argument_list|()
assert|;
do|do
block|{
if|if
condition|(
name|childTwoPhase
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
do|while
condition|(
name|childApproximation
operator|.
name|nextDoc
argument_list|()
operator|<
name|parentApproximation
operator|.
name|docID
argument_list|()
condition|)
do|;
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|matchCost
specifier|public
name|float
name|matchCost
parameter_list|()
block|{
comment|// TODO: how could we compute a match cost?
return|return
name|childTwoPhase
operator|.
name|matchCost
argument_list|()
operator|+
literal|10
return|;
block|}
block|}
DECL|class|BlockJoinScorer
specifier|static
class|class
name|BlockJoinScorer
extends|extends
name|Scorer
block|{
DECL|field|childScorer
specifier|private
specifier|final
name|Scorer
name|childScorer
decl_stmt|;
DECL|field|parentBits
specifier|private
specifier|final
name|BitSet
name|parentBits
decl_stmt|;
DECL|field|scoreMode
specifier|private
specifier|final
name|ScoreMode
name|scoreMode
decl_stmt|;
DECL|field|childApproximation
specifier|private
specifier|final
name|DocIdSetIterator
name|childApproximation
decl_stmt|;
DECL|field|childTwoPhase
specifier|private
specifier|final
name|TwoPhaseIterator
name|childTwoPhase
decl_stmt|;
DECL|field|parentApproximation
specifier|private
specifier|final
name|ParentApproximation
name|parentApproximation
decl_stmt|;
DECL|field|parentTwoPhase
specifier|private
specifier|final
name|ParentTwoPhase
name|parentTwoPhase
decl_stmt|;
DECL|field|score
specifier|private
name|float
name|score
decl_stmt|;
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
DECL|method|BlockJoinScorer
specifier|public
name|BlockJoinScorer
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|Scorer
name|childScorer
parameter_list|,
name|BitSet
name|parentBits
parameter_list|,
name|ScoreMode
name|scoreMode
parameter_list|)
block|{
name|super
argument_list|(
name|weight
argument_list|)
expr_stmt|;
comment|//System.out.println("Q.init firstChildDoc=" + firstChildDoc);
name|this
operator|.
name|parentBits
operator|=
name|parentBits
expr_stmt|;
name|this
operator|.
name|childScorer
operator|=
name|childScorer
expr_stmt|;
name|this
operator|.
name|scoreMode
operator|=
name|scoreMode
expr_stmt|;
name|childTwoPhase
operator|=
name|childScorer
operator|.
name|twoPhaseIterator
argument_list|()
expr_stmt|;
if|if
condition|(
name|childTwoPhase
operator|==
literal|null
condition|)
block|{
name|childApproximation
operator|=
name|childScorer
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|parentApproximation
operator|=
operator|new
name|ParentApproximation
argument_list|(
name|childApproximation
argument_list|,
name|parentBits
argument_list|)
expr_stmt|;
name|parentTwoPhase
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|childApproximation
operator|=
name|childTwoPhase
operator|.
name|approximation
argument_list|()
expr_stmt|;
name|parentApproximation
operator|=
operator|new
name|ParentApproximation
argument_list|(
name|childTwoPhase
operator|.
name|approximation
argument_list|()
argument_list|,
name|parentBits
argument_list|)
expr_stmt|;
name|parentTwoPhase
operator|=
operator|new
name|ParentTwoPhase
argument_list|(
name|parentApproximation
argument_list|,
name|childTwoPhase
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getChildren
specifier|public
name|Collection
argument_list|<
name|ChildScorer
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|singleton
argument_list|(
operator|new
name|ChildScorer
argument_list|(
name|childScorer
argument_list|,
literal|"BLOCK_JOIN"
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|DocIdSetIterator
name|iterator
parameter_list|()
block|{
if|if
condition|(
name|parentTwoPhase
operator|==
literal|null
condition|)
block|{
comment|// the approximation is exact
return|return
name|parentApproximation
return|;
block|}
else|else
block|{
return|return
name|TwoPhaseIterator
operator|.
name|asDocIdSetIterator
argument_list|(
name|parentTwoPhase
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|twoPhaseIterator
specifier|public
name|TwoPhaseIterator
name|twoPhaseIterator
parameter_list|()
block|{
return|return
name|parentTwoPhase
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|parentApproximation
operator|.
name|docID
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|score
specifier|public
name|float
name|score
parameter_list|()
throws|throws
name|IOException
block|{
name|setScoreAndFreq
argument_list|()
expr_stmt|;
return|return
name|score
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
name|setScoreAndFreq
argument_list|()
expr_stmt|;
return|return
name|freq
return|;
block|}
DECL|method|setScoreAndFreq
specifier|private
name|void
name|setScoreAndFreq
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|childApproximation
operator|.
name|docID
argument_list|()
operator|>=
name|parentApproximation
operator|.
name|docID
argument_list|()
condition|)
block|{
return|return;
block|}
name|double
name|score
init|=
name|scoreMode
operator|==
name|ScoreMode
operator|.
name|None
condition|?
literal|0
else|:
name|childScorer
operator|.
name|score
argument_list|()
decl_stmt|;
name|int
name|freq
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|childApproximation
operator|.
name|nextDoc
argument_list|()
operator|<
name|parentApproximation
operator|.
name|docID
argument_list|()
condition|)
block|{
if|if
condition|(
name|childTwoPhase
operator|==
literal|null
operator|||
name|childTwoPhase
operator|.
name|matches
argument_list|()
condition|)
block|{
specifier|final
name|float
name|childScore
init|=
name|childScorer
operator|.
name|score
argument_list|()
decl_stmt|;
name|freq
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|scoreMode
condition|)
block|{
case|case
name|Total
case|:
case|case
name|Avg
case|:
name|score
operator|+=
name|childScore
expr_stmt|;
break|break;
case|case
name|Min
case|:
name|score
operator|=
name|Math
operator|.
name|min
argument_list|(
name|score
argument_list|,
name|childScore
argument_list|)
expr_stmt|;
break|break;
case|case
name|Max
case|:
name|score
operator|=
name|Math
operator|.
name|max
argument_list|(
name|score
argument_list|,
name|childScore
argument_list|)
expr_stmt|;
break|break;
case|case
name|None
case|:
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
block|}
if|if
condition|(
name|childApproximation
operator|.
name|docID
argument_list|()
operator|==
name|parentApproximation
operator|.
name|docID
argument_list|()
operator|&&
operator|(
name|childTwoPhase
operator|==
literal|null
operator|||
name|childTwoPhase
operator|.
name|matches
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Child query must not match same docs with parent filter. "
operator|+
literal|"Combine them as must clauses (+) to find a problem doc. "
operator|+
literal|"docId="
operator|+
name|parentApproximation
operator|.
name|docID
argument_list|()
operator|+
literal|", "
operator|+
name|childScorer
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|scoreMode
operator|==
name|ScoreMode
operator|.
name|Avg
condition|)
block|{
name|score
operator|/=
name|freq
expr_stmt|;
block|}
name|this
operator|.
name|score
operator|=
operator|(
name|float
operator|)
name|score
expr_stmt|;
name|this
operator|.
name|freq
operator|=
name|freq
expr_stmt|;
block|}
DECL|method|explain
specifier|public
name|Explanation
name|explain
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|,
name|Weight
name|childWeight
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|prevParentDoc
init|=
name|parentBits
operator|.
name|prevSetBit
argument_list|(
name|parentApproximation
operator|.
name|docID
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|start
init|=
name|context
operator|.
name|docBase
operator|+
name|prevParentDoc
operator|+
literal|1
decl_stmt|;
comment|// +1 b/c prevParentDoc is previous parent doc
name|int
name|end
init|=
name|context
operator|.
name|docBase
operator|+
name|parentApproximation
operator|.
name|docID
argument_list|()
operator|-
literal|1
decl_stmt|;
comment|// -1 b/c parentDoc is parent doc
name|Explanation
name|bestChild
init|=
literal|null
decl_stmt|;
name|int
name|matches
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|childDoc
init|=
name|start
init|;
name|childDoc
operator|<=
name|end
condition|;
name|childDoc
operator|++
control|)
block|{
name|Explanation
name|child
init|=
name|childWeight
operator|.
name|explain
argument_list|(
name|context
argument_list|,
name|childDoc
operator|-
name|context
operator|.
name|docBase
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|isMatch
argument_list|()
condition|)
block|{
name|matches
operator|++
expr_stmt|;
if|if
condition|(
name|bestChild
operator|==
literal|null
operator|||
name|child
operator|.
name|getValue
argument_list|()
operator|>
name|bestChild
operator|.
name|getValue
argument_list|()
condition|)
block|{
name|bestChild
operator|=
name|child
expr_stmt|;
block|}
block|}
block|}
assert|assert
name|freq
argument_list|()
operator|==
name|matches
assert|;
return|return
name|Explanation
operator|.
name|match
argument_list|(
name|score
argument_list|()
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Score based on %d child docs in range from %d to %d, best match:"
argument_list|,
name|matches
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
argument_list|,
name|bestChild
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|rewrite
specifier|public
name|Query
name|rewrite
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Query
name|childRewrite
init|=
name|childQuery
operator|.
name|rewrite
argument_list|(
name|reader
argument_list|)
decl_stmt|;
if|if
condition|(
name|childRewrite
operator|!=
name|childQuery
condition|)
block|{
return|return
operator|new
name|ToParentBlockJoinQuery
argument_list|(
name|childRewrite
argument_list|,
name|parentsFilter
argument_list|,
name|scoreMode
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|rewrite
argument_list|(
name|reader
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
literal|"ToParentBlockJoinQuery ("
operator|+
name|childQuery
operator|.
name|toString
argument_list|()
operator|+
literal|")"
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|sameClassAs
argument_list|(
name|other
argument_list|)
operator|&&
name|equalsTo
argument_list|(
name|getClass
argument_list|()
operator|.
name|cast
argument_list|(
name|other
argument_list|)
argument_list|)
return|;
block|}
DECL|method|equalsTo
specifier|private
name|boolean
name|equalsTo
parameter_list|(
name|ToParentBlockJoinQuery
name|other
parameter_list|)
block|{
return|return
name|childQuery
operator|.
name|equals
argument_list|(
name|other
operator|.
name|childQuery
argument_list|)
operator|&&
name|parentsFilter
operator|.
name|equals
argument_list|(
name|other
operator|.
name|parentsFilter
argument_list|)
operator|&&
name|scoreMode
operator|==
name|other
operator|.
name|scoreMode
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|hash
init|=
name|classHash
argument_list|()
decl_stmt|;
name|hash
operator|=
name|prime
operator|*
name|hash
operator|+
name|childQuery
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|hash
operator|=
name|prime
operator|*
name|hash
operator|+
name|scoreMode
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|hash
operator|=
name|prime
operator|*
name|hash
operator|+
name|parentsFilter
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|hash
return|;
block|}
block|}
end_class

end_unit

