begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PostingsEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Attribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|AttributeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|AttributeReflector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|AttributeSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Automaton
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|CompiledAutomaton
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|LevenshteinAutomata
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_comment
comment|/** Subclass of TermsEnum for enumerating all terms that are similar  * to the specified filter term.  *  *<p>Term enumerations are always ordered by  * {@link BytesRef#compareTo}.  Each term in the enumeration is  * greater than all that precede it.</p>  */
end_comment

begin_class
DECL|class|FuzzyTermsEnum
specifier|public
specifier|final
class|class
name|FuzzyTermsEnum
extends|extends
name|TermsEnum
block|{
comment|// NOTE: we can't subclass FilteredTermsEnum here because we need to sometimes change actualEnum:
DECL|field|actualEnum
specifier|private
name|TermsEnum
name|actualEnum
decl_stmt|;
comment|// We use this to communicate the score (boost) of the current matched term we are on back to
comment|// MultiTermQuery.TopTermsBlendedFreqScoringRewrite that is collecting the best (default 50) matched terms:
DECL|field|boostAtt
specifier|private
specifier|final
name|BoostAttribute
name|boostAtt
decl_stmt|;
comment|// MultiTermQuery.TopTermsBlendedFreqScoringRewrite tells us the worst boost still in its queue using this att,
comment|// which we use to know when we can reduce the automaton from ed=2 to ed=1, or ed=0 if only single top term is collected:
DECL|field|maxBoostAtt
specifier|private
specifier|final
name|MaxNonCompetitiveBoostAttribute
name|maxBoostAtt
decl_stmt|;
comment|// We use this to share the pre-built (once for the query) Levenshtein automata across segments:
DECL|field|dfaAtt
specifier|private
specifier|final
name|LevenshteinAutomataAttribute
name|dfaAtt
decl_stmt|;
DECL|field|bottom
specifier|private
name|float
name|bottom
decl_stmt|;
DECL|field|bottomTerm
specifier|private
name|BytesRef
name|bottomTerm
decl_stmt|;
DECL|field|automata
specifier|private
specifier|final
name|CompiledAutomaton
name|automata
index|[]
decl_stmt|;
DECL|field|queuedBottom
specifier|private
name|BytesRef
name|queuedBottom
decl_stmt|;
DECL|field|termLength
specifier|final
name|int
name|termLength
decl_stmt|;
comment|// Maximum number of edits we will accept.  This is either 2 or 1 (or, degenerately, 0) passed by the user originally,
comment|// but as we collect terms, we can lower this (e.g. from 2 to 1) if we detect that the term queue is full, and all
comment|// collected terms are ed=1:
DECL|field|maxEdits
specifier|private
name|int
name|maxEdits
decl_stmt|;
DECL|field|terms
specifier|final
name|Terms
name|terms
decl_stmt|;
DECL|field|term
specifier|final
name|Term
name|term
decl_stmt|;
DECL|field|termText
specifier|final
name|int
name|termText
index|[]
decl_stmt|;
DECL|field|realPrefixLength
specifier|final
name|int
name|realPrefixLength
decl_stmt|;
comment|// True (the default, in FuzzyQuery) if a transposition should count as a single edit:
DECL|field|transpositions
specifier|final
name|boolean
name|transpositions
decl_stmt|;
comment|/**    * Constructor for enumeration of all terms from specified<code>reader</code> which share a prefix of    * length<code>prefixLength</code> with<code>term</code> and which have at most {@code maxEdits} edits.    *<p>    * After calling the constructor the enumeration is already pointing to the first     * valid term if such a term exists.     *     * @param terms Delivers terms.    * @param atts {@link AttributeSource} created by the rewrite method of {@link MultiTermQuery}    * thats contains information about competitive boosts during rewrite. It is also used    * to cache DFAs between segment transitions.    * @param term Pattern term.    * @param maxEdits Maximum edit distance.    * @param prefixLength Length of required common prefix. Default value is 0.    * @throws IOException if there is a low-level IO error    */
DECL|method|FuzzyTermsEnum
specifier|public
name|FuzzyTermsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|,
name|AttributeSource
name|atts
parameter_list|,
name|Term
name|term
parameter_list|,
specifier|final
name|int
name|maxEdits
parameter_list|,
specifier|final
name|int
name|prefixLength
parameter_list|,
name|boolean
name|transpositions
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|maxEdits
argument_list|<
literal|0
operator|||
name|maxEdits
argument_list|>
name|LevenshteinAutomata
operator|.
name|MAXIMUM_SUPPORTED_DISTANCE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"max edits must be 0.."
operator|+
name|LevenshteinAutomata
operator|.
name|MAXIMUM_SUPPORTED_DISTANCE
operator|+
literal|", inclusive; got: "
operator|+
name|maxEdits
argument_list|)
throw|;
block|}
if|if
condition|(
name|prefixLength
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"prefixLength cannot be less than 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|maxEdits
operator|=
name|maxEdits
expr_stmt|;
name|this
operator|.
name|terms
operator|=
name|terms
expr_stmt|;
name|this
operator|.
name|term
operator|=
name|term
expr_stmt|;
comment|// convert the string into a utf32 int[] representation for fast comparisons
specifier|final
name|String
name|utf16
init|=
name|term
operator|.
name|text
argument_list|()
decl_stmt|;
name|this
operator|.
name|termText
operator|=
operator|new
name|int
index|[
name|utf16
operator|.
name|codePointCount
argument_list|(
literal|0
argument_list|,
name|utf16
operator|.
name|length
argument_list|()
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|int
name|cp
init|,
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<
name|utf16
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|cp
argument_list|)
control|)
block|{
name|termText
index|[
name|j
operator|++
index|]
operator|=
name|cp
operator|=
name|utf16
operator|.
name|codePointAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|termLength
operator|=
name|termText
operator|.
name|length
expr_stmt|;
name|this
operator|.
name|dfaAtt
operator|=
name|atts
operator|.
name|addAttribute
argument_list|(
name|LevenshteinAutomataAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxBoostAtt
operator|=
name|atts
operator|.
name|addAttribute
argument_list|(
name|MaxNonCompetitiveBoostAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// NOTE: boostAtt must pulled from attributes() not from atts!  This is because TopTermsRewrite looks for boostAtt from this TermsEnum's
comment|// private attributes() and not the global atts passed to us from MultiTermQuery:
name|this
operator|.
name|boostAtt
operator|=
name|attributes
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|BoostAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
comment|//The prefix could be longer than the word.
comment|//It's kind of silly though.  It means we must match the entire word.
name|this
operator|.
name|realPrefixLength
operator|=
name|prefixLength
operator|>
name|termLength
condition|?
name|termLength
else|:
name|prefixLength
expr_stmt|;
name|this
operator|.
name|transpositions
operator|=
name|transpositions
expr_stmt|;
name|CompiledAutomaton
index|[]
name|prevAutomata
init|=
name|dfaAtt
operator|.
name|automata
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevAutomata
operator|==
literal|null
condition|)
block|{
name|prevAutomata
operator|=
operator|new
name|CompiledAutomaton
index|[
name|maxEdits
operator|+
literal|1
index|]
expr_stmt|;
name|LevenshteinAutomata
name|builder
init|=
operator|new
name|LevenshteinAutomata
argument_list|(
name|UnicodeUtil
operator|.
name|newString
argument_list|(
name|termText
argument_list|,
name|realPrefixLength
argument_list|,
name|termText
operator|.
name|length
operator|-
name|realPrefixLength
argument_list|)
argument_list|,
name|transpositions
argument_list|)
decl_stmt|;
name|String
name|prefix
init|=
name|UnicodeUtil
operator|.
name|newString
argument_list|(
name|termText
argument_list|,
literal|0
argument_list|,
name|realPrefixLength
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|maxEdits
condition|;
name|i
operator|++
control|)
block|{
name|Automaton
name|a
init|=
name|builder
operator|.
name|toAutomaton
argument_list|(
name|i
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
name|prevAutomata
index|[
name|i
index|]
operator|=
operator|new
name|CompiledAutomaton
argument_list|(
name|a
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// first segment computes the automata, and we share with subsequent segments via this Attribute:
name|dfaAtt
operator|.
name|setAutomata
argument_list|(
name|prevAutomata
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|automata
operator|=
name|prevAutomata
expr_stmt|;
name|bottom
operator|=
name|maxBoostAtt
operator|.
name|getMaxNonCompetitiveBoost
argument_list|()
expr_stmt|;
name|bottomTerm
operator|=
name|maxBoostAtt
operator|.
name|getCompetitiveTerm
argument_list|()
expr_stmt|;
name|bottomChanged
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * return an automata-based enum for matching up to editDistance from    * lastTerm, if possible    */
DECL|method|getAutomatonEnum
specifier|private
name|TermsEnum
name|getAutomatonEnum
parameter_list|(
name|int
name|editDistance
parameter_list|,
name|BytesRef
name|lastTerm
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|editDistance
operator|<
name|automata
operator|.
name|length
assert|;
specifier|final
name|CompiledAutomaton
name|compiled
init|=
name|automata
index|[
name|editDistance
index|]
decl_stmt|;
name|BytesRef
name|initialSeekTerm
decl_stmt|;
if|if
condition|(
name|lastTerm
operator|==
literal|null
condition|)
block|{
comment|// This is the first enum we are pulling:
name|initialSeekTerm
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// We are pulling this enum (e.g., ed=1) after iterating for a while already (e.g., ed=2):
name|initialSeekTerm
operator|=
name|compiled
operator|.
name|floor
argument_list|(
name|lastTerm
argument_list|,
operator|new
name|BytesRefBuilder
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|terms
operator|.
name|intersect
argument_list|(
name|compiled
argument_list|,
name|initialSeekTerm
argument_list|)
return|;
block|}
comment|/**    * fired when the max non-competitive boost has changed. this is the hook to    * swap in a smarter actualEnum.    */
DECL|method|bottomChanged
specifier|private
name|void
name|bottomChanged
parameter_list|(
name|BytesRef
name|lastTerm
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|oldMaxEdits
init|=
name|maxEdits
decl_stmt|;
comment|// true if the last term encountered is lexicographically equal or after the bottom term in the PQ
name|boolean
name|termAfter
init|=
name|bottomTerm
operator|==
literal|null
operator|||
operator|(
name|lastTerm
operator|!=
literal|null
operator|&&
name|lastTerm
operator|.
name|compareTo
argument_list|(
name|bottomTerm
argument_list|)
operator|>=
literal|0
operator|)
decl_stmt|;
comment|// as long as the max non-competitive boost is>= the max boost
comment|// for some edit distance, keep dropping the max edit distance.
while|while
condition|(
name|maxEdits
operator|>
literal|0
condition|)
block|{
name|float
name|maxBoost
init|=
literal|1.0f
operator|-
operator|(
operator|(
name|float
operator|)
name|maxEdits
operator|/
operator|(
name|float
operator|)
name|termLength
operator|)
decl_stmt|;
if|if
condition|(
name|bottom
operator|<
name|maxBoost
operator|||
operator|(
name|bottom
operator|==
name|maxBoost
operator|&&
name|termAfter
operator|==
literal|false
operator|)
condition|)
block|{
break|break;
block|}
name|maxEdits
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|oldMaxEdits
operator|!=
name|maxEdits
operator|||
name|lastTerm
operator|==
literal|null
condition|)
block|{
comment|// This is a very powerful optimization: the maximum edit distance has changed.  This happens because we collect only the top scoring
comment|// N (= 50, by default) terms, and if e.g. maxEdits=2, and the queue is now full of matching terms, and we notice that the worst entry
comment|// in that queue is ed=1, then we can switch the automata here to ed=1 which is a big speedup.
name|actualEnum
operator|=
name|getAutomatonEnum
argument_list|(
name|maxEdits
argument_list|,
name|lastTerm
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|queuedBottom
operator|!=
literal|null
condition|)
block|{
name|bottomChanged
argument_list|(
name|queuedBottom
argument_list|)
expr_stmt|;
name|queuedBottom
operator|=
literal|null
expr_stmt|;
block|}
name|BytesRef
name|term
decl_stmt|;
name|term
operator|=
name|actualEnum
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|term
operator|==
literal|null
condition|)
block|{
comment|// end
return|return
literal|null
return|;
block|}
name|int
name|ed
init|=
name|maxEdits
decl_stmt|;
comment|// we know the outer DFA always matches.
comment|// now compute exact edit distance
while|while
condition|(
name|ed
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|term
argument_list|,
name|ed
operator|-
literal|1
argument_list|)
condition|)
block|{
name|ed
operator|--
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ed
operator|==
literal|0
condition|)
block|{
comment|// exact match
name|boostAtt
operator|.
name|setBoost
argument_list|(
literal|1.0F
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|codePointCount
init|=
name|UnicodeUtil
operator|.
name|codePointCount
argument_list|(
name|term
argument_list|)
decl_stmt|;
name|int
name|minTermLength
init|=
name|Math
operator|.
name|min
argument_list|(
name|codePointCount
argument_list|,
name|termLength
argument_list|)
decl_stmt|;
name|float
name|similarity
init|=
literal|1.0f
operator|-
operator|(
name|float
operator|)
name|ed
operator|/
operator|(
name|float
operator|)
name|minTermLength
decl_stmt|;
name|boostAtt
operator|.
name|setBoost
argument_list|(
name|similarity
argument_list|)
expr_stmt|;
block|}
specifier|final
name|float
name|bottom
init|=
name|maxBoostAtt
operator|.
name|getMaxNonCompetitiveBoost
argument_list|()
decl_stmt|;
specifier|final
name|BytesRef
name|bottomTerm
init|=
name|maxBoostAtt
operator|.
name|getCompetitiveTerm
argument_list|()
decl_stmt|;
if|if
condition|(
name|term
operator|!=
literal|null
operator|&&
operator|(
name|bottom
operator|!=
name|this
operator|.
name|bottom
operator|||
name|bottomTerm
operator|!=
name|this
operator|.
name|bottomTerm
operator|)
condition|)
block|{
name|this
operator|.
name|bottom
operator|=
name|bottom
expr_stmt|;
name|this
operator|.
name|bottomTerm
operator|=
name|bottomTerm
expr_stmt|;
comment|// clone the term before potentially doing something with it
comment|// this is a rare but wonderful occurrence anyway
comment|// We must delay bottomChanged until the next next() call otherwise we mess up docFreq(), etc., for the current term:
name|queuedBottom
operator|=
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
return|return
name|term
return|;
block|}
comment|/** returns true if term is within k edits of the query term */
DECL|method|matches
specifier|private
name|boolean
name|matches
parameter_list|(
name|BytesRef
name|termIn
parameter_list|,
name|int
name|k
parameter_list|)
block|{
return|return
name|k
operator|==
literal|0
condition|?
name|termIn
operator|.
name|equals
argument_list|(
name|term
operator|.
name|bytes
argument_list|()
argument_list|)
else|:
name|automata
index|[
name|k
index|]
operator|.
name|runAutomaton
operator|.
name|run
argument_list|(
name|termIn
operator|.
name|bytes
argument_list|,
name|termIn
operator|.
name|offset
argument_list|,
name|termIn
operator|.
name|length
argument_list|)
return|;
block|}
comment|// proxy all other enum calls to the actual enum
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|docFreq
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|totalTermFreq
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|postings
specifier|public
name|PostingsEnum
name|postings
parameter_list|(
name|PostingsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|postings
argument_list|(
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|TermState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
name|actualEnum
operator|.
name|seekExact
argument_list|(
name|term
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|termState
specifier|public
name|TermState
name|termState
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|termState
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|ord
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|boolean
name|seekExact
parameter_list|(
name|BytesRef
name|text
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|seekExact
argument_list|(
name|text
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
name|BytesRef
name|text
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|seekCeil
argument_list|(
name|text
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
name|actualEnum
operator|.
name|seekExact
argument_list|(
name|ord
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|term
argument_list|()
return|;
block|}
comment|/**    * reuses compiled automata across different segments,    * because they are independent of the index    * @lucene.internal */
DECL|interface|LevenshteinAutomataAttribute
specifier|public
specifier|static
interface|interface
name|LevenshteinAutomataAttribute
extends|extends
name|Attribute
block|{
DECL|method|automata
specifier|public
name|CompiledAutomaton
index|[]
name|automata
parameter_list|()
function_decl|;
DECL|method|setAutomata
specifier|public
name|void
name|setAutomata
parameter_list|(
name|CompiledAutomaton
index|[]
name|automata
parameter_list|)
function_decl|;
block|}
comment|/**     * Stores compiled automata as a list (indexed by edit distance)    * @lucene.internal */
DECL|class|LevenshteinAutomataAttributeImpl
specifier|public
specifier|static
specifier|final
class|class
name|LevenshteinAutomataAttributeImpl
extends|extends
name|AttributeImpl
implements|implements
name|LevenshteinAutomataAttribute
block|{
DECL|field|automata
specifier|private
name|CompiledAutomaton
index|[]
name|automata
decl_stmt|;
annotation|@
name|Override
DECL|method|automata
specifier|public
name|CompiledAutomaton
index|[]
name|automata
parameter_list|()
block|{
return|return
name|automata
return|;
block|}
annotation|@
name|Override
DECL|method|setAutomata
specifier|public
name|void
name|setAutomata
parameter_list|(
name|CompiledAutomaton
index|[]
name|automata
parameter_list|)
block|{
name|this
operator|.
name|automata
operator|=
name|automata
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|automata
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
if|if
condition|(
name|automata
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|automata
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|other
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|LevenshteinAutomataAttributeImpl
operator|)
condition|)
return|return
literal|false
return|;
return|return
name|Arrays
operator|.
name|equals
argument_list|(
name|automata
argument_list|,
operator|(
operator|(
name|LevenshteinAutomataAttributeImpl
operator|)
name|other
operator|)
operator|.
name|automata
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|copyTo
specifier|public
name|void
name|copyTo
parameter_list|(
name|AttributeImpl
name|_target
parameter_list|)
block|{
name|LevenshteinAutomataAttribute
name|target
init|=
operator|(
name|LevenshteinAutomataAttribute
operator|)
name|_target
decl_stmt|;
if|if
condition|(
name|automata
operator|==
literal|null
condition|)
block|{
name|target
operator|.
name|setAutomata
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|.
name|setAutomata
argument_list|(
name|automata
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|reflectWith
specifier|public
name|void
name|reflectWith
parameter_list|(
name|AttributeReflector
name|reflector
parameter_list|)
block|{
name|reflector
operator|.
name|reflect
argument_list|(
name|LevenshteinAutomataAttribute
operator|.
name|class
argument_list|,
literal|"automata"
argument_list|,
name|automata
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

