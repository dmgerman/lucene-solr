begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.geo
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo
package|;
end_package

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/*   We accept either a whole type: Feature, like this:      { "type": "Feature",       "geometry": {          "type": "Polygon",          "coordinates": [            [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],              [100.0, 1.0], [100.0, 0.0] ]            ]        },        "properties": {          "prop0": "value0",          "prop1": {"this": "that"}          }        }     Or the inner object with type: Multi/Polygon.     Or a type: FeatureCollection, if it has only one Feature which is a Polygon or MultiPolyon.     type: MultiPolygon (union of polygons) is also accepted. */
end_comment

begin_comment
comment|/** Does minimal parsing of a GeoJSON object, to extract either Polygon or MultiPolygon, either directly as a the top-level type, or if  *  the top-level type is Feature, as the geometry of that feature. */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|class|SimpleGeoJSONPolygonParser
class|class
name|SimpleGeoJSONPolygonParser
block|{
DECL|field|input
specifier|final
name|String
name|input
decl_stmt|;
DECL|field|upto
specifier|private
name|int
name|upto
decl_stmt|;
DECL|field|polyType
specifier|private
name|String
name|polyType
decl_stmt|;
DECL|field|coordinates
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|coordinates
decl_stmt|;
DECL|method|SimpleGeoJSONPolygonParser
specifier|public
name|SimpleGeoJSONPolygonParser
parameter_list|(
name|String
name|input
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
block|}
DECL|method|parse
specifier|public
name|Polygon
index|[]
name|parse
parameter_list|()
throws|throws
name|ParseException
block|{
comment|// parse entire object
name|parseObject
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// make sure there's nothing left:
name|readEnd
argument_list|()
expr_stmt|;
comment|// The order of JSON object keys (type, geometry, coordinates in our case) can be arbitrary, so we wait until we are done parsing to
comment|// put the pieces together here:
if|if
condition|(
name|coordinates
operator|==
literal|null
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"did not see any polygon coordinates"
argument_list|)
throw|;
block|}
if|if
condition|(
name|polyType
operator|==
literal|null
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"did not see type: Polygon or MultiPolygon"
argument_list|)
throw|;
block|}
if|if
condition|(
name|polyType
operator|.
name|equals
argument_list|(
literal|"Polygon"
argument_list|)
condition|)
block|{
return|return
operator|new
name|Polygon
index|[]
block|{
name|parsePolygon
argument_list|(
name|coordinates
argument_list|)
block|}
return|;
block|}
else|else
block|{
name|List
argument_list|<
name|Polygon
argument_list|>
name|polygons
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|coordinates
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|o
init|=
name|coordinates
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|List
operator|==
literal|false
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"elements of coordinates array should be an array, but got: "
operator|+
name|o
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
name|polygons
operator|.
name|add
argument_list|(
name|parsePolygon
argument_list|(
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|polygons
operator|.
name|toArray
argument_list|(
operator|new
name|Polygon
index|[
name|polygons
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
comment|/** path is the "address" by keys of where we are, e.g. geometry.coordinates */
DECL|method|parseObject
specifier|private
name|void
name|parseObject
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|ParseException
block|{
name|scan
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|char
name|ch
init|=
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'}'
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|first
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|','
condition|)
block|{
comment|// ok
name|upto
operator|++
expr_stmt|;
name|ch
operator|=
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'}'
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
throw|throw
name|newParseException
argument_list|(
literal|"expected , but got "
operator|+
name|ch
argument_list|)
throw|;
block|}
block|}
name|first
operator|=
literal|false
expr_stmt|;
name|int
name|uptoStart
init|=
name|upto
decl_stmt|;
name|String
name|key
init|=
name|parseString
argument_list|()
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
literal|"crs.properties"
argument_list|)
operator|&&
name|key
operator|.
name|equals
argument_list|(
literal|"href"
argument_list|)
condition|)
block|{
name|upto
operator|=
name|uptoStart
expr_stmt|;
throw|throw
name|newParseException
argument_list|(
literal|"cannot handle linked crs"
argument_list|)
throw|;
block|}
name|scan
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|Object
name|o
decl_stmt|;
name|ch
operator|=
name|peek
argument_list|()
expr_stmt|;
name|uptoStart
operator|=
name|upto
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'['
condition|)
block|{
name|String
name|newPath
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|newPath
operator|=
name|key
expr_stmt|;
block|}
else|else
block|{
name|newPath
operator|=
name|path
operator|+
literal|"."
operator|+
name|key
expr_stmt|;
block|}
name|o
operator|=
name|parseArray
argument_list|(
name|newPath
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'{'
condition|)
block|{
name|String
name|newPath
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|newPath
operator|=
name|key
expr_stmt|;
block|}
else|else
block|{
name|newPath
operator|=
name|path
operator|+
literal|"."
operator|+
name|key
expr_stmt|;
block|}
name|parseObject
argument_list|(
name|newPath
argument_list|)
expr_stmt|;
name|o
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
block|{
name|o
operator|=
name|parseString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'t'
condition|)
block|{
name|scan
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
name|o
operator|=
name|Boolean
operator|.
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'f'
condition|)
block|{
name|scan
argument_list|(
literal|"false"
argument_list|)
expr_stmt|;
name|o
operator|=
name|Boolean
operator|.
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'n'
condition|)
block|{
name|scan
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
name|o
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'.'
operator|||
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|o
operator|=
name|parseNumber
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'}'
condition|)
block|{
break|break;
block|}
else|else
block|{
throw|throw
name|newParseException
argument_list|(
literal|"expected array, object, string or literal value, but got: "
operator|+
name|ch
argument_list|)
throw|;
block|}
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
literal|"crs.properties"
argument_list|)
operator|&&
name|key
operator|.
name|equals
argument_list|(
literal|"name"
argument_list|)
condition|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|String
operator|==
literal|false
condition|)
block|{
name|upto
operator|=
name|uptoStart
expr_stmt|;
throw|throw
name|newParseException
argument_list|(
literal|"crs.properties.name should be a string, but saw: "
operator|+
name|o
argument_list|)
throw|;
block|}
name|String
name|crs
init|=
operator|(
name|String
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|crs
operator|.
name|startsWith
argument_list|(
literal|"urn:ogc:def:crs:OGC"
argument_list|)
operator|==
literal|false
operator|||
name|crs
operator|.
name|endsWith
argument_list|(
literal|":CRS84"
argument_list|)
operator|==
literal|false
condition|)
block|{
name|upto
operator|=
name|uptoStart
expr_stmt|;
throw|throw
name|newParseException
argument_list|(
literal|"crs must be CRS84 from OGC, but saw: "
operator|+
name|o
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"type"
argument_list|)
operator|&&
name|path
operator|.
name|startsWith
argument_list|(
literal|"crs"
argument_list|)
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|String
operator|==
literal|false
condition|)
block|{
name|upto
operator|=
name|uptoStart
expr_stmt|;
throw|throw
name|newParseException
argument_list|(
literal|"type should be a string, but got: "
operator|+
name|o
argument_list|)
throw|;
block|}
name|String
name|type
init|=
operator|(
name|String
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Polygon"
argument_list|)
operator|&&
name|isValidGeometryPath
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|polyType
operator|=
literal|"Polygon"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"MultiPolygon"
argument_list|)
operator|&&
name|isValidGeometryPath
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|polyType
operator|=
literal|"MultiPolygon"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|.
name|equals
argument_list|(
literal|"FeatureCollection"
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
literal|"Feature"
argument_list|)
operator|)
operator|&&
operator|(
name|path
operator|.
name|equals
argument_list|(
literal|"features.[]"
argument_list|)
operator|||
name|path
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|)
condition|)
block|{
comment|// OK, we recurse
block|}
else|else
block|{
name|upto
operator|=
name|uptoStart
expr_stmt|;
throw|throw
name|newParseException
argument_list|(
literal|"can only handle type FeatureCollection (if it has a single polygon geometry), Feature, Polygon or MutiPolygon, but got "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"coordinates"
argument_list|)
operator|&&
name|isValidGeometryPath
argument_list|(
name|path
argument_list|)
condition|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|List
operator|==
literal|false
condition|)
block|{
name|upto
operator|=
name|uptoStart
expr_stmt|;
throw|throw
name|newParseException
argument_list|(
literal|"coordinates should be an array, but got: "
operator|+
name|o
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|coordinates
operator|!=
literal|null
condition|)
block|{
name|upto
operator|=
name|uptoStart
expr_stmt|;
throw|throw
name|newParseException
argument_list|(
literal|"only one Polygon or MultiPolygon is supported"
argument_list|)
throw|;
block|}
name|coordinates
operator|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|o
expr_stmt|;
block|}
block|}
name|scan
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
comment|/** Returns true if the object path is a valid location to see a Multi/Polygon geometry */
DECL|method|isValidGeometryPath
specifier|private
name|boolean
name|isValidGeometryPath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
name|path
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|||
name|path
operator|.
name|equals
argument_list|(
literal|"geometry"
argument_list|)
operator|||
name|path
operator|.
name|equals
argument_list|(
literal|"features.[].geometry"
argument_list|)
return|;
block|}
DECL|method|parsePolygon
specifier|private
name|Polygon
name|parsePolygon
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|coordinates
parameter_list|)
throws|throws
name|ParseException
block|{
name|List
argument_list|<
name|Polygon
argument_list|>
name|holes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Object
name|o
init|=
name|coordinates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|List
operator|==
literal|false
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"first element of polygon array must be an array [[lat, lon], [lat, lon] ...] but got: "
operator|+
name|o
argument_list|)
throw|;
block|}
name|double
index|[]
index|[]
name|polyPoints
init|=
name|parsePoints
argument_list|(
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|o
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|coordinates
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|o
operator|=
name|coordinates
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|List
operator|==
literal|false
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"elements of coordinates array must be an array [[lat, lon], [lat, lon] ...] but got: "
operator|+
name|o
argument_list|)
throw|;
block|}
name|double
index|[]
index|[]
name|holePoints
init|=
name|parsePoints
argument_list|(
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|o
argument_list|)
decl_stmt|;
name|holes
operator|.
name|add
argument_list|(
operator|new
name|Polygon
argument_list|(
name|holePoints
index|[
literal|0
index|]
argument_list|,
name|holePoints
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Polygon
argument_list|(
name|polyPoints
index|[
literal|0
index|]
argument_list|,
name|polyPoints
index|[
literal|1
index|]
argument_list|,
name|holes
operator|.
name|toArray
argument_list|(
operator|new
name|Polygon
index|[
name|holes
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
comment|/** Parses [[lat, lon], [lat, lon] ...] into 2d double array */
DECL|method|parsePoints
specifier|private
name|double
index|[]
index|[]
name|parsePoints
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|o
parameter_list|)
throws|throws
name|ParseException
block|{
name|double
index|[]
name|lats
init|=
operator|new
name|double
index|[
name|o
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|double
index|[]
name|lons
init|=
operator|new
name|double
index|[
name|o
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|o
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|point
init|=
name|o
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|point
operator|instanceof
name|List
operator|==
literal|false
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"elements of coordinates array must [lat, lon] array, but got: "
operator|+
name|point
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Object
argument_list|>
name|pointList
init|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|point
decl_stmt|;
if|if
condition|(
name|pointList
operator|.
name|size
argument_list|()
operator|!=
literal|2
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"elements of coordinates array must [lat, lon] array, but got wrong element count: "
operator|+
name|pointList
argument_list|)
throw|;
block|}
if|if
condition|(
name|pointList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|Double
operator|==
literal|false
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"elements of coordinates array must [lat, lon] array, but first element is not a Double: "
operator|+
name|pointList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|pointList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|Double
operator|==
literal|false
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"elements of coordinates array must [lat, lon] array, but second element is not a Double: "
operator|+
name|pointList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
throw|;
block|}
comment|// lon, lat ordering in GeoJSON!
name|lons
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|Double
operator|)
name|pointList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|doubleValue
argument_list|()
expr_stmt|;
name|lats
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|Double
operator|)
name|pointList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|doubleValue
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|double
index|[]
index|[]
block|{
name|lats
block|,
name|lons
block|}
return|;
block|}
DECL|method|parseArray
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|parseArray
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|ParseException
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|scan
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
while|while
condition|(
name|upto
operator|<
name|input
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|ch
init|=
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|']'
condition|)
block|{
name|scan
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|result
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ch
operator|!=
literal|','
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"expected ',' separating list items, but got '"
operator|+
name|ch
operator|+
literal|"'"
argument_list|)
throw|;
block|}
comment|// skip the ,
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|upto
operator|==
name|input
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"hit EOF while parsing array"
argument_list|)
throw|;
block|}
name|ch
operator|=
name|peek
argument_list|()
expr_stmt|;
block|}
name|Object
name|o
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'['
condition|)
block|{
name|o
operator|=
name|parseArray
argument_list|(
name|path
operator|+
literal|".[]"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'{'
condition|)
block|{
comment|// This is only used when parsing the "features" in type: FeatureCollection
name|parseObject
argument_list|(
name|path
operator|+
literal|".[]"
argument_list|)
expr_stmt|;
name|o
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'.'
operator|||
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|o
operator|=
name|parseNumber
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|newParseException
argument_list|(
literal|"expected another array or number while parsing array, not '"
operator|+
name|ch
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|result
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
throw|throw
name|newParseException
argument_list|(
literal|"hit EOF while reading array"
argument_list|)
throw|;
block|}
DECL|method|parseNumber
specifier|private
name|Number
name|parseNumber
parameter_list|()
throws|throws
name|ParseException
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|uptoStart
init|=
name|upto
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|input
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|ch
init|=
name|input
operator|.
name|charAt
argument_list|(
name|upto
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'.'
operator|||
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
name|ch
operator|==
literal|'e'
operator|||
name|ch
operator|==
literal|'E'
condition|)
block|{
name|upto
operator|++
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// we only handle doubles
try|try
block|{
return|return
name|Double
operator|.
name|parseDouble
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|upto
operator|=
name|uptoStart
expr_stmt|;
throw|throw
name|newParseException
argument_list|(
literal|"could not parse number as double"
argument_list|)
throw|;
block|}
block|}
DECL|method|parseString
specifier|private
name|String
name|parseString
parameter_list|()
throws|throws
name|ParseException
block|{
name|scan
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|input
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|ch
init|=
name|input
operator|.
name|charAt
argument_list|(
name|upto
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
block|{
name|upto
operator|++
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|// an escaped character
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|upto
operator|==
name|input
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"hit EOF inside string literal"
argument_list|)
throw|;
block|}
name|ch
operator|=
name|input
operator|.
name|charAt
argument_list|(
name|upto
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'u'
condition|)
block|{
comment|// 4 hex digit unicode BMP escape
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|upto
operator|+
literal|4
operator|>
name|input
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"hit EOF inside string literal"
argument_list|)
throw|;
block|}
name|b
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|input
operator|.
name|substring
argument_list|(
name|upto
argument_list|,
name|upto
operator|+
literal|4
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: allow \n, \t, etc.???
throw|throw
name|newParseException
argument_list|(
literal|"unsupported string escape character \\"
operator|+
name|ch
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|b
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
block|}
throw|throw
name|newParseException
argument_list|(
literal|"hit EOF inside string literal"
argument_list|)
throw|;
block|}
DECL|method|peek
specifier|private
name|char
name|peek
parameter_list|()
throws|throws
name|ParseException
block|{
while|while
condition|(
name|upto
operator|<
name|input
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|ch
init|=
name|input
operator|.
name|charAt
argument_list|(
name|upto
argument_list|)
decl_stmt|;
if|if
condition|(
name|isJSONWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|upto
operator|++
expr_stmt|;
continue|continue;
block|}
return|return
name|ch
return|;
block|}
throw|throw
name|newParseException
argument_list|(
literal|"unexpected EOF"
argument_list|)
throw|;
block|}
comment|/** Scans across whitespace and consumes the expected character, or throws {@code ParseException} if the character is wrong */
DECL|method|scan
specifier|private
name|void
name|scan
parameter_list|(
name|char
name|expected
parameter_list|)
throws|throws
name|ParseException
block|{
while|while
condition|(
name|upto
operator|<
name|input
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|ch
init|=
name|input
operator|.
name|charAt
argument_list|(
name|upto
argument_list|)
decl_stmt|;
if|if
condition|(
name|isJSONWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|upto
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|!=
name|expected
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"expected '"
operator|+
name|expected
operator|+
literal|"' but got '"
operator|+
name|ch
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|upto
operator|++
expr_stmt|;
return|return;
block|}
throw|throw
name|newParseException
argument_list|(
literal|"expected '"
operator|+
name|expected
operator|+
literal|"' but got EOF"
argument_list|)
throw|;
block|}
DECL|method|readEnd
specifier|private
name|void
name|readEnd
parameter_list|()
throws|throws
name|ParseException
block|{
while|while
condition|(
name|upto
operator|<
name|input
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|ch
init|=
name|input
operator|.
name|charAt
argument_list|(
name|upto
argument_list|)
decl_stmt|;
if|if
condition|(
name|isJSONWhitespace
argument_list|(
name|ch
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"unexpected character '"
operator|+
name|ch
operator|+
literal|"' after end of GeoJSON object"
argument_list|)
throw|;
block|}
name|upto
operator|++
expr_stmt|;
block|}
block|}
comment|/** Scans the expected string, or throws {@code ParseException} */
DECL|method|scan
specifier|private
name|void
name|scan
parameter_list|(
name|String
name|expected
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|upto
operator|+
name|expected
operator|.
name|length
argument_list|()
operator|>
name|input
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"expected \""
operator|+
name|expected
operator|+
literal|"\" but hit EOF"
argument_list|)
throw|;
block|}
name|String
name|subString
init|=
name|input
operator|.
name|substring
argument_list|(
name|upto
argument_list|,
name|upto
operator|+
name|expected
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|subString
operator|.
name|equals
argument_list|(
name|expected
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
name|newParseException
argument_list|(
literal|"expected \""
operator|+
name|expected
operator|+
literal|"\" but got \""
operator|+
name|subString
operator|+
literal|"\""
argument_list|)
throw|;
block|}
name|upto
operator|+=
name|expected
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
DECL|method|isJSONWhitespace
specifier|private
specifier|static
name|boolean
name|isJSONWhitespace
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
comment|// JSON doesn't accept allow unicode whitespace?
return|return
name|ch
operator|==
literal|0x20
operator|||
comment|// space
name|ch
operator|==
literal|0x09
operator|||
comment|// tab
name|ch
operator|==
literal|0x0a
operator|||
comment|// line feed
name|ch
operator|==
literal|0x0d
return|;
comment|// newline
block|}
comment|/** When calling this, upto should be at the position of the incorrect character! */
DECL|method|newParseException
specifier|private
name|ParseException
name|newParseException
parameter_list|(
name|String
name|details
parameter_list|)
throws|throws
name|ParseException
block|{
name|String
name|fragment
decl_stmt|;
name|int
name|end
init|=
name|Math
operator|.
name|min
argument_list|(
name|input
operator|.
name|length
argument_list|()
argument_list|,
name|upto
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|upto
operator|<
literal|50
condition|)
block|{
name|fragment
operator|=
name|input
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fragment
operator|=
literal|"..."
operator|+
name|input
operator|.
name|substring
argument_list|(
name|upto
operator|-
literal|50
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ParseException
argument_list|(
name|details
operator|+
literal|" at character offset "
operator|+
name|upto
operator|+
literal|"; fragment leading to this:\n"
operator|+
name|fragment
argument_list|,
name|upto
argument_list|)
return|;
block|}
block|}
end_class

end_unit

