begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.geo
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PointValues
operator|.
name|Relation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|NumericUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|SloppyMath
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo
operator|.
name|GeoUtils
operator|.
name|MAX_LAT_INCL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo
operator|.
name|GeoUtils
operator|.
name|MAX_LON_INCL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo
operator|.
name|GeoUtils
operator|.
name|MIN_LON_INCL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo
operator|.
name|GeoUtils
operator|.
name|MIN_LAT_INCL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo
operator|.
name|GeoUtils
operator|.
name|checkLatitude
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo
operator|.
name|GeoUtils
operator|.
name|checkLongitude
import|;
end_import

begin_comment
comment|/**  * reusable geopoint encoding methods  *  * @lucene.experimental  */
end_comment

begin_class
DECL|class|GeoEncodingUtils
specifier|public
specifier|final
class|class
name|GeoEncodingUtils
block|{
comment|/** number of bits used for quantizing latitude and longitude values */
DECL|field|BITS
specifier|public
specifier|static
specifier|final
name|short
name|BITS
init|=
literal|32
decl_stmt|;
DECL|field|LAT_SCALE
specifier|private
specifier|static
specifier|final
name|double
name|LAT_SCALE
init|=
operator|(
literal|0x1L
operator|<<
name|BITS
operator|)
operator|/
literal|180.0D
decl_stmt|;
DECL|field|LAT_DECODE
specifier|private
specifier|static
specifier|final
name|double
name|LAT_DECODE
init|=
literal|1
operator|/
name|LAT_SCALE
decl_stmt|;
DECL|field|LON_SCALE
specifier|private
specifier|static
specifier|final
name|double
name|LON_SCALE
init|=
operator|(
literal|0x1L
operator|<<
name|BITS
operator|)
operator|/
literal|360.0D
decl_stmt|;
DECL|field|LON_DECODE
specifier|private
specifier|static
specifier|final
name|double
name|LON_DECODE
init|=
literal|1
operator|/
name|LON_SCALE
decl_stmt|;
comment|// No instance:
DECL|method|GeoEncodingUtils
specifier|private
name|GeoEncodingUtils
parameter_list|()
block|{   }
comment|/**    * Quantizes double (64 bit) latitude into 32 bits (rounding down: in the direction of -90)    * @param latitude latitude value: must be within standard +/-90 coordinate bounds.    * @return encoded value as a 32-bit {@code int}    * @throws IllegalArgumentException if latitude is out of bounds    */
DECL|method|encodeLatitude
specifier|public
specifier|static
name|int
name|encodeLatitude
parameter_list|(
name|double
name|latitude
parameter_list|)
block|{
name|checkLatitude
argument_list|(
name|latitude
argument_list|)
expr_stmt|;
comment|// the maximum possible value cannot be encoded without overflow
if|if
condition|(
name|latitude
operator|==
literal|90.0D
condition|)
block|{
name|latitude
operator|=
name|Math
operator|.
name|nextDown
argument_list|(
name|latitude
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|latitude
operator|/
name|LAT_DECODE
argument_list|)
return|;
block|}
comment|/**    * Quantizes double (64 bit) latitude into 32 bits (rounding up: in the direction of +90)    * @param latitude latitude value: must be within standard +/-90 coordinate bounds.    * @return encoded value as a 32-bit {@code int}    * @throws IllegalArgumentException if latitude is out of bounds    */
DECL|method|encodeLatitudeCeil
specifier|public
specifier|static
name|int
name|encodeLatitudeCeil
parameter_list|(
name|double
name|latitude
parameter_list|)
block|{
name|GeoUtils
operator|.
name|checkLatitude
argument_list|(
name|latitude
argument_list|)
expr_stmt|;
comment|// the maximum possible value cannot be encoded without overflow
if|if
condition|(
name|latitude
operator|==
literal|90.0D
condition|)
block|{
name|latitude
operator|=
name|Math
operator|.
name|nextDown
argument_list|(
name|latitude
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|latitude
operator|/
name|LAT_DECODE
argument_list|)
return|;
block|}
comment|/**    * Quantizes double (64 bit) longitude into 32 bits (rounding down: in the direction of -180)    * @param longitude longitude value: must be within standard +/-180 coordinate bounds.    * @return encoded value as a 32-bit {@code int}    * @throws IllegalArgumentException if longitude is out of bounds    */
DECL|method|encodeLongitude
specifier|public
specifier|static
name|int
name|encodeLongitude
parameter_list|(
name|double
name|longitude
parameter_list|)
block|{
name|checkLongitude
argument_list|(
name|longitude
argument_list|)
expr_stmt|;
comment|// the maximum possible value cannot be encoded without overflow
if|if
condition|(
name|longitude
operator|==
literal|180.0D
condition|)
block|{
name|longitude
operator|=
name|Math
operator|.
name|nextDown
argument_list|(
name|longitude
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|longitude
operator|/
name|LON_DECODE
argument_list|)
return|;
block|}
comment|/**    * Quantizes double (64 bit) longitude into 32 bits (rounding up: in the direction of +180)    * @param longitude longitude value: must be within standard +/-180 coordinate bounds.    * @return encoded value as a 32-bit {@code int}    * @throws IllegalArgumentException if longitude is out of bounds    */
DECL|method|encodeLongitudeCeil
specifier|public
specifier|static
name|int
name|encodeLongitudeCeil
parameter_list|(
name|double
name|longitude
parameter_list|)
block|{
name|GeoUtils
operator|.
name|checkLongitude
argument_list|(
name|longitude
argument_list|)
expr_stmt|;
comment|// the maximum possible value cannot be encoded without overflow
if|if
condition|(
name|longitude
operator|==
literal|180.0D
condition|)
block|{
name|longitude
operator|=
name|Math
operator|.
name|nextDown
argument_list|(
name|longitude
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|longitude
operator|/
name|LON_DECODE
argument_list|)
return|;
block|}
comment|/**    * Turns quantized value from {@link #encodeLatitude} back into a double.    * @param encoded encoded value: 32-bit quantized value.    * @return decoded latitude value.    */
DECL|method|decodeLatitude
specifier|public
specifier|static
name|double
name|decodeLatitude
parameter_list|(
name|int
name|encoded
parameter_list|)
block|{
name|double
name|result
init|=
name|encoded
operator|*
name|LAT_DECODE
decl_stmt|;
assert|assert
name|result
operator|>=
name|MIN_LAT_INCL
operator|&&
name|result
operator|<
name|MAX_LAT_INCL
assert|;
return|return
name|result
return|;
block|}
comment|/**    * Turns quantized value from byte array back into a double.    * @param src byte array containing 4 bytes to decode at {@code offset}    * @param offset offset into {@code src} to decode from.    * @return decoded latitude value.    */
DECL|method|decodeLatitude
specifier|public
specifier|static
name|double
name|decodeLatitude
parameter_list|(
name|byte
index|[]
name|src
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
name|decodeLatitude
argument_list|(
name|NumericUtils
operator|.
name|sortableBytesToInt
argument_list|(
name|src
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Turns quantized value from {@link #encodeLongitude} back into a double.    * @param encoded encoded value: 32-bit quantized value.    * @return decoded longitude value.    */
DECL|method|decodeLongitude
specifier|public
specifier|static
name|double
name|decodeLongitude
parameter_list|(
name|int
name|encoded
parameter_list|)
block|{
name|double
name|result
init|=
name|encoded
operator|*
name|LON_DECODE
decl_stmt|;
assert|assert
name|result
operator|>=
name|MIN_LON_INCL
operator|&&
name|result
operator|<
name|MAX_LON_INCL
assert|;
return|return
name|result
return|;
block|}
comment|/**    * Turns quantized value from byte array back into a double.    * @param src byte array containing 4 bytes to decode at {@code offset}    * @param offset offset into {@code src} to decode from.    * @return decoded longitude value.    */
DECL|method|decodeLongitude
specifier|public
specifier|static
name|double
name|decodeLongitude
parameter_list|(
name|byte
index|[]
name|src
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
name|decodeLongitude
argument_list|(
name|NumericUtils
operator|.
name|sortableBytesToInt
argument_list|(
name|src
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
comment|/** Create a predicate that checks whether points are within a distance of a given point.    *  It works by computing the bounding box around the circle that is defined    *  by the given points/distance and splitting it into between 1024 and 4096    *  smaller boxes (4096*0.75^2=2304 on average). Then for each sub box, it    *  computes the relation between this box and the distance query. Finally at    *  search time, it first computes the sub box that the point belongs to,    *  most of the time, no distance computation will need to be performed since    *  all points from the sub box will either be in or out of the circle.    *  @lucene.internal */
DECL|method|createDistancePredicate
specifier|public
specifier|static
name|DistancePredicate
name|createDistancePredicate
parameter_list|(
name|double
name|lat
parameter_list|,
name|double
name|lon
parameter_list|,
name|double
name|radiusMeters
parameter_list|)
block|{
specifier|final
name|Rectangle
name|boundingBox
init|=
name|Rectangle
operator|.
name|fromPointDistance
argument_list|(
name|lat
argument_list|,
name|lon
argument_list|,
name|radiusMeters
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minLat
init|=
name|encodeLatitudeCeil
argument_list|(
name|boundingBox
operator|.
name|minLat
argument_list|)
decl_stmt|;
specifier|final
name|int
name|maxLat
init|=
name|encodeLatitude
argument_list|(
name|boundingBox
operator|.
name|maxLat
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minLon
init|=
name|encodeLongitudeCeil
argument_list|(
name|boundingBox
operator|.
name|minLon
argument_list|)
decl_stmt|;
specifier|final
name|int
name|maxLon
init|=
name|encodeLongitude
argument_list|(
name|boundingBox
operator|.
name|maxLon
argument_list|)
decl_stmt|;
specifier|final
name|int
name|latShift
decl_stmt|,
name|lonShift
decl_stmt|;
specifier|final
name|int
name|latBase
decl_stmt|,
name|lonBase
decl_stmt|;
specifier|final
name|int
name|maxLatDelta
decl_stmt|,
name|maxLonDelta
decl_stmt|;
block|{
name|long
name|minLat2
init|=
operator|(
name|long
operator|)
name|minLat
operator|-
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
name|long
name|maxLat2
init|=
operator|(
name|long
operator|)
name|maxLat
operator|-
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
name|latShift
operator|=
name|computeShift
argument_list|(
name|minLat2
argument_list|,
name|maxLat2
argument_list|)
expr_stmt|;
name|latBase
operator|=
call|(
name|int
call|)
argument_list|(
name|minLat2
operator|>>>
name|latShift
argument_list|)
expr_stmt|;
name|maxLatDelta
operator|=
call|(
name|int
call|)
argument_list|(
name|maxLat2
operator|>>>
name|latShift
argument_list|)
operator|-
name|latBase
operator|+
literal|1
expr_stmt|;
assert|assert
name|maxLatDelta
operator|>
literal|0
assert|;
block|}
block|{
name|long
name|minLon2
init|=
operator|(
name|long
operator|)
name|minLon
operator|-
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
name|long
name|maxLon2
init|=
operator|(
name|long
operator|)
name|maxLon
operator|-
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
if|if
condition|(
name|boundingBox
operator|.
name|crossesDateline
argument_list|()
condition|)
block|{
name|maxLon2
operator|+=
literal|1L
operator|<<
literal|32
expr_stmt|;
comment|// wrap
block|}
name|lonShift
operator|=
name|computeShift
argument_list|(
name|minLon2
argument_list|,
name|maxLon2
argument_list|)
expr_stmt|;
name|lonBase
operator|=
call|(
name|int
call|)
argument_list|(
name|minLon2
operator|>>>
name|lonShift
argument_list|)
expr_stmt|;
name|maxLonDelta
operator|=
call|(
name|int
call|)
argument_list|(
name|maxLon2
operator|>>>
name|lonShift
argument_list|)
operator|-
name|lonBase
operator|+
literal|1
expr_stmt|;
assert|assert
name|maxLonDelta
operator|>
literal|0
assert|;
block|}
specifier|final
name|double
name|axisLat
init|=
name|Rectangle
operator|.
name|axisLat
argument_list|(
name|lat
argument_list|,
name|radiusMeters
argument_list|)
decl_stmt|;
specifier|final
name|double
name|distanceSortKey
init|=
name|GeoUtils
operator|.
name|distanceQuerySortKey
argument_list|(
name|radiusMeters
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|relations
init|=
operator|new
name|byte
index|[
name|maxLatDelta
operator|*
name|maxLonDelta
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxLatDelta
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|maxLonDelta
condition|;
operator|++
name|j
control|)
block|{
specifier|final
name|int
name|boxMinLat
init|=
operator|(
operator|(
name|latBase
operator|+
name|i
operator|)
operator|<<
name|latShift
operator|)
operator|+
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
specifier|final
name|int
name|boxMinLon
init|=
operator|(
operator|(
name|lonBase
operator|+
name|j
operator|)
operator|<<
name|lonShift
operator|)
operator|+
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
specifier|final
name|int
name|boxMaxLat
init|=
name|boxMinLat
operator|+
operator|(
literal|1
operator|<<
name|latShift
operator|)
operator|-
literal|1
decl_stmt|;
specifier|final
name|int
name|boxMaxLon
init|=
name|boxMinLon
operator|+
operator|(
literal|1
operator|<<
name|lonShift
operator|)
operator|-
literal|1
decl_stmt|;
name|relations
index|[
name|i
operator|*
name|maxLonDelta
operator|+
name|j
index|]
operator|=
operator|(
name|byte
operator|)
name|GeoUtils
operator|.
name|relate
argument_list|(
name|decodeLatitude
argument_list|(
name|boxMinLat
argument_list|)
argument_list|,
name|decodeLatitude
argument_list|(
name|boxMaxLat
argument_list|)
argument_list|,
name|decodeLongitude
argument_list|(
name|boxMinLon
argument_list|)
argument_list|,
name|decodeLongitude
argument_list|(
name|boxMaxLon
argument_list|)
argument_list|,
name|lat
argument_list|,
name|lon
argument_list|,
name|distanceSortKey
argument_list|,
name|axisLat
argument_list|)
operator|.
name|ordinal
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|new
name|DistancePredicate
argument_list|(
name|latShift
argument_list|,
name|lonShift
argument_list|,
name|latBase
argument_list|,
name|lonBase
argument_list|,
name|maxLatDelta
argument_list|,
name|maxLonDelta
argument_list|,
name|relations
argument_list|,
name|lat
argument_list|,
name|lon
argument_list|,
name|distanceSortKey
argument_list|)
return|;
block|}
comment|/** Compute the minimum shift value so that    * {@code (b>>>shift)-(a>>>shift)} is less that {@code ARITY}. */
DECL|method|computeShift
specifier|private
specifier|static
name|int
name|computeShift
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
assert|assert
name|a
operator|<
name|b
assert|;
comment|// We enforce a shift of at least 1 so that when we work with unsigned ints
comment|// by doing (lat - MIN_VALUE), the result of the shift (lat - MIN_VALUE)>>> shift
comment|// can be used for comparisons without particular care: the sign bit has
comment|// been cleared so comparisons work the same for signed and unsigned ints
for|for
control|(
name|int
name|shift
init|=
literal|1
init|;
condition|;
operator|++
name|shift
control|)
block|{
specifier|final
name|long
name|delta
init|=
operator|(
name|b
operator|>>>
name|shift
operator|)
operator|-
operator|(
name|a
operator|>>>
name|shift
operator|)
decl_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0
operator|&&
name|delta
operator|<
name|DistancePredicate
operator|.
name|ARITY
condition|)
block|{
return|return
name|shift
return|;
block|}
block|}
block|}
comment|/** A predicate that checks whether a given point is within a distance of another point. */
DECL|class|DistancePredicate
specifier|public
specifier|static
class|class
name|DistancePredicate
block|{
DECL|field|ARITY
specifier|private
specifier|static
specifier|final
name|int
name|ARITY
init|=
literal|64
decl_stmt|;
DECL|field|latShift
DECL|field|lonShift
specifier|private
specifier|final
name|int
name|latShift
decl_stmt|,
name|lonShift
decl_stmt|;
DECL|field|latBase
DECL|field|lonBase
specifier|private
specifier|final
name|int
name|latBase
decl_stmt|,
name|lonBase
decl_stmt|;
DECL|field|maxLatDelta
DECL|field|maxLonDelta
specifier|private
specifier|final
name|int
name|maxLatDelta
decl_stmt|,
name|maxLonDelta
decl_stmt|;
DECL|field|relations
specifier|private
specifier|final
name|byte
index|[]
name|relations
decl_stmt|;
DECL|field|lat
DECL|field|lon
specifier|private
specifier|final
name|double
name|lat
decl_stmt|,
name|lon
decl_stmt|;
DECL|field|distanceKey
specifier|private
specifier|final
name|double
name|distanceKey
decl_stmt|;
DECL|method|DistancePredicate
specifier|private
name|DistancePredicate
parameter_list|(
name|int
name|latShift
parameter_list|,
name|int
name|lonShift
parameter_list|,
name|int
name|latBase
parameter_list|,
name|int
name|lonBase
parameter_list|,
name|int
name|maxLatDelta
parameter_list|,
name|int
name|maxLonDelta
parameter_list|,
name|byte
index|[]
name|relations
parameter_list|,
name|double
name|lat
parameter_list|,
name|double
name|lon
parameter_list|,
name|double
name|distanceKey
parameter_list|)
block|{
name|this
operator|.
name|latShift
operator|=
name|latShift
expr_stmt|;
name|this
operator|.
name|lonShift
operator|=
name|lonShift
expr_stmt|;
name|this
operator|.
name|latBase
operator|=
name|latBase
expr_stmt|;
name|this
operator|.
name|lonBase
operator|=
name|lonBase
expr_stmt|;
name|this
operator|.
name|maxLatDelta
operator|=
name|maxLatDelta
expr_stmt|;
name|this
operator|.
name|maxLonDelta
operator|=
name|maxLonDelta
expr_stmt|;
name|this
operator|.
name|relations
operator|=
name|relations
expr_stmt|;
name|this
operator|.
name|lat
operator|=
name|lat
expr_stmt|;
name|this
operator|.
name|lon
operator|=
name|lon
expr_stmt|;
name|this
operator|.
name|distanceKey
operator|=
name|distanceKey
expr_stmt|;
block|}
comment|/** Check whether the given point is within a distance of another point.      *  NOTE: this operates directly on the encoded representation of points. */
DECL|method|apply
specifier|public
name|boolean
name|apply
parameter_list|(
name|int
name|lat
parameter_list|,
name|int
name|lon
parameter_list|)
block|{
specifier|final
name|int
name|lat2
init|=
operator|(
operator|(
name|lat
operator|-
name|Integer
operator|.
name|MIN_VALUE
operator|)
operator|>>>
name|latShift
operator|)
decl_stmt|;
if|if
condition|(
name|lat2
operator|<
name|latBase
operator|||
name|lat2
operator|>=
name|latBase
operator|+
name|maxLatDelta
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|lon2
init|=
operator|(
operator|(
name|lon
operator|-
name|Integer
operator|.
name|MIN_VALUE
operator|)
operator|>>>
name|lonShift
operator|)
decl_stmt|;
if|if
condition|(
name|lon2
operator|<
name|lonBase
condition|)
block|{
comment|// wrap
name|lon2
operator|+=
literal|1L
operator|<<
operator|(
literal|32
operator|-
name|lonShift
operator|)
expr_stmt|;
assert|assert
name|lon2
operator|>=
name|lonBase
assert|;
block|}
if|if
condition|(
name|lon2
operator|-
name|lonBase
operator|>=
name|maxLonDelta
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|relation
init|=
name|relations
index|[
operator|(
name|lat2
operator|-
name|latBase
operator|)
operator|*
name|maxLonDelta
operator|+
operator|(
name|lon2
operator|-
name|lonBase
operator|)
index|]
decl_stmt|;
if|if
condition|(
name|relation
operator|==
name|Relation
operator|.
name|CELL_CROSSES_QUERY
operator|.
name|ordinal
argument_list|()
condition|)
block|{
return|return
name|SloppyMath
operator|.
name|haversinSortKey
argument_list|(
name|decodeLatitude
argument_list|(
name|lat
argument_list|)
argument_list|,
name|decodeLongitude
argument_list|(
name|lon
argument_list|)
argument_list|,
name|this
operator|.
name|lat
argument_list|,
name|this
operator|.
name|lon
argument_list|)
operator|<=
name|distanceKey
return|;
block|}
else|else
block|{
return|return
name|relation
operator|==
name|Relation
operator|.
name|CELL_INSIDE_QUERY
operator|.
name|ordinal
argument_list|()
return|;
block|}
block|}
block|}
block|}
end_class

end_unit

