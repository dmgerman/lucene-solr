begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.util.fst
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|InputStreamDataInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|OutputStreamDataOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import

begin_comment
comment|// TODO: break this into WritableFST and ReadOnlyFST.. then
end_comment

begin_comment
comment|// we can have subclasses of ReadOnlyFST to handle the
end_comment

begin_comment
comment|// different byte[] level encodings (packed or
end_comment

begin_comment
comment|// not)... and things like nodeCount, arcCount are read only
end_comment

begin_comment
comment|// TODO: if FST is pure prefix trie we can do a more compact
end_comment

begin_comment
comment|// job, ie, once we are at a 'suffix only', just store the
end_comment

begin_comment
comment|// completion labels as a string not as a series of arcs.
end_comment

begin_comment
comment|// NOTE: while the FST is able to represent a non-final
end_comment

begin_comment
comment|// dead-end state (NON_FINAL_END_NODE=0), the layers above
end_comment

begin_comment
comment|// (FSTEnum, Util) have problems with this!!
end_comment

begin_comment
comment|/** Represents an finite state machine (FST), using a  *  compact byte[] format.  *<p> The format is similar to what's used by Morfologik  *  (http://sourceforge.net/projects/morfologik).  *    *<p> See the {@link org.apache.lucene.util.fst package  *      documentation} for some simple examples.  *  * @lucene.experimental  */
end_comment

begin_class
DECL|class|FST
specifier|public
specifier|final
class|class
name|FST
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Accountable
block|{
DECL|field|BASE_RAM_BYTES_USED
specifier|private
specifier|static
specifier|final
name|long
name|BASE_RAM_BYTES_USED
init|=
name|RamUsageEstimator
operator|.
name|shallowSizeOfInstance
argument_list|(
name|FST
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ARC_SHALLOW_RAM_BYTES_USED
specifier|private
specifier|static
specifier|final
name|long
name|ARC_SHALLOW_RAM_BYTES_USED
init|=
name|RamUsageEstimator
operator|.
name|shallowSizeOfInstance
argument_list|(
name|Arc
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Specifies allowed range of each int input label for    *  this FST. */
DECL|enum|INPUT_TYPE
DECL|enum constant|BYTE1
DECL|enum constant|BYTE2
DECL|enum constant|BYTE4
specifier|public
specifier|static
enum|enum
name|INPUT_TYPE
block|{
name|BYTE1
block|,
name|BYTE2
block|,
name|BYTE4
block|}
empty_stmt|;
DECL|field|BIT_FINAL_ARC
specifier|static
specifier|final
name|int
name|BIT_FINAL_ARC
init|=
literal|1
operator|<<
literal|0
decl_stmt|;
DECL|field|BIT_LAST_ARC
specifier|static
specifier|final
name|int
name|BIT_LAST_ARC
init|=
literal|1
operator|<<
literal|1
decl_stmt|;
DECL|field|BIT_TARGET_NEXT
specifier|static
specifier|final
name|int
name|BIT_TARGET_NEXT
init|=
literal|1
operator|<<
literal|2
decl_stmt|;
comment|// TODO: we can free up a bit if we can nuke this:
DECL|field|BIT_STOP_NODE
specifier|static
specifier|final
name|int
name|BIT_STOP_NODE
init|=
literal|1
operator|<<
literal|3
decl_stmt|;
comment|/** This flag is set if the arc has an output. */
DECL|field|BIT_ARC_HAS_OUTPUT
specifier|public
specifier|static
specifier|final
name|int
name|BIT_ARC_HAS_OUTPUT
init|=
literal|1
operator|<<
literal|4
decl_stmt|;
DECL|field|BIT_ARC_HAS_FINAL_OUTPUT
specifier|static
specifier|final
name|int
name|BIT_ARC_HAS_FINAL_OUTPUT
init|=
literal|1
operator|<<
literal|5
decl_stmt|;
comment|// We use this as a marker (because this one flag is
comment|// illegal by itself ...):
DECL|field|ARCS_AS_FIXED_ARRAY
specifier|private
specifier|static
specifier|final
name|byte
name|ARCS_AS_FIXED_ARRAY
init|=
name|BIT_ARC_HAS_FINAL_OUTPUT
decl_stmt|;
comment|/**    * @see #shouldExpand(Builder, Builder.UnCompiledNode)    */
DECL|field|FIXED_ARRAY_SHALLOW_DISTANCE
specifier|static
specifier|final
name|int
name|FIXED_ARRAY_SHALLOW_DISTANCE
init|=
literal|3
decl_stmt|;
comment|// 0 => only root node.
comment|/**    * @see #shouldExpand(Builder, Builder.UnCompiledNode)    */
DECL|field|FIXED_ARRAY_NUM_ARCS_SHALLOW
specifier|static
specifier|final
name|int
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
init|=
literal|5
decl_stmt|;
comment|/**    * @see #shouldExpand(Builder, Builder.UnCompiledNode)    */
DECL|field|FIXED_ARRAY_NUM_ARCS_DEEP
specifier|static
specifier|final
name|int
name|FIXED_ARRAY_NUM_ARCS_DEEP
init|=
literal|10
decl_stmt|;
comment|// Increment version to change it
DECL|field|FILE_FORMAT_NAME
specifier|private
specifier|static
specifier|final
name|String
name|FILE_FORMAT_NAME
init|=
literal|"FST"
decl_stmt|;
DECL|field|VERSION_START
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_START
init|=
literal|0
decl_stmt|;
comment|/** Changed numBytesPerArc for array'd case from byte to int. */
DECL|field|VERSION_INT_NUM_BYTES_PER_ARC
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_INT_NUM_BYTES_PER_ARC
init|=
literal|1
decl_stmt|;
comment|/** Write BYTE2 labels as 2-byte short, not vInt. */
DECL|field|VERSION_SHORT_BYTE2_LABELS
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_SHORT_BYTE2_LABELS
init|=
literal|2
decl_stmt|;
comment|/** Added optional packed format. */
DECL|field|VERSION_PACKED
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_PACKED
init|=
literal|3
decl_stmt|;
comment|/** Changed from int to vInt for encoding arc targets.     *  Also changed maxBytesPerArc from int to vInt in the array case. */
DECL|field|VERSION_VINT_TARGET
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_VINT_TARGET
init|=
literal|4
decl_stmt|;
comment|/** Don't store arcWithOutputCount anymore */
DECL|field|VERSION_NO_NODE_ARC_COUNTS
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_NO_NODE_ARC_COUNTS
init|=
literal|5
decl_stmt|;
DECL|field|VERSION_PACKED_REMOVED
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_PACKED_REMOVED
init|=
literal|6
decl_stmt|;
DECL|field|VERSION_CURRENT
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_CURRENT
init|=
name|VERSION_PACKED_REMOVED
decl_stmt|;
comment|// Never serialized; just used to represent the virtual
comment|// final node w/ no arcs:
DECL|field|FINAL_END_NODE
specifier|private
specifier|static
specifier|final
name|long
name|FINAL_END_NODE
init|=
operator|-
literal|1
decl_stmt|;
comment|// Never serialized; just used to represent the virtual
comment|// non-final node w/ no arcs:
DECL|field|NON_FINAL_END_NODE
specifier|private
specifier|static
specifier|final
name|long
name|NON_FINAL_END_NODE
init|=
literal|0
decl_stmt|;
comment|/** If arc has this label then that arc is final/accepted */
DECL|field|END_LABEL
specifier|public
specifier|static
specifier|final
name|int
name|END_LABEL
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|inputType
specifier|public
specifier|final
name|INPUT_TYPE
name|inputType
decl_stmt|;
comment|// if non-null, this FST accepts the empty string and
comment|// produces this output
DECL|field|emptyOutput
name|T
name|emptyOutput
decl_stmt|;
comment|/** A {@link BytesStore}, used during building, or during reading when    *  the FST is very large (more than 1 GB).  If the FST is less than 1    *  GB then bytesArray is set instead. */
DECL|field|bytes
specifier|final
name|BytesStore
name|bytes
decl_stmt|;
comment|/** Used at read time when the FST fits into a single byte[]. */
DECL|field|bytesArray
specifier|final
name|byte
index|[]
name|bytesArray
decl_stmt|;
DECL|field|startNode
specifier|private
name|long
name|startNode
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|outputs
specifier|public
specifier|final
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
decl_stmt|;
DECL|field|cachedRootArcs
specifier|private
name|Arc
argument_list|<
name|T
argument_list|>
name|cachedRootArcs
index|[]
decl_stmt|;
comment|/** Represents a single arc. */
DECL|class|Arc
specifier|public
specifier|static
specifier|final
class|class
name|Arc
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|label
specifier|public
name|int
name|label
decl_stmt|;
DECL|field|output
specifier|public
name|T
name|output
decl_stmt|;
comment|// From node (ord or address); currently only used when
comment|// building an FST w/ willPackFST=true:
DECL|field|node
name|long
name|node
decl_stmt|;
comment|/** To node (ord or address) */
DECL|field|target
specifier|public
name|long
name|target
decl_stmt|;
DECL|field|flags
name|byte
name|flags
decl_stmt|;
DECL|field|nextFinalOutput
specifier|public
name|T
name|nextFinalOutput
decl_stmt|;
comment|// address (into the byte[]), or ord/address if label == END_LABEL
DECL|field|nextArc
name|long
name|nextArc
decl_stmt|;
comment|/** Where the first arc in the array starts; only valid if      *  bytesPerArc != 0 */
DECL|field|posArcsStart
specifier|public
name|long
name|posArcsStart
decl_stmt|;
comment|/** Non-zero if this arc is part of an array, which means all      *  arcs for the node are encoded with a fixed number of bytes so      *  that we can random access by index.  We do when there are enough      *  arcs leaving one node.  It wastes some bytes but gives faster      *  lookups. */
DECL|field|bytesPerArc
specifier|public
name|int
name|bytesPerArc
decl_stmt|;
comment|/** Where we are in the array; only valid if bytesPerArc != 0. */
DECL|field|arcIdx
specifier|public
name|int
name|arcIdx
decl_stmt|;
comment|/** How many arcs in the array; only valid if bytesPerArc != 0. */
DECL|field|numArcs
specifier|public
name|int
name|numArcs
decl_stmt|;
comment|/** Returns this */
DECL|method|copyFrom
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|copyFrom
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|other
parameter_list|)
block|{
name|node
operator|=
name|other
operator|.
name|node
expr_stmt|;
name|label
operator|=
name|other
operator|.
name|label
expr_stmt|;
name|target
operator|=
name|other
operator|.
name|target
expr_stmt|;
name|flags
operator|=
name|other
operator|.
name|flags
expr_stmt|;
name|output
operator|=
name|other
operator|.
name|output
expr_stmt|;
name|nextFinalOutput
operator|=
name|other
operator|.
name|nextFinalOutput
expr_stmt|;
name|nextArc
operator|=
name|other
operator|.
name|nextArc
expr_stmt|;
name|bytesPerArc
operator|=
name|other
operator|.
name|bytesPerArc
expr_stmt|;
if|if
condition|(
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
name|posArcsStart
operator|=
name|other
operator|.
name|posArcsStart
expr_stmt|;
name|arcIdx
operator|=
name|other
operator|.
name|arcIdx
expr_stmt|;
name|numArcs
operator|=
name|other
operator|.
name|numArcs
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|flag
name|boolean
name|flag
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
return|return
name|FST
operator|.
name|flag
argument_list|(
name|flags
argument_list|,
name|flag
argument_list|)
return|;
block|}
DECL|method|isLast
specifier|public
name|boolean
name|isLast
parameter_list|()
block|{
return|return
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
return|;
block|}
DECL|method|isFinal
specifier|public
name|boolean
name|isFinal
parameter_list|()
block|{
return|return
name|flag
argument_list|(
name|BIT_FINAL_ARC
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"node="
operator|+
name|node
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" target="
operator|+
name|target
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" label=0x"
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
argument_list|(
name|BIT_FINAL_ARC
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" final"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" last"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" targetNext"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_STOP_NODE
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" stop"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" output="
operator|+
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" nextFinalOutput="
operator|+
name|nextFinalOutput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" arcArray(idx="
operator|+
name|arcIdx
operator|+
literal|" of "
operator|+
name|numArcs
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
empty_stmt|;
DECL|method|flag
specifier|private
specifier|static
name|boolean
name|flag
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
return|return
operator|(
name|flags
operator|&
name|bit
operator|)
operator|!=
literal|0
return|;
block|}
DECL|field|version
specifier|private
specifier|final
name|int
name|version
decl_stmt|;
comment|// make a new empty FST, for building; Builder invokes
comment|// this ctor
DECL|method|FST
name|FST
parameter_list|(
name|INPUT_TYPE
name|inputType
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|,
name|int
name|bytesPageBits
parameter_list|)
block|{
name|this
operator|.
name|inputType
operator|=
name|inputType
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|version
operator|=
name|VERSION_CURRENT
expr_stmt|;
name|bytesArray
operator|=
literal|null
expr_stmt|;
name|bytes
operator|=
operator|new
name|BytesStore
argument_list|(
name|bytesPageBits
argument_list|)
expr_stmt|;
comment|// pad: ensure no node gets address 0 which is reserved to mean
comment|// the stop state w/ no arcs
name|bytes
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|emptyOutput
operator|=
literal|null
expr_stmt|;
block|}
DECL|field|DEFAULT_MAX_BLOCK_BITS
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_BLOCK_BITS
init|=
name|Constants
operator|.
name|JRE_IS_64BIT
condition|?
literal|30
else|:
literal|28
decl_stmt|;
comment|/** Load a previously saved FST. */
DECL|method|FST
specifier|public
name|FST
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|in
argument_list|,
name|outputs
argument_list|,
name|DEFAULT_MAX_BLOCK_BITS
argument_list|)
expr_stmt|;
block|}
comment|/** Load a previously saved FST; maxBlockBits allows you to    *  control the size of the byte[] pages used to hold the FST bytes. */
DECL|method|FST
specifier|public
name|FST
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|,
name|int
name|maxBlockBits
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
if|if
condition|(
name|maxBlockBits
argument_list|<
literal|1
operator|||
name|maxBlockBits
argument_list|>
literal|30
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxBlockBits should be 1 .. 30; got "
operator|+
name|maxBlockBits
argument_list|)
throw|;
block|}
comment|// NOTE: only reads most recent format; we don't have
comment|// back-compat promise for FSTs (they are experimental):
name|version
operator|=
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|in
argument_list|,
name|FILE_FORMAT_NAME
argument_list|,
name|VERSION_PACKED
argument_list|,
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|<
name|VERSION_PACKED_REMOVED
condition|)
block|{
if|if
condition|(
name|in
operator|.
name|readByte
argument_list|()
operator|==
literal|1
condition|)
block|{
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"Cannot read packed FSTs anymore"
argument_list|,
name|in
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|in
operator|.
name|readByte
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// accepts empty string
comment|// 1 KB blocks:
name|BytesStore
name|emptyBytes
init|=
operator|new
name|BytesStore
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|int
name|numBytes
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|emptyBytes
operator|.
name|copyBytes
argument_list|(
name|in
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
comment|// De-serialize empty-string output:
name|BytesReader
name|reader
init|=
name|emptyBytes
operator|.
name|getReverseReader
argument_list|()
decl_stmt|;
comment|// NoOutputs uses 0 bytes when writing its output,
comment|// so we have to check here else BytesStore gets
comment|// angry:
if|if
condition|(
name|numBytes
operator|>
literal|0
condition|)
block|{
name|reader
operator|.
name|setPosition
argument_list|(
name|numBytes
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|emptyOutput
operator|=
name|outputs
operator|.
name|readFinalOutput
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emptyOutput
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|byte
name|t
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
literal|0
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE4
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"invalid input type "
operator|+
name|t
argument_list|)
throw|;
block|}
name|startNode
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|<
name|VERSION_NO_NODE_ARC_COUNTS
condition|)
block|{
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
name|long
name|numBytes
init|=
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBytes
operator|>
literal|1
operator|<<
name|maxBlockBits
condition|)
block|{
comment|// FST is big: we need multiple pages
name|bytes
operator|=
operator|new
name|BytesStore
argument_list|(
name|in
argument_list|,
name|numBytes
argument_list|,
literal|1
operator|<<
name|maxBlockBits
argument_list|)
expr_stmt|;
name|bytesArray
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// FST fits into a single block: use ByteArrayBytesStoreReader for less overhead
name|bytes
operator|=
literal|null
expr_stmt|;
name|bytesArray
operator|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|numBytes
index|]
expr_stmt|;
name|in
operator|.
name|readBytes
argument_list|(
name|bytesArray
argument_list|,
literal|0
argument_list|,
name|bytesArray
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|cacheRootArcs
argument_list|()
expr_stmt|;
block|}
DECL|method|getInputType
specifier|public
name|INPUT_TYPE
name|getInputType
parameter_list|()
block|{
return|return
name|inputType
return|;
block|}
DECL|method|ramBytesUsed
specifier|private
name|long
name|ramBytesUsed
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
index|[]
name|arcs
parameter_list|)
block|{
name|long
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arcs
operator|!=
literal|null
condition|)
block|{
name|size
operator|+=
name|RamUsageEstimator
operator|.
name|shallowSizeOf
argument_list|(
name|arcs
argument_list|)
expr_stmt|;
for|for
control|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
range|:
name|arcs
control|)
block|{
if|if
condition|(
name|arc
operator|!=
literal|null
condition|)
block|{
name|size
operator|+=
name|ARC_SHALLOW_RAM_BYTES_USED
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
literal|null
operator|&&
name|arc
operator|.
name|output
operator|!=
name|outputs
operator|.
name|getNoOutput
argument_list|()
condition|)
block|{
name|size
operator|+=
name|outputs
operator|.
name|ramBytesUsed
argument_list|(
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
literal|null
operator|&&
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|outputs
operator|.
name|getNoOutput
argument_list|()
condition|)
block|{
name|size
operator|+=
name|outputs
operator|.
name|ramBytesUsed
argument_list|(
name|arc
operator|.
name|nextFinalOutput
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|size
return|;
block|}
DECL|field|cachedArcsBytesUsed
specifier|private
name|int
name|cachedArcsBytesUsed
decl_stmt|;
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
name|long
name|size
init|=
name|BASE_RAM_BYTES_USED
decl_stmt|;
if|if
condition|(
name|bytesArray
operator|!=
literal|null
condition|)
block|{
name|size
operator|+=
name|bytesArray
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|size
operator|+=
name|bytes
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
block|}
name|size
operator|+=
name|cachedArcsBytesUsed
expr_stmt|;
return|return
name|size
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"(input="
operator|+
name|inputType
operator|+
literal|",output="
operator|+
name|outputs
return|;
block|}
DECL|method|finish
name|void
name|finish
parameter_list|(
name|long
name|newStartNode
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|newStartNode
operator|<=
name|bytes
operator|.
name|getPosition
argument_list|()
assert|;
if|if
condition|(
name|startNode
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"already finished"
argument_list|)
throw|;
block|}
if|if
condition|(
name|newStartNode
operator|==
name|FINAL_END_NODE
operator|&&
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|newStartNode
operator|=
literal|0
expr_stmt|;
block|}
name|startNode
operator|=
name|newStartNode
expr_stmt|;
name|bytes
operator|.
name|finish
argument_list|()
expr_stmt|;
name|cacheRootArcs
argument_list|()
expr_stmt|;
block|}
comment|// Optionally caches first 128 labels
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
DECL|method|cacheRootArcs
specifier|private
name|void
name|cacheRootArcs
parameter_list|()
throws|throws
name|IOException
block|{
comment|// We should only be called once per FST:
assert|assert
name|cachedArcsBytesUsed
operator|==
literal|0
assert|;
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|Arc
argument_list|<>
argument_list|()
decl_stmt|;
name|getFirstArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetHasArcs
argument_list|(
name|arc
argument_list|)
condition|)
block|{
specifier|final
name|BytesReader
name|in
init|=
name|getBytesReader
argument_list|()
decl_stmt|;
name|Arc
argument_list|<
name|T
argument_list|>
index|[]
name|arcs
init|=
operator|(
name|Arc
argument_list|<
name|T
argument_list|>
index|[]
operator|)
operator|new
name|Arc
index|[
literal|0x80
index|]
decl_stmt|;
name|readFirstRealTargetArc
argument_list|(
name|arc
operator|.
name|target
argument_list|,
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
assert|assert
name|arc
operator|.
name|label
operator|!=
name|END_LABEL
assert|;
if|if
condition|(
name|arc
operator|.
name|label
operator|<
name|arcs
operator|.
name|length
condition|)
block|{
name|arcs
index|[
name|arc
operator|.
name|label
index|]
operator|=
operator|new
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|arc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
break|break;
block|}
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|int
name|cacheRAM
init|=
operator|(
name|int
operator|)
name|ramBytesUsed
argument_list|(
name|arcs
argument_list|)
decl_stmt|;
comment|// Don't cache if there are only a few arcs or if the cache would use> 20% RAM of the FST itself:
if|if
condition|(
name|count
operator|>=
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
operator|&&
name|cacheRAM
operator|<
name|ramBytesUsed
argument_list|()
operator|/
literal|5
condition|)
block|{
name|cachedRootArcs
operator|=
name|arcs
expr_stmt|;
name|cachedArcsBytesUsed
operator|=
name|cacheRAM
expr_stmt|;
block|}
block|}
block|}
DECL|method|getEmptyOutput
specifier|public
name|T
name|getEmptyOutput
parameter_list|()
block|{
return|return
name|emptyOutput
return|;
block|}
DECL|method|setEmptyOutput
name|void
name|setEmptyOutput
parameter_list|(
name|T
name|v
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|emptyOutput
operator|=
name|outputs
operator|.
name|merge
argument_list|(
name|emptyOutput
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emptyOutput
operator|=
name|v
expr_stmt|;
block|}
block|}
DECL|method|save
specifier|public
name|void
name|save
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startNode
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"call finish first"
argument_list|)
throw|;
block|}
name|CodecUtil
operator|.
name|writeHeader
argument_list|(
name|out
argument_list|,
name|FILE_FORMAT_NAME
argument_list|,
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
comment|// TODO: really we should encode this as an arc, arriving
comment|// to the root node, instead of special casing here:
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
comment|// Accepts empty string
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
comment|// Serialize empty-string output:
name|RAMOutputStream
name|ros
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
name|outputs
operator|.
name|writeFinalOutput
argument_list|(
name|emptyOutput
argument_list|,
name|ros
argument_list|)
expr_stmt|;
name|byte
index|[]
name|emptyOutputBytes
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|ros
operator|.
name|getFilePointer
argument_list|()
index|]
decl_stmt|;
name|ros
operator|.
name|writeTo
argument_list|(
name|emptyOutputBytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// reverse
specifier|final
name|int
name|stopAt
init|=
name|emptyOutputBytes
operator|.
name|length
operator|/
literal|2
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|stopAt
condition|)
block|{
specifier|final
name|byte
name|b
init|=
name|emptyOutputBytes
index|[
name|upto
index|]
decl_stmt|;
name|emptyOutputBytes
index|[
name|upto
index|]
operator|=
name|emptyOutputBytes
index|[
name|emptyOutputBytes
operator|.
name|length
operator|-
name|upto
operator|-
literal|1
index|]
expr_stmt|;
name|emptyOutputBytes
index|[
name|emptyOutputBytes
operator|.
name|length
operator|-
name|upto
operator|-
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
name|out
operator|.
name|writeVInt
argument_list|(
name|emptyOutputBytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|emptyOutputBytes
argument_list|,
literal|0
argument_list|,
name|emptyOutputBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|final
name|byte
name|t
decl_stmt|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
name|t
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
name|t
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
literal|2
expr_stmt|;
block|}
name|out
operator|.
name|writeByte
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|startNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|null
condition|)
block|{
name|long
name|numBytes
init|=
name|bytes
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|numBytes
argument_list|)
expr_stmt|;
name|bytes
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|bytesArray
operator|!=
literal|null
assert|;
name|out
operator|.
name|writeVLong
argument_list|(
name|bytesArray
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|bytesArray
argument_list|,
literal|0
argument_list|,
name|bytesArray
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Writes an automaton to a file.     */
DECL|method|save
specifier|public
name|void
name|save
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|OutputStream
name|os
init|=
operator|new
name|BufferedOutputStream
argument_list|(
name|Files
operator|.
name|newOutputStream
argument_list|(
name|path
argument_list|)
argument_list|)
init|)
block|{
name|save
argument_list|(
operator|new
name|OutputStreamDataOutput
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Reads an automaton from a file.     */
DECL|method|read
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|FST
argument_list|<
name|T
argument_list|>
name|read
parameter_list|(
name|Path
name|path
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|InputStream
name|is
init|=
name|Files
operator|.
name|newInputStream
argument_list|(
name|path
argument_list|)
init|)
block|{
return|return
operator|new
name|FST
argument_list|<>
argument_list|(
operator|new
name|InputStreamDataInput
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|is
argument_list|)
argument_list|)
argument_list|,
name|outputs
argument_list|)
return|;
block|}
block|}
DECL|method|writeLabel
specifier|private
name|void
name|writeLabel
parameter_list|(
name|DataOutput
name|out
parameter_list|,
name|int
name|v
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|v
operator|>=
literal|0
operator|:
literal|"v="
operator|+
name|v
assert|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
assert|assert
name|v
operator|<=
literal|255
operator|:
literal|"v="
operator|+
name|v
assert|;
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
assert|assert
name|v
operator|<=
literal|65535
operator|:
literal|"v="
operator|+
name|v
assert|;
name|out
operator|.
name|writeShort
argument_list|(
operator|(
name|short
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|writeVInt
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Reads one BYTE1/2/4 label from the provided {@link DataInput}. */
DECL|method|readLabel
specifier|public
name|int
name|readLabel
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|v
decl_stmt|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
comment|// Unsigned byte:
name|v
operator|=
name|in
operator|.
name|readByte
argument_list|()
operator|&
literal|0xFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
comment|// Unsigned short:
name|v
operator|=
name|in
operator|.
name|readShort
argument_list|()
operator|&
literal|0xFFFF
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
comment|/** returns true if the node at this address has any    *  outgoing arcs */
DECL|method|targetHasArcs
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|targetHasArcs
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
block|{
return|return
name|arc
operator|.
name|target
operator|>
literal|0
return|;
block|}
comment|// serializes new node by appending its bytes to the end
comment|// of the current byte[]
DECL|method|addNode
name|long
name|addNode
parameter_list|(
name|Builder
argument_list|<
name|T
argument_list|>
name|builder
parameter_list|,
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|nodeIn
parameter_list|)
throws|throws
name|IOException
block|{
name|T
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
comment|//System.out.println("FST.addNode pos=" + bytes.getPosition() + " numArcs=" + nodeIn.numArcs);
if|if
condition|(
name|nodeIn
operator|.
name|numArcs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nodeIn
operator|.
name|isFinal
condition|)
block|{
return|return
name|FINAL_END_NODE
return|;
block|}
else|else
block|{
return|return
name|NON_FINAL_END_NODE
return|;
block|}
block|}
specifier|final
name|long
name|startAddress
init|=
name|builder
operator|.
name|bytes
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|//System.out.println("  startAddr=" + startAddress);
specifier|final
name|boolean
name|doFixedArray
init|=
name|shouldExpand
argument_list|(
name|builder
argument_list|,
name|nodeIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|doFixedArray
condition|)
block|{
comment|//System.out.println("  fixedArray");
if|if
condition|(
name|builder
operator|.
name|reusedBytesPerArc
operator|.
name|length
operator|<
name|nodeIn
operator|.
name|numArcs
condition|)
block|{
name|builder
operator|.
name|reusedBytesPerArc
operator|=
operator|new
name|int
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|nodeIn
operator|.
name|numArcs
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
block|}
name|builder
operator|.
name|arcCount
operator|+=
name|nodeIn
operator|.
name|numArcs
expr_stmt|;
specifier|final
name|int
name|lastArc
init|=
name|nodeIn
operator|.
name|numArcs
operator|-
literal|1
decl_stmt|;
name|long
name|lastArcStart
init|=
name|builder
operator|.
name|bytes
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|int
name|maxBytesPerArc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|nodeIn
operator|.
name|numArcs
condition|;
name|arcIdx
operator|++
control|)
block|{
specifier|final
name|Builder
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|nodeIn
operator|.
name|arcs
index|[
name|arcIdx
index|]
decl_stmt|;
specifier|final
name|Builder
operator|.
name|CompiledNode
name|target
init|=
operator|(
name|Builder
operator|.
name|CompiledNode
operator|)
name|arc
operator|.
name|target
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|//System.out.println("  arc " + arcIdx + " label=" + arc.label + " -> target=" + target.node);
if|if
condition|(
name|arcIdx
operator|==
name|lastArc
condition|)
block|{
name|flags
operator|+=
name|BIT_LAST_ARC
expr_stmt|;
block|}
if|if
condition|(
name|builder
operator|.
name|lastFrozenNode
operator|==
name|target
operator|.
name|node
operator|&&
operator|!
name|doFixedArray
condition|)
block|{
comment|// TODO: for better perf (but more RAM used) we
comment|// could avoid this except when arc is "near" the
comment|// last arc:
name|flags
operator|+=
name|BIT_TARGET_NEXT
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
condition|)
block|{
name|flags
operator|+=
name|BIT_FINAL_ARC
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_FINAL_OUTPUT
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|arc
operator|.
name|nextFinalOutput
operator|==
name|NO_OUTPUT
assert|;
block|}
name|boolean
name|targetHasArcs
init|=
name|target
operator|.
name|node
operator|>
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|targetHasArcs
condition|)
block|{
name|flags
operator|+=
name|BIT_STOP_NODE
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_OUTPUT
expr_stmt|;
block|}
name|builder
operator|.
name|bytes
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|flags
argument_list|)
expr_stmt|;
name|writeLabel
argument_list|(
name|builder
operator|.
name|bytes
argument_list|,
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
comment|// System.out.println("  write arc: label=" + (char) arc.label + " flags=" + flags + " target=" + target.node + " pos=" + bytes.getPosition() + " output=" + outputs.outputToString(arc.output));
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outputs
operator|.
name|write
argument_list|(
name|arc
operator|.
name|output
argument_list|,
name|builder
operator|.
name|bytes
argument_list|)
expr_stmt|;
comment|//System.out.println("    write output");
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
comment|//System.out.println("    write final output");
name|outputs
operator|.
name|writeFinalOutput
argument_list|(
name|arc
operator|.
name|nextFinalOutput
argument_list|,
name|builder
operator|.
name|bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetHasArcs
operator|&&
operator|(
name|flags
operator|&
name|BIT_TARGET_NEXT
operator|)
operator|==
literal|0
condition|)
block|{
assert|assert
name|target
operator|.
name|node
operator|>
literal|0
assert|;
comment|//System.out.println("    write target");
name|builder
operator|.
name|bytes
operator|.
name|writeVLong
argument_list|(
name|target
operator|.
name|node
argument_list|)
expr_stmt|;
block|}
comment|// just write the arcs "like normal" on first pass,
comment|// but record how many bytes each one took, and max
comment|// byte size:
if|if
condition|(
name|doFixedArray
condition|)
block|{
name|builder
operator|.
name|reusedBytesPerArc
index|[
name|arcIdx
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|builder
operator|.
name|bytes
operator|.
name|getPosition
argument_list|()
operator|-
name|lastArcStart
argument_list|)
expr_stmt|;
name|lastArcStart
operator|=
name|builder
operator|.
name|bytes
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|maxBytesPerArc
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxBytesPerArc
argument_list|,
name|builder
operator|.
name|reusedBytesPerArc
index|[
name|arcIdx
index|]
argument_list|)
expr_stmt|;
comment|//System.out.println("    bytes=" + builder.reusedBytesPerArc[arcIdx]);
block|}
block|}
comment|// TODO: try to avoid wasteful cases: disable doFixedArray in that case
comment|/*       *       * LUCENE-4682: what is a fair heuristic here?      * It could involve some of these:      * 1. how "busy" the node is: nodeIn.inputCount relative to frontier[0].inputCount?      * 2. how much binSearch saves over scan: nodeIn.numArcs      * 3. waste: numBytes vs numBytesExpanded      *       * the one below just looks at #3     if (doFixedArray) {       // rough heuristic: make this 1.25 "waste factor" a parameter to the phd ctor????       int numBytes = lastArcStart - startAddress;       int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;       if (numBytesExpanded> numBytes*1.25) {         doFixedArray = false;       }     }     */
if|if
condition|(
name|doFixedArray
condition|)
block|{
specifier|final
name|int
name|MAX_HEADER_SIZE
init|=
literal|11
decl_stmt|;
comment|// header(byte) + numArcs(vint) + numBytes(vint)
assert|assert
name|maxBytesPerArc
operator|>
literal|0
assert|;
comment|// 2nd pass just "expands" all arcs to take up a fixed
comment|// byte size
comment|//System.out.println("write int @pos=" + (fixedArrayStart-4) + " numArcs=" + nodeIn.numArcs);
comment|// create the header
comment|// TODO: clean this up: or just rewind+reuse and deal with it
name|byte
name|header
index|[]
init|=
operator|new
name|byte
index|[
name|MAX_HEADER_SIZE
index|]
decl_stmt|;
name|ByteArrayDataOutput
name|bad
init|=
operator|new
name|ByteArrayDataOutput
argument_list|(
name|header
argument_list|)
decl_stmt|;
comment|// write a "false" first arc:
name|bad
operator|.
name|writeByte
argument_list|(
name|ARCS_AS_FIXED_ARRAY
argument_list|)
expr_stmt|;
name|bad
operator|.
name|writeVInt
argument_list|(
name|nodeIn
operator|.
name|numArcs
argument_list|)
expr_stmt|;
name|bad
operator|.
name|writeVInt
argument_list|(
name|maxBytesPerArc
argument_list|)
expr_stmt|;
name|int
name|headerLen
init|=
name|bad
operator|.
name|getPosition
argument_list|()
decl_stmt|;
specifier|final
name|long
name|fixedArrayStart
init|=
name|startAddress
operator|+
name|headerLen
decl_stmt|;
comment|// expand the arcs in place, backwards
name|long
name|srcPos
init|=
name|builder
operator|.
name|bytes
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|long
name|destPos
init|=
name|fixedArrayStart
operator|+
name|nodeIn
operator|.
name|numArcs
operator|*
name|maxBytesPerArc
decl_stmt|;
assert|assert
name|destPos
operator|>=
name|srcPos
assert|;
if|if
condition|(
name|destPos
operator|>
name|srcPos
condition|)
block|{
name|builder
operator|.
name|bytes
operator|.
name|skipBytes
argument_list|(
call|(
name|int
call|)
argument_list|(
name|destPos
operator|-
name|srcPos
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|arcIdx
init|=
name|nodeIn
operator|.
name|numArcs
operator|-
literal|1
init|;
name|arcIdx
operator|>=
literal|0
condition|;
name|arcIdx
operator|--
control|)
block|{
name|destPos
operator|-=
name|maxBytesPerArc
expr_stmt|;
name|srcPos
operator|-=
name|builder
operator|.
name|reusedBytesPerArc
index|[
name|arcIdx
index|]
expr_stmt|;
comment|//System.out.println("  repack arcIdx=" + arcIdx + " srcPos=" + srcPos + " destPos=" + destPos);
if|if
condition|(
name|srcPos
operator|!=
name|destPos
condition|)
block|{
comment|//System.out.println("  copy len=" + builder.reusedBytesPerArc[arcIdx]);
assert|assert
name|destPos
operator|>
name|srcPos
operator|:
literal|"destPos="
operator|+
name|destPos
operator|+
literal|" srcPos="
operator|+
name|srcPos
operator|+
literal|" arcIdx="
operator|+
name|arcIdx
operator|+
literal|" maxBytesPerArc="
operator|+
name|maxBytesPerArc
operator|+
literal|" reusedBytesPerArc[arcIdx]="
operator|+
name|builder
operator|.
name|reusedBytesPerArc
index|[
name|arcIdx
index|]
operator|+
literal|" nodeIn.numArcs="
operator|+
name|nodeIn
operator|.
name|numArcs
assert|;
name|builder
operator|.
name|bytes
operator|.
name|copyBytes
argument_list|(
name|srcPos
argument_list|,
name|destPos
argument_list|,
name|builder
operator|.
name|reusedBytesPerArc
index|[
name|arcIdx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// now write the header
name|builder
operator|.
name|bytes
operator|.
name|writeBytes
argument_list|(
name|startAddress
argument_list|,
name|header
argument_list|,
literal|0
argument_list|,
name|headerLen
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|thisNodeAddress
init|=
name|builder
operator|.
name|bytes
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
decl_stmt|;
name|builder
operator|.
name|bytes
operator|.
name|reverse
argument_list|(
name|startAddress
argument_list|,
name|thisNodeAddress
argument_list|)
expr_stmt|;
name|builder
operator|.
name|nodeCount
operator|++
expr_stmt|;
return|return
name|thisNodeAddress
return|;
block|}
comment|/** Fills virtual 'start' arc, ie, an empty incoming arc to    *  the FST's start node */
DECL|method|getFirstArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|getFirstArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
block|{
name|T
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_FINAL_ARC
operator||
name|BIT_LAST_ARC
expr_stmt|;
name|arc
operator|.
name|nextFinalOutput
operator|=
name|emptyOutput
expr_stmt|;
if|if
condition|(
name|emptyOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|arc
operator|.
name|flags
operator||=
name|BIT_ARC_HAS_FINAL_OUTPUT
expr_stmt|;
block|}
block|}
else|else
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
expr_stmt|;
name|arc
operator|.
name|nextFinalOutput
operator|=
name|NO_OUTPUT
expr_stmt|;
block|}
name|arc
operator|.
name|output
operator|=
name|NO_OUTPUT
expr_stmt|;
comment|// If there are no nodes, ie, the FST only accepts the
comment|// empty string, then startNode is 0
name|arc
operator|.
name|target
operator|=
name|startNode
expr_stmt|;
return|return
name|arc
return|;
block|}
comment|/** Follows the<code>follow</code> arc and reads the last    *  arc of its target; this changes the provided    *<code>arc</code> (2nd arg) in-place and returns it.    *     * @return Returns the second argument    * (<code>arc</code>). */
DECL|method|readLastTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readLastTargetArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("readLast");
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|follow
argument_list|)
condition|)
block|{
comment|//System.out.println("  end node");
assert|assert
name|follow
operator|.
name|isFinal
argument_list|()
assert|;
name|arc
operator|.
name|label
operator|=
name|END_LABEL
expr_stmt|;
name|arc
operator|.
name|target
operator|=
name|FINAL_END_NODE
expr_stmt|;
name|arc
operator|.
name|output
operator|=
name|follow
operator|.
name|nextFinalOutput
expr_stmt|;
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
expr_stmt|;
return|return
name|arc
return|;
block|}
else|else
block|{
name|in
operator|.
name|setPosition
argument_list|(
name|follow
operator|.
name|target
argument_list|)
expr_stmt|;
name|arc
operator|.
name|node
operator|=
name|follow
operator|.
name|target
expr_stmt|;
specifier|final
name|byte
name|b
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|ARCS_AS_FIXED_ARRAY
condition|)
block|{
comment|// array: jump straight to end
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|VERSION_VINT_TARGET
condition|)
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
comment|//System.out.println("  array numArcs=" + arc.numArcs + " bpa=" + arc.bytesPerArc);
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|arc
operator|.
name|arcIdx
operator|=
name|arc
operator|.
name|numArcs
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|flags
operator|=
name|b
expr_stmt|;
comment|// non-array: linear scan
name|arc
operator|.
name|bytesPerArc
operator|=
literal|0
expr_stmt|;
comment|//System.out.println("  scan");
while|while
condition|(
operator|!
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
comment|// skip this arc:
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|skipOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|skipFinalOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_STOP_NODE
argument_list|)
condition|)
block|{           }
elseif|else
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{           }
else|else
block|{
name|readUnpackedNodeTarget
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|arc
operator|.
name|flags
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
comment|// Undo the byte flags we read:
name|in
operator|.
name|skipBytes
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
assert|assert
name|arc
operator|.
name|isLast
argument_list|()
assert|;
return|return
name|arc
return|;
block|}
block|}
DECL|method|readUnpackedNodeTarget
specifier|private
name|long
name|readUnpackedNodeTarget
parameter_list|(
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|target
decl_stmt|;
if|if
condition|(
name|version
operator|<
name|VERSION_VINT_TARGET
condition|)
block|{
name|target
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
comment|/**    * Follow the<code>follow</code> arc and read the first arc of its target;    * this changes the provided<code>arc</code> (2nd arg) in-place and returns    * it.    *     * @return Returns the second argument (<code>arc</code>).    */
DECL|method|readFirstTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readFirstTargetArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|//int pos = address;
comment|//System.out.println("    readFirstTarget follow.target=" + follow.target + " isFinal=" + follow.isFinal());
if|if
condition|(
name|follow
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|// Insert "fake" final first arc:
name|arc
operator|.
name|label
operator|=
name|END_LABEL
expr_stmt|;
name|arc
operator|.
name|output
operator|=
name|follow
operator|.
name|nextFinalOutput
expr_stmt|;
name|arc
operator|.
name|flags
operator|=
name|BIT_FINAL_ARC
expr_stmt|;
if|if
condition|(
name|follow
operator|.
name|target
operator|<=
literal|0
condition|)
block|{
name|arc
operator|.
name|flags
operator||=
name|BIT_LAST_ARC
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|node
operator|=
name|follow
operator|.
name|target
expr_stmt|;
comment|// NOTE: nextArc is a node (not an address!) in this case:
name|arc
operator|.
name|nextArc
operator|=
name|follow
operator|.
name|target
expr_stmt|;
block|}
name|arc
operator|.
name|target
operator|=
name|FINAL_END_NODE
expr_stmt|;
comment|//System.out.println("    insert isFinal; nextArc=" + follow.target + " isLast=" + arc.isLast() + " output=" + outputs.outputToString(arc.output));
return|return
name|arc
return|;
block|}
else|else
block|{
return|return
name|readFirstRealTargetArc
argument_list|(
name|follow
operator|.
name|target
argument_list|,
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
block|}
DECL|method|readFirstRealTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readFirstRealTargetArc
parameter_list|(
name|long
name|node
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
specifier|final
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|address
init|=
name|node
decl_stmt|;
name|in
operator|.
name|setPosition
argument_list|(
name|address
argument_list|)
expr_stmt|;
comment|//System.out.println("  readFirstRealTargtArc address="
comment|//+ address);
comment|//System.out.println("   flags=" + arc.flags);
name|arc
operator|.
name|node
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|readByte
argument_list|()
operator|==
name|ARCS_AS_FIXED_ARRAY
condition|)
block|{
comment|//System.out.println("  fixedArray");
comment|// this is first arc in a fixed-array
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|VERSION_VINT_TARGET
condition|)
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
name|arc
operator|.
name|arcIdx
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
comment|//System.out.println("  bytesPer=" + arc.bytesPerArc + " numArcs=" + arc.numArcs + " arcsStart=" + pos);
block|}
else|else
block|{
comment|//arc.flags = b;
name|arc
operator|.
name|nextArc
operator|=
name|address
expr_stmt|;
name|arc
operator|.
name|bytesPerArc
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
comment|/**    * Checks if<code>arc</code>'s target state is in expanded (or vector) format.     *     * @return Returns<code>true</code> if<code>arc</code> points to a state in an    * expanded array format.    */
DECL|method|isExpandedTarget
name|boolean
name|isExpandedTarget
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|follow
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|in
operator|.
name|setPosition
argument_list|(
name|follow
operator|.
name|target
argument_list|)
expr_stmt|;
return|return
name|in
operator|.
name|readByte
argument_list|()
operator|==
name|ARCS_AS_FIXED_ARRAY
return|;
block|}
block|}
comment|/** In-place read; returns the arc. */
DECL|method|readNextArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readNextArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|END_LABEL
condition|)
block|{
comment|// This was a fake inserted "final" arc
if|if
condition|(
name|arc
operator|.
name|nextArc
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot readNextArc when arc.isLast()=true"
argument_list|)
throw|;
block|}
return|return
name|readFirstRealTargetArc
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|,
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
block|}
comment|/** Peeks at next arc's label; does not alter arc.  Do    *  not call this if arc.isLast()! */
DECL|method|readNextArcLabel
specifier|public
name|int
name|readNextArcLabel
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|arc
operator|.
name|isLast
argument_list|()
assert|;
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|END_LABEL
condition|)
block|{
comment|//System.out.println("    nextArc fake " +
comment|//arc.nextArc);
name|long
name|pos
init|=
name|arc
operator|.
name|nextArc
decl_stmt|;
name|in
operator|.
name|setPosition
argument_list|(
name|pos
argument_list|)
expr_stmt|;
specifier|final
name|byte
name|b
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|ARCS_AS_FIXED_ARRAY
condition|)
block|{
comment|//System.out.println("    nextArc fixed array");
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|// Skip bytesPerArc:
if|if
condition|(
name|version
operator|>=
name|VERSION_VINT_TARGET
condition|)
block|{
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|in
operator|.
name|setPosition
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
comment|//System.out.println("    nextArc real array");
comment|// arcs are at fixed entries
name|in
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|posArcsStart
argument_list|)
expr_stmt|;
name|in
operator|.
name|skipBytes
argument_list|(
operator|(
literal|1
operator|+
name|arc
operator|.
name|arcIdx
operator|)
operator|*
name|arc
operator|.
name|bytesPerArc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// arcs are packed
comment|//System.out.println("    nextArc real packed");
name|in
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|)
expr_stmt|;
block|}
block|}
comment|// skip flags
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
return|return
name|readLabel
argument_list|(
name|in
argument_list|)
return|;
block|}
comment|/** Never returns null, but you should never call this if    *  arc.isLast() is true. */
DECL|method|readNextRealArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readNextRealArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
specifier|final
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: can't assert this because we call from readFirstArc
comment|// assert !flag(arc.flags, BIT_LAST_ARC);
comment|// this is a continuing arc in a fixed array
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
comment|// arcs are at fixed entries
name|arc
operator|.
name|arcIdx
operator|++
expr_stmt|;
assert|assert
name|arc
operator|.
name|arcIdx
operator|<
name|arc
operator|.
name|numArcs
assert|;
name|in
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|posArcsStart
argument_list|)
expr_stmt|;
name|in
operator|.
name|skipBytes
argument_list|(
name|arc
operator|.
name|arcIdx
operator|*
name|arc
operator|.
name|bytesPerArc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// arcs are packed
name|in
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|)
expr_stmt|;
block|}
name|arc
operator|.
name|flags
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|arc
operator|.
name|label
operator|=
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|output
operator|=
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|output
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|nextFinalOutput
operator|=
name|outputs
operator|.
name|readFinalOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|nextFinalOutput
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_STOP_NODE
argument_list|)
condition|)
block|{
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_FINAL_ARC
argument_list|)
condition|)
block|{
name|arc
operator|.
name|target
operator|=
name|FINAL_END_NODE
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|target
operator|=
name|NON_FINAL_END_NODE
expr_stmt|;
block|}
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
comment|// TODO: would be nice to make this lazy -- maybe
comment|// caller doesn't need the target and is scanning arcs...
if|if
condition|(
operator|!
name|arc
operator|.
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|==
literal|0
condition|)
block|{
comment|// must scan
name|seekToNextNode
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|posArcsStart
argument_list|)
expr_stmt|;
name|in
operator|.
name|skipBytes
argument_list|(
name|arc
operator|.
name|bytesPerArc
operator|*
name|arc
operator|.
name|numArcs
argument_list|)
expr_stmt|;
block|}
block|}
name|arc
operator|.
name|target
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|target
operator|=
name|readUnpackedNodeTarget
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
return|return
name|arc
return|;
block|}
comment|// LUCENE-5152: called only from asserts, to validate that the
comment|// non-cached arc lookup would produce the same result, to
comment|// catch callers that illegally modify shared structures with
comment|// the result (we shallow-clone the Arc itself, but e.g. a BytesRef
comment|// output is still shared):
DECL|method|assertRootCachedArc
specifier|private
name|boolean
name|assertRootCachedArc
parameter_list|(
name|int
name|label
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|cachedArc
parameter_list|)
throws|throws
name|IOException
block|{
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|Arc
argument_list|<>
argument_list|()
decl_stmt|;
name|getFirstArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|BytesReader
name|in
init|=
name|getBytesReader
argument_list|()
decl_stmt|;
name|Arc
argument_list|<
name|T
argument_list|>
name|result
init|=
name|findTargetArc
argument_list|(
name|label
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|in
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
assert|assert
name|cachedArc
operator|==
literal|null
assert|;
block|}
else|else
block|{
assert|assert
name|cachedArc
operator|!=
literal|null
assert|;
assert|assert
name|cachedArc
operator|.
name|arcIdx
operator|==
name|result
operator|.
name|arcIdx
assert|;
assert|assert
name|cachedArc
operator|.
name|bytesPerArc
operator|==
name|result
operator|.
name|bytesPerArc
assert|;
assert|assert
name|cachedArc
operator|.
name|flags
operator|==
name|result
operator|.
name|flags
assert|;
assert|assert
name|cachedArc
operator|.
name|label
operator|==
name|result
operator|.
name|label
assert|;
assert|assert
name|cachedArc
operator|.
name|nextArc
operator|==
name|result
operator|.
name|nextArc
assert|;
assert|assert
name|cachedArc
operator|.
name|nextFinalOutput
operator|.
name|equals
argument_list|(
name|result
operator|.
name|nextFinalOutput
argument_list|)
assert|;
assert|assert
name|cachedArc
operator|.
name|node
operator|==
name|result
operator|.
name|node
assert|;
assert|assert
name|cachedArc
operator|.
name|numArcs
operator|==
name|result
operator|.
name|numArcs
assert|;
assert|assert
name|cachedArc
operator|.
name|output
operator|.
name|equals
argument_list|(
name|result
operator|.
name|output
argument_list|)
assert|;
assert|assert
name|cachedArc
operator|.
name|posArcsStart
operator|==
name|result
operator|.
name|posArcsStart
assert|;
assert|assert
name|cachedArc
operator|.
name|target
operator|==
name|result
operator|.
name|target
assert|;
block|}
return|return
literal|true
return|;
block|}
comment|// TODO: could we somehow [partially] tableize arc lookups
comment|// like automaton?
comment|/** Finds an arc leaving the incoming arc, replacing the arc in place.    *  This returns null if the arc was not found, else the incoming arc. */
DECL|method|findTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|findTargetArc
parameter_list|(
name|int
name|labelToMatch
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|findTargetArc
argument_list|(
name|labelToMatch
argument_list|,
name|follow
argument_list|,
name|arc
argument_list|,
name|in
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Finds an arc leaving the incoming arc, replacing the arc in place.    *  This returns null if the arc was not found, else the incoming arc. */
DECL|method|findTargetArc
specifier|private
name|Arc
argument_list|<
name|T
argument_list|>
name|findTargetArc
parameter_list|(
name|int
name|labelToMatch
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|,
name|boolean
name|useRootArcCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|labelToMatch
operator|==
name|END_LABEL
condition|)
block|{
if|if
condition|(
name|follow
operator|.
name|isFinal
argument_list|()
condition|)
block|{
if|if
condition|(
name|follow
operator|.
name|target
operator|<=
literal|0
condition|)
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|// NOTE: nextArc is a node (not an address!) in this case:
name|arc
operator|.
name|nextArc
operator|=
name|follow
operator|.
name|target
expr_stmt|;
name|arc
operator|.
name|node
operator|=
name|follow
operator|.
name|target
expr_stmt|;
block|}
name|arc
operator|.
name|output
operator|=
name|follow
operator|.
name|nextFinalOutput
expr_stmt|;
name|arc
operator|.
name|label
operator|=
name|END_LABEL
expr_stmt|;
return|return
name|arc
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// Short-circuit if this arc is in the root arc cache:
if|if
condition|(
name|useRootArcCache
operator|&&
name|cachedRootArcs
operator|!=
literal|null
operator|&&
name|follow
operator|.
name|target
operator|==
name|startNode
operator|&&
name|labelToMatch
operator|<
name|cachedRootArcs
operator|.
name|length
condition|)
block|{
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|result
init|=
name|cachedRootArcs
index|[
name|labelToMatch
index|]
decl_stmt|;
comment|// LUCENE-5152: detect tricky cases where caller
comment|// modified previously returned cached root-arcs:
assert|assert
name|assertRootCachedArc
argument_list|(
name|labelToMatch
argument_list|,
name|result
argument_list|)
assert|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|arc
operator|.
name|copyFrom
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|arc
return|;
block|}
block|}
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|follow
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|in
operator|.
name|setPosition
argument_list|(
name|follow
operator|.
name|target
argument_list|)
expr_stmt|;
name|arc
operator|.
name|node
operator|=
name|follow
operator|.
name|target
expr_stmt|;
comment|// System.out.println("fta label=" + (char) labelToMatch);
if|if
condition|(
name|in
operator|.
name|readByte
argument_list|()
operator|==
name|ARCS_AS_FIXED_ARRAY
condition|)
block|{
comment|// Arcs are full array; do binary search:
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|VERSION_VINT_TARGET
condition|)
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|arc
operator|.
name|numArcs
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
comment|//System.out.println("    cycle");
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|in
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|posArcsStart
argument_list|)
expr_stmt|;
name|in
operator|.
name|skipBytes
argument_list|(
name|arc
operator|.
name|bytesPerArc
operator|*
name|mid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|int
name|midLabel
init|=
name|readLabel
argument_list|(
name|in
argument_list|)
decl_stmt|;
specifier|final
name|int
name|cmp
init|=
name|midLabel
operator|-
name|labelToMatch
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|arcIdx
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
comment|//System.out.println("    found!");
return|return
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// Linear scan
name|readFirstRealTargetArc
argument_list|(
name|follow
operator|.
name|target
argument_list|,
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|//System.out.println("  non-bs cycle");
comment|// TODO: we should fix this code to not have to create
comment|// object for the output of every arc we scan... only
comment|// for the matching arc, if found
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|labelToMatch
condition|)
block|{
comment|//System.out.println("    found!");
return|return
name|arc
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|label
operator|>
name|labelToMatch
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|seekToNextNode
specifier|private
name|void
name|seekToNextNode
parameter_list|(
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|flags
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|skipOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|skipFinalOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_STOP_NODE
argument_list|)
operator|&&
operator|!
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
name|readUnpackedNodeTarget
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
comment|/**    * Nodes will be expanded if their depth (distance from the root node) is    *&lt;= this value and their number of arcs is&gt;=    * {@link #FIXED_ARRAY_NUM_ARCS_SHALLOW}.    *     *<p>    * Fixed array consumes more RAM but enables binary search on the arcs    * (instead of a linear scan) on lookup by arc label.    *     * @return<code>true</code> if<code>node</code> should be stored in an    *         expanded (array) form.    *     * @see #FIXED_ARRAY_NUM_ARCS_DEEP    * @see Builder.UnCompiledNode#depth    */
DECL|method|shouldExpand
specifier|private
name|boolean
name|shouldExpand
parameter_list|(
name|Builder
argument_list|<
name|T
argument_list|>
name|builder
parameter_list|,
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|)
block|{
return|return
name|builder
operator|.
name|allowArrayArcs
operator|&&
operator|(
operator|(
name|node
operator|.
name|depth
operator|<=
name|FIXED_ARRAY_SHALLOW_DISTANCE
operator|&&
name|node
operator|.
name|numArcs
operator|>=
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
operator|)
operator|||
name|node
operator|.
name|numArcs
operator|>=
name|FIXED_ARRAY_NUM_ARCS_DEEP
operator|)
return|;
block|}
comment|/** Returns a {@link BytesReader} for this FST, positioned at    *  position 0. */
DECL|method|getBytesReader
specifier|public
name|BytesReader
name|getBytesReader
parameter_list|()
block|{
if|if
condition|(
name|bytesArray
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|ReverseBytesReader
argument_list|(
name|bytesArray
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|bytes
operator|.
name|getReverseReader
argument_list|()
return|;
block|}
block|}
comment|/** Reads bytes stored in an FST. */
DECL|class|BytesReader
specifier|public
specifier|static
specifier|abstract
class|class
name|BytesReader
extends|extends
name|DataInput
block|{
comment|/** Get current read position. */
DECL|method|getPosition
specifier|public
specifier|abstract
name|long
name|getPosition
parameter_list|()
function_decl|;
comment|/** Set current read position. */
DECL|method|setPosition
specifier|public
specifier|abstract
name|void
name|setPosition
parameter_list|(
name|long
name|pos
parameter_list|)
function_decl|;
comment|/** Returns true if this reader uses reversed bytes      *  under-the-hood. */
DECL|method|reversed
specifier|public
specifier|abstract
name|boolean
name|reversed
parameter_list|()
function_decl|;
block|}
comment|/*   public void countSingleChains() throws IOException {     // TODO: must assert this FST was built with     // "willRewrite"      final List<ArcAndState<T>> queue = new ArrayList<>();      // TODO: use bitset to not revisit nodes already     // visited      FixedBitSet seen = new FixedBitSet(1+nodeCount);     int saved = 0;      queue.add(new ArcAndState<T>(getFirstArc(new Arc<T>()), new IntsRef()));     Arc<T> scratchArc = new Arc<>();     while(queue.size()> 0) {       //System.out.println("cycle size=" + queue.size());       //for(ArcAndState<T> ent : queue) {       //  System.out.println("  " + Util.toBytesRef(ent.chain, new BytesRef()));       //  }       final ArcAndState<T> arcAndState = queue.get(queue.size()-1);       seen.set(arcAndState.arc.node);       final BytesRef br = Util.toBytesRef(arcAndState.chain, new BytesRef());       if (br.length> 0&& br.bytes[br.length-1] == -1) {         br.length--;       }       //System.out.println("  top node=" + arcAndState.arc.target + " chain=" + br.utf8ToString());       if (targetHasArcs(arcAndState.arc)&& !seen.get(arcAndState.arc.target)) {         // push         readFirstTargetArc(arcAndState.arc, scratchArc);         //System.out.println("  push label=" + (char) scratchArc.label);         //System.out.println("    tonode=" + scratchArc.target + " last?=" + scratchArc.isLast());                  final IntsRef chain = IntsRef.deepCopyOf(arcAndState.chain);         chain.grow(1+chain.length);         // TODO         //assert scratchArc.label != END_LABEL;         chain.ints[chain.length] = scratchArc.label;         chain.length++;          if (scratchArc.isLast()) {           if (scratchArc.target != -1&& inCounts[scratchArc.target] == 1) {             //System.out.println("    append");           } else {             if (arcAndState.chain.length> 1) {               saved += chain.length-2;               try {                 System.out.println("chain: " + Util.toBytesRef(chain, new BytesRef()).utf8ToString());               } catch (AssertionError ae) {                 System.out.println("chain: " + Util.toBytesRef(chain, new BytesRef()));               }             }             chain.length = 0;           }         } else {           //System.out.println("    reset");           if (arcAndState.chain.length> 1) {             saved += arcAndState.chain.length-2;             try {               System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()).utf8ToString());             } catch (AssertionError ae) {               System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()));             }           }           if (scratchArc.target != -1&& inCounts[scratchArc.target] != 1) {             chain.length = 0;           } else {             chain.ints[0] = scratchArc.label;             chain.length = 1;           }         }         // TODO: instead of new Arc() we can re-use from         // a by-depth array         queue.add(new ArcAndState<T>(new Arc<T>().copyFrom(scratchArc), chain));       } else if (!arcAndState.arc.isLast()) {         // next         readNextArc(arcAndState.arc);         //System.out.println("  next label=" + (char) arcAndState.arc.label + " len=" + arcAndState.chain.length);         if (arcAndState.chain.length != 0) {           arcAndState.chain.ints[arcAndState.chain.length-1] = arcAndState.arc.label;         }       } else {         if (arcAndState.chain.length> 1) {           saved += arcAndState.chain.length-2;           System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()).utf8ToString());         }         // pop         //System.out.println("  pop");         queue.remove(queue.size()-1);         while(queue.size()> 0&& queue.get(queue.size()-1).arc.isLast()) {           queue.remove(queue.size()-1);         }         if (queue.size()> 0) {           final ArcAndState<T> arcAndState2 = queue.get(queue.size()-1);           readNextArc(arcAndState2.arc);           //System.out.println("  read next=" + (char) arcAndState2.arc.label + " queue=" + queue.size());           assert arcAndState2.arc.label != END_LABEL;           if (arcAndState2.chain.length != 0) {             arcAndState2.chain.ints[arcAndState2.chain.length-1] = arcAndState2.arc.label;           }         }       }     }      System.out.println("TOT saved " + saved);   }  */
block|}
end_class

end_unit

