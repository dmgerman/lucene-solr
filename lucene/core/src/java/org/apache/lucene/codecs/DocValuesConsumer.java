begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.codecs
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|BinaryDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocIDMerger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|EmptyDocValuesProducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FilteredTermsEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiDocValues
operator|.
name|OrdinalMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|NumericDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentWriteState
import|;
end_import

begin_comment
comment|// javadocs
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedNumericDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedSetDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LongBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LongValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|PackedInts
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
import|;
end_import

begin_comment
comment|/**   * Abstract API that consumes numeric, binary and  * sorted docvalues.  Concrete implementations of this  * actually do "something" with the docvalues (write it into  * the index in a specific format).  *<p>  * The lifecycle is:  *<ol>  *<li>DocValuesConsumer is created by   *       {@link NormsFormat#normsConsumer(SegmentWriteState)}.  *<li>{@link #addNumericField}, {@link #addBinaryField},  *       {@link #addSortedField}, {@link #addSortedSetField},  *       or {@link #addSortedNumericField} are called for each Numeric,  *       Binary, Sorted, SortedSet, or SortedNumeric docvalues field.   *       The API is a "pull" rather than "push", and the implementation   *       is free to iterate over the values multiple times   *       ({@link Iterable#iterator()}).  *<li>After all fields are added, the consumer is {@link #close}d.  *</ol>  *  * @lucene.experimental  */
end_comment

begin_class
DECL|class|DocValuesConsumer
specifier|public
specifier|abstract
class|class
name|DocValuesConsumer
implements|implements
name|Closeable
block|{
comment|/** Sole constructor. (For invocation by subclass     *  constructors, typically implicit.) */
DECL|method|DocValuesConsumer
specifier|protected
name|DocValuesConsumer
parameter_list|()
block|{}
comment|/**    * Writes numeric docvalues for a field.    * @param field field information    * @param valuesProducer Numeric values to write.    * @throws IOException if an I/O error occurred.    */
DECL|method|addNumericField
specifier|public
specifier|abstract
name|void
name|addNumericField
parameter_list|(
name|FieldInfo
name|field
parameter_list|,
name|DocValuesProducer
name|valuesProducer
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Writes binary docvalues for a field.    * @param field field information    * @param valuesProducer Binary values to write.    * @throws IOException if an I/O error occurred.    */
DECL|method|addBinaryField
specifier|public
specifier|abstract
name|void
name|addBinaryField
parameter_list|(
name|FieldInfo
name|field
parameter_list|,
name|DocValuesProducer
name|valuesProducer
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Writes pre-sorted binary docvalues for a field.    * @param field field information    * @param valuesProducer produces the values and ordinals to write    * @throws IOException if an I/O error occurred.    */
DECL|method|addSortedField
specifier|public
specifier|abstract
name|void
name|addSortedField
parameter_list|(
name|FieldInfo
name|field
parameter_list|,
name|DocValuesProducer
name|valuesProducer
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Writes pre-sorted numeric docvalues for a field    * @param field field information    * @param valuesProducer produces the values to write    * @throws IOException if an I/O error occurred.    */
DECL|method|addSortedNumericField
specifier|public
specifier|abstract
name|void
name|addSortedNumericField
parameter_list|(
name|FieldInfo
name|field
parameter_list|,
name|DocValuesProducer
name|valuesProducer
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Writes pre-sorted set docvalues for a field    * @param field field information    * @param valuesProducer produces the values to write    * @throws IOException if an I/O error occurred.    */
DECL|method|addSortedSetField
specifier|public
specifier|abstract
name|void
name|addSortedSetField
parameter_list|(
name|FieldInfo
name|field
parameter_list|,
name|DocValuesProducer
name|valuesProducer
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Merges in the fields from the readers in     *<code>mergeState</code>. The default implementation     *  calls {@link #mergeNumericField}, {@link #mergeBinaryField},    *  {@link #mergeSortedField}, {@link #mergeSortedSetField},    *  or {@link #mergeSortedNumericField} for each field,    *  depending on its type.    *  Implementations can override this method     *  for more sophisticated merging (bulk-byte copying, etc). */
DECL|method|merge
specifier|public
name|void
name|merge
parameter_list|(
name|MergeState
name|mergeState
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|DocValuesProducer
name|docValuesProducer
range|:
name|mergeState
operator|.
name|docValuesProducers
control|)
block|{
if|if
condition|(
name|docValuesProducer
operator|!=
literal|null
condition|)
block|{
name|docValuesProducer
operator|.
name|checkIntegrity
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|FieldInfo
name|mergeFieldInfo
range|:
name|mergeState
operator|.
name|mergeFieldInfos
control|)
block|{
name|DocValuesType
name|type
init|=
name|mergeFieldInfo
operator|.
name|getDocValuesType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|DocValuesType
operator|.
name|NONE
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|DocValuesType
operator|.
name|NUMERIC
condition|)
block|{
name|mergeNumericField
argument_list|(
name|mergeFieldInfo
argument_list|,
name|mergeState
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|DocValuesType
operator|.
name|BINARY
condition|)
block|{
name|mergeBinaryField
argument_list|(
name|mergeFieldInfo
argument_list|,
name|mergeState
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|DocValuesType
operator|.
name|SORTED
condition|)
block|{
name|mergeSortedField
argument_list|(
name|mergeFieldInfo
argument_list|,
name|mergeState
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|DocValuesType
operator|.
name|SORTED_SET
condition|)
block|{
name|mergeSortedSetField
argument_list|(
name|mergeFieldInfo
argument_list|,
name|mergeState
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|DocValuesType
operator|.
name|SORTED_NUMERIC
condition|)
block|{
name|mergeSortedNumericField
argument_list|(
name|mergeFieldInfo
argument_list|,
name|mergeState
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"type="
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/** Tracks state of one numeric sub-reader that we are merging */
DECL|class|NumericDocValuesSub
specifier|private
specifier|static
class|class
name|NumericDocValuesSub
extends|extends
name|DocIDMerger
operator|.
name|Sub
block|{
DECL|field|values
specifier|final
name|NumericDocValues
name|values
decl_stmt|;
DECL|method|NumericDocValuesSub
specifier|public
name|NumericDocValuesSub
parameter_list|(
name|MergeState
operator|.
name|DocMap
name|docMap
parameter_list|,
name|NumericDocValues
name|values
parameter_list|)
block|{
name|super
argument_list|(
name|docMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|values
operator|=
name|values
expr_stmt|;
assert|assert
name|values
operator|.
name|docID
argument_list|()
operator|==
operator|-
literal|1
assert|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|values
operator|.
name|nextDoc
argument_list|()
return|;
block|}
block|}
comment|/**    * Merges the numeric docvalues from<code>MergeState</code>.    *<p>    * The default implementation calls {@link #addNumericField}, passing    * a DocValuesProducer that merges and filters deleted documents on the fly.    */
DECL|method|mergeNumericField
specifier|public
name|void
name|mergeNumericField
parameter_list|(
specifier|final
name|FieldInfo
name|mergeFieldInfo
parameter_list|,
specifier|final
name|MergeState
name|mergeState
parameter_list|)
throws|throws
name|IOException
block|{
name|addNumericField
argument_list|(
name|mergeFieldInfo
argument_list|,
operator|new
name|EmptyDocValuesProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|NumericDocValues
name|getNumeric
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldInfo
operator|!=
name|mergeFieldInfo
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"wrong fieldInfo"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|NumericDocValuesSub
argument_list|>
name|subs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
assert|assert
name|mergeState
operator|.
name|docMaps
operator|.
name|length
operator|==
name|mergeState
operator|.
name|docValuesProducers
operator|.
name|length
assert|;
name|long
name|cost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mergeState
operator|.
name|docValuesProducers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|NumericDocValues
name|values
init|=
literal|null
decl_stmt|;
name|DocValuesProducer
name|docValuesProducer
init|=
name|mergeState
operator|.
name|docValuesProducers
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|docValuesProducer
operator|!=
literal|null
condition|)
block|{
name|FieldInfo
name|readerFieldInfo
init|=
name|mergeState
operator|.
name|fieldInfos
index|[
name|i
index|]
operator|.
name|fieldInfo
argument_list|(
name|mergeFieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|readerFieldInfo
operator|!=
literal|null
operator|&&
name|readerFieldInfo
operator|.
name|getDocValuesType
argument_list|()
operator|==
name|DocValuesType
operator|.
name|NUMERIC
condition|)
block|{
name|values
operator|=
name|docValuesProducer
operator|.
name|getNumeric
argument_list|(
name|readerFieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|values
operator|!=
literal|null
condition|)
block|{
name|cost
operator|+=
name|values
operator|.
name|cost
argument_list|()
expr_stmt|;
name|subs
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesSub
argument_list|(
name|mergeState
operator|.
name|docMaps
index|[
name|i
index|]
argument_list|,
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|DocIDMerger
argument_list|<
name|NumericDocValuesSub
argument_list|>
name|docIDMerger
init|=
name|DocIDMerger
operator|.
name|of
argument_list|(
name|subs
argument_list|,
name|mergeState
operator|.
name|needsIndexSort
argument_list|)
decl_stmt|;
specifier|final
name|long
name|finalCost
init|=
name|cost
decl_stmt|;
return|return
operator|new
name|NumericDocValues
argument_list|()
block|{
specifier|private
name|int
name|docID
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|NumericDocValuesSub
name|current
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
name|current
operator|=
name|docIDMerger
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|docID
operator|=
name|NO_MORE_DOCS
expr_stmt|;
block|}
else|else
block|{
name|docID
operator|=
name|current
operator|.
name|mappedDocID
expr_stmt|;
block|}
return|return
name|docID
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advanceExact
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|finalCost
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|longValue
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|current
operator|.
name|values
operator|.
name|longValue
argument_list|()
return|;
block|}
block|}
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tracks state of one binary sub-reader that we are merging */
DECL|class|BinaryDocValuesSub
specifier|private
specifier|static
class|class
name|BinaryDocValuesSub
extends|extends
name|DocIDMerger
operator|.
name|Sub
block|{
DECL|field|values
specifier|final
name|BinaryDocValues
name|values
decl_stmt|;
DECL|method|BinaryDocValuesSub
specifier|public
name|BinaryDocValuesSub
parameter_list|(
name|MergeState
operator|.
name|DocMap
name|docMap
parameter_list|,
name|BinaryDocValues
name|values
parameter_list|)
block|{
name|super
argument_list|(
name|docMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|values
operator|=
name|values
expr_stmt|;
assert|assert
name|values
operator|.
name|docID
argument_list|()
operator|==
operator|-
literal|1
assert|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|values
operator|.
name|nextDoc
argument_list|()
return|;
block|}
block|}
comment|/**    * Merges the binary docvalues from<code>MergeState</code>.    *<p>    * The default implementation calls {@link #addBinaryField}, passing    * a DocValuesProducer that merges and filters deleted documents on the fly.    */
DECL|method|mergeBinaryField
specifier|public
name|void
name|mergeBinaryField
parameter_list|(
name|FieldInfo
name|mergeFieldInfo
parameter_list|,
specifier|final
name|MergeState
name|mergeState
parameter_list|)
throws|throws
name|IOException
block|{
name|addBinaryField
argument_list|(
name|mergeFieldInfo
argument_list|,
operator|new
name|EmptyDocValuesProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|BinaryDocValues
name|getBinary
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldInfo
operator|!=
name|mergeFieldInfo
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"wrong fieldInfo"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|BinaryDocValuesSub
argument_list|>
name|subs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|long
name|cost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mergeState
operator|.
name|docValuesProducers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|BinaryDocValues
name|values
init|=
literal|null
decl_stmt|;
name|DocValuesProducer
name|docValuesProducer
init|=
name|mergeState
operator|.
name|docValuesProducers
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|docValuesProducer
operator|!=
literal|null
condition|)
block|{
name|FieldInfo
name|readerFieldInfo
init|=
name|mergeState
operator|.
name|fieldInfos
index|[
name|i
index|]
operator|.
name|fieldInfo
argument_list|(
name|mergeFieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|readerFieldInfo
operator|!=
literal|null
operator|&&
name|readerFieldInfo
operator|.
name|getDocValuesType
argument_list|()
operator|==
name|DocValuesType
operator|.
name|BINARY
condition|)
block|{
name|values
operator|=
name|docValuesProducer
operator|.
name|getBinary
argument_list|(
name|readerFieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|values
operator|!=
literal|null
condition|)
block|{
name|cost
operator|+=
name|values
operator|.
name|cost
argument_list|()
expr_stmt|;
name|subs
operator|.
name|add
argument_list|(
operator|new
name|BinaryDocValuesSub
argument_list|(
name|mergeState
operator|.
name|docMaps
index|[
name|i
index|]
argument_list|,
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|DocIDMerger
argument_list|<
name|BinaryDocValuesSub
argument_list|>
name|docIDMerger
init|=
name|DocIDMerger
operator|.
name|of
argument_list|(
name|subs
argument_list|,
name|mergeState
operator|.
name|needsIndexSort
argument_list|)
decl_stmt|;
specifier|final
name|long
name|finalCost
init|=
name|cost
decl_stmt|;
return|return
operator|new
name|BinaryDocValues
argument_list|()
block|{
specifier|private
name|BinaryDocValuesSub
name|current
decl_stmt|;
specifier|private
name|int
name|docID
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
name|current
operator|=
name|docIDMerger
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|docID
operator|=
name|NO_MORE_DOCS
expr_stmt|;
block|}
else|else
block|{
name|docID
operator|=
name|current
operator|.
name|mappedDocID
expr_stmt|;
block|}
return|return
name|docID
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advanceExact
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|finalCost
return|;
block|}
annotation|@
name|Override
specifier|public
name|BytesRef
name|binaryValue
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|current
operator|.
name|values
operator|.
name|binaryValue
argument_list|()
return|;
block|}
block|}
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tracks state of one sorted numeric sub-reader that we are merging */
DECL|class|SortedNumericDocValuesSub
specifier|private
specifier|static
class|class
name|SortedNumericDocValuesSub
extends|extends
name|DocIDMerger
operator|.
name|Sub
block|{
DECL|field|values
specifier|final
name|SortedNumericDocValues
name|values
decl_stmt|;
DECL|method|SortedNumericDocValuesSub
specifier|public
name|SortedNumericDocValuesSub
parameter_list|(
name|MergeState
operator|.
name|DocMap
name|docMap
parameter_list|,
name|SortedNumericDocValues
name|values
parameter_list|)
block|{
name|super
argument_list|(
name|docMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|values
operator|=
name|values
expr_stmt|;
assert|assert
name|values
operator|.
name|docID
argument_list|()
operator|==
operator|-
literal|1
assert|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|values
operator|.
name|nextDoc
argument_list|()
return|;
block|}
block|}
comment|/**    * Merges the sorted docvalues from<code>toMerge</code>.    *<p>    * The default implementation calls {@link #addSortedNumericField}, passing    * iterables that filter deleted documents.    */
DECL|method|mergeSortedNumericField
specifier|public
name|void
name|mergeSortedNumericField
parameter_list|(
name|FieldInfo
name|mergeFieldInfo
parameter_list|,
specifier|final
name|MergeState
name|mergeState
parameter_list|)
throws|throws
name|IOException
block|{
name|addSortedNumericField
argument_list|(
name|mergeFieldInfo
argument_list|,
operator|new
name|EmptyDocValuesProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SortedNumericDocValues
name|getSortedNumeric
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldInfo
operator|!=
name|mergeFieldInfo
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"wrong FieldInfo"
argument_list|)
throw|;
block|}
comment|// We must make new iterators + DocIDMerger for each iterator:
name|List
argument_list|<
name|SortedNumericDocValuesSub
argument_list|>
name|subs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|long
name|cost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mergeState
operator|.
name|docValuesProducers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DocValuesProducer
name|docValuesProducer
init|=
name|mergeState
operator|.
name|docValuesProducers
index|[
name|i
index|]
decl_stmt|;
name|SortedNumericDocValues
name|values
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|docValuesProducer
operator|!=
literal|null
condition|)
block|{
name|FieldInfo
name|readerFieldInfo
init|=
name|mergeState
operator|.
name|fieldInfos
index|[
name|i
index|]
operator|.
name|fieldInfo
argument_list|(
name|mergeFieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|readerFieldInfo
operator|!=
literal|null
operator|&&
name|readerFieldInfo
operator|.
name|getDocValuesType
argument_list|()
operator|==
name|DocValuesType
operator|.
name|SORTED_NUMERIC
condition|)
block|{
name|values
operator|=
name|docValuesProducer
operator|.
name|getSortedNumeric
argument_list|(
name|readerFieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
name|values
operator|=
name|DocValues
operator|.
name|emptySortedNumeric
argument_list|(
name|mergeState
operator|.
name|maxDocs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|cost
operator|+=
name|values
operator|.
name|cost
argument_list|()
expr_stmt|;
name|subs
operator|.
name|add
argument_list|(
operator|new
name|SortedNumericDocValuesSub
argument_list|(
name|mergeState
operator|.
name|docMaps
index|[
name|i
index|]
argument_list|,
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|finalCost
init|=
name|cost
decl_stmt|;
specifier|final
name|DocIDMerger
argument_list|<
name|SortedNumericDocValuesSub
argument_list|>
name|docIDMerger
init|=
name|DocIDMerger
operator|.
name|of
argument_list|(
name|subs
argument_list|,
name|mergeState
operator|.
name|needsIndexSort
argument_list|)
decl_stmt|;
return|return
operator|new
name|SortedNumericDocValues
argument_list|()
block|{
specifier|private
name|int
name|docID
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|SortedNumericDocValuesSub
name|currentSub
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
name|currentSub
operator|=
name|docIDMerger
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentSub
operator|==
literal|null
condition|)
block|{
name|docID
operator|=
name|NO_MORE_DOCS
expr_stmt|;
block|}
else|else
block|{
name|docID
operator|=
name|currentSub
operator|.
name|mappedDocID
expr_stmt|;
block|}
return|return
name|docID
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advanceExact
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|docValueCount
parameter_list|()
block|{
return|return
name|currentSub
operator|.
name|values
operator|.
name|docValueCount
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|finalCost
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|nextValue
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|currentSub
operator|.
name|values
operator|.
name|nextValue
argument_list|()
return|;
block|}
block|}
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tracks state of one sorted sub-reader that we are merging */
DECL|class|SortedDocValuesSub
specifier|private
specifier|static
class|class
name|SortedDocValuesSub
extends|extends
name|DocIDMerger
operator|.
name|Sub
block|{
DECL|field|values
specifier|final
name|SortedDocValues
name|values
decl_stmt|;
DECL|field|map
specifier|final
name|LongValues
name|map
decl_stmt|;
DECL|method|SortedDocValuesSub
specifier|public
name|SortedDocValuesSub
parameter_list|(
name|MergeState
operator|.
name|DocMap
name|docMap
parameter_list|,
name|SortedDocValues
name|values
parameter_list|,
name|LongValues
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|docMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|values
operator|=
name|values
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
assert|assert
name|values
operator|.
name|docID
argument_list|()
operator|==
operator|-
literal|1
assert|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|values
operator|.
name|nextDoc
argument_list|()
return|;
block|}
block|}
comment|/**    * Merges the sorted docvalues from<code>toMerge</code>.    *<p>    * The default implementation calls {@link #addSortedField}, passing    * an Iterable that merges ordinals and values and filters deleted documents .    */
DECL|method|mergeSortedField
specifier|public
name|void
name|mergeSortedField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
specifier|final
name|MergeState
name|mergeState
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|SortedDocValues
argument_list|>
name|toMerge
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mergeState
operator|.
name|docValuesProducers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SortedDocValues
name|values
init|=
literal|null
decl_stmt|;
name|DocValuesProducer
name|docValuesProducer
init|=
name|mergeState
operator|.
name|docValuesProducers
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|docValuesProducer
operator|!=
literal|null
condition|)
block|{
name|FieldInfo
name|readerFieldInfo
init|=
name|mergeState
operator|.
name|fieldInfos
index|[
name|i
index|]
operator|.
name|fieldInfo
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|readerFieldInfo
operator|!=
literal|null
operator|&&
name|readerFieldInfo
operator|.
name|getDocValuesType
argument_list|()
operator|==
name|DocValuesType
operator|.
name|SORTED
condition|)
block|{
name|values
operator|=
name|docValuesProducer
operator|.
name|getSorted
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
name|values
operator|=
name|DocValues
operator|.
name|emptySorted
argument_list|()
expr_stmt|;
block|}
name|toMerge
operator|.
name|add
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|numReaders
init|=
name|toMerge
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|SortedDocValues
name|dvs
index|[]
init|=
name|toMerge
operator|.
name|toArray
argument_list|(
operator|new
name|SortedDocValues
index|[
name|numReaders
index|]
argument_list|)
decl_stmt|;
comment|// step 1: iterate thru each sub and mark terms still in use
name|TermsEnum
name|liveTerms
index|[]
init|=
operator|new
name|TermsEnum
index|[
name|dvs
operator|.
name|length
index|]
decl_stmt|;
name|long
index|[]
name|weights
init|=
operator|new
name|long
index|[
name|liveTerms
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|sub
init|=
literal|0
init|;
name|sub
operator|<
name|numReaders
condition|;
name|sub
operator|++
control|)
block|{
name|SortedDocValues
name|dv
init|=
name|dvs
index|[
name|sub
index|]
decl_stmt|;
name|Bits
name|liveDocs
init|=
name|mergeState
operator|.
name|liveDocs
index|[
name|sub
index|]
decl_stmt|;
if|if
condition|(
name|liveDocs
operator|==
literal|null
condition|)
block|{
name|liveTerms
index|[
name|sub
index|]
operator|=
name|dv
operator|.
name|termsEnum
argument_list|()
expr_stmt|;
name|weights
index|[
name|sub
index|]
operator|=
name|dv
operator|.
name|getValueCount
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LongBitSet
name|bitset
init|=
operator|new
name|LongBitSet
argument_list|(
name|dv
operator|.
name|getValueCount
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|docID
decl_stmt|;
while|while
condition|(
operator|(
name|docID
operator|=
name|dv
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|liveDocs
operator|.
name|get
argument_list|(
name|docID
argument_list|)
condition|)
block|{
name|int
name|ord
init|=
name|dv
operator|.
name|ordValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|ord
operator|>=
literal|0
condition|)
block|{
name|bitset
operator|.
name|set
argument_list|(
name|ord
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|liveTerms
index|[
name|sub
index|]
operator|=
operator|new
name|BitsFilteredTermsEnum
argument_list|(
name|dv
operator|.
name|termsEnum
argument_list|()
argument_list|,
name|bitset
argument_list|)
expr_stmt|;
name|weights
index|[
name|sub
index|]
operator|=
name|bitset
operator|.
name|cardinality
argument_list|()
expr_stmt|;
block|}
block|}
comment|// step 2: create ordinal map (this conceptually does the "merging")
specifier|final
name|OrdinalMap
name|map
init|=
name|OrdinalMap
operator|.
name|build
argument_list|(
name|this
argument_list|,
name|liveTerms
argument_list|,
name|weights
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|)
decl_stmt|;
comment|// step 3: add field
name|addSortedField
argument_list|(
name|fieldInfo
argument_list|,
operator|new
name|EmptyDocValuesProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SortedDocValues
name|getSorted
parameter_list|(
name|FieldInfo
name|fieldInfoIn
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldInfoIn
operator|!=
name|fieldInfo
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"wrong FieldInfo"
argument_list|)
throw|;
block|}
comment|// We must make new iterators + DocIDMerger for each iterator:
name|List
argument_list|<
name|SortedDocValuesSub
argument_list|>
name|subs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|long
name|cost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mergeState
operator|.
name|docValuesProducers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SortedDocValues
name|values
init|=
literal|null
decl_stmt|;
name|DocValuesProducer
name|docValuesProducer
init|=
name|mergeState
operator|.
name|docValuesProducers
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|docValuesProducer
operator|!=
literal|null
condition|)
block|{
name|FieldInfo
name|readerFieldInfo
init|=
name|mergeState
operator|.
name|fieldInfos
index|[
name|i
index|]
operator|.
name|fieldInfo
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|readerFieldInfo
operator|!=
literal|null
operator|&&
name|readerFieldInfo
operator|.
name|getDocValuesType
argument_list|()
operator|==
name|DocValuesType
operator|.
name|SORTED
condition|)
block|{
name|values
operator|=
name|docValuesProducer
operator|.
name|getSorted
argument_list|(
name|readerFieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
name|values
operator|=
name|DocValues
operator|.
name|emptySorted
argument_list|()
expr_stmt|;
block|}
name|cost
operator|+=
name|values
operator|.
name|cost
argument_list|()
expr_stmt|;
name|subs
operator|.
name|add
argument_list|(
operator|new
name|SortedDocValuesSub
argument_list|(
name|mergeState
operator|.
name|docMaps
index|[
name|i
index|]
argument_list|,
name|values
argument_list|,
name|map
operator|.
name|getGlobalOrds
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|finalCost
init|=
name|cost
decl_stmt|;
specifier|final
name|DocIDMerger
argument_list|<
name|SortedDocValuesSub
argument_list|>
name|docIDMerger
init|=
name|DocIDMerger
operator|.
name|of
argument_list|(
name|subs
argument_list|,
name|mergeState
operator|.
name|needsIndexSort
argument_list|)
decl_stmt|;
return|return
operator|new
name|SortedDocValues
argument_list|()
block|{
specifier|private
name|int
name|docID
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|int
name|ord
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
name|SortedDocValuesSub
name|sub
init|=
name|docIDMerger
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|sub
operator|==
literal|null
condition|)
block|{
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
name|int
name|subOrd
init|=
name|sub
operator|.
name|values
operator|.
name|ordValue
argument_list|()
decl_stmt|;
assert|assert
name|subOrd
operator|!=
operator|-
literal|1
assert|;
name|ord
operator|=
operator|(
name|int
operator|)
name|sub
operator|.
name|map
operator|.
name|get
argument_list|(
name|subOrd
argument_list|)
expr_stmt|;
name|docID
operator|=
name|sub
operator|.
name|mappedDocID
expr_stmt|;
return|return
name|docID
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|ordValue
parameter_list|()
block|{
return|return
name|ord
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advanceExact
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|finalCost
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getValueCount
parameter_list|()
block|{
return|return
operator|(
name|int
operator|)
name|map
operator|.
name|getValueCount
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|BytesRef
name|lookupOrd
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|segmentNumber
init|=
name|map
operator|.
name|getFirstSegmentNumber
argument_list|(
name|ord
argument_list|)
decl_stmt|;
name|int
name|segmentOrd
init|=
operator|(
name|int
operator|)
name|map
operator|.
name|getFirstSegmentOrd
argument_list|(
name|ord
argument_list|)
decl_stmt|;
return|return
name|dvs
index|[
name|segmentNumber
index|]
operator|.
name|lookupOrd
argument_list|(
name|segmentOrd
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tracks state of one sorted set sub-reader that we are merging */
DECL|class|SortedSetDocValuesSub
specifier|private
specifier|static
class|class
name|SortedSetDocValuesSub
extends|extends
name|DocIDMerger
operator|.
name|Sub
block|{
DECL|field|values
specifier|final
name|SortedSetDocValues
name|values
decl_stmt|;
DECL|field|map
specifier|final
name|LongValues
name|map
decl_stmt|;
DECL|method|SortedSetDocValuesSub
specifier|public
name|SortedSetDocValuesSub
parameter_list|(
name|MergeState
operator|.
name|DocMap
name|docMap
parameter_list|,
name|SortedSetDocValues
name|values
parameter_list|,
name|LongValues
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|docMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|values
operator|=
name|values
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
assert|assert
name|values
operator|.
name|docID
argument_list|()
operator|==
operator|-
literal|1
assert|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|values
operator|.
name|nextDoc
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"SortedSetDocValuesSub(mappedDocID="
operator|+
name|mappedDocID
operator|+
literal|" values="
operator|+
name|values
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * Merges the sortedset docvalues from<code>toMerge</code>.    *<p>    * The default implementation calls {@link #addSortedSetField}, passing    * an Iterable that merges ordinals and values and filters deleted documents .    */
DECL|method|mergeSortedSetField
specifier|public
name|void
name|mergeSortedSetField
parameter_list|(
name|FieldInfo
name|mergeFieldInfo
parameter_list|,
specifier|final
name|MergeState
name|mergeState
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|SortedSetDocValues
argument_list|>
name|toMerge
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mergeState
operator|.
name|docValuesProducers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SortedSetDocValues
name|values
init|=
literal|null
decl_stmt|;
name|DocValuesProducer
name|docValuesProducer
init|=
name|mergeState
operator|.
name|docValuesProducers
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|docValuesProducer
operator|!=
literal|null
condition|)
block|{
name|FieldInfo
name|fieldInfo
init|=
name|mergeState
operator|.
name|fieldInfos
index|[
name|i
index|]
operator|.
name|fieldInfo
argument_list|(
name|mergeFieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldInfo
operator|!=
literal|null
operator|&&
name|fieldInfo
operator|.
name|getDocValuesType
argument_list|()
operator|==
name|DocValuesType
operator|.
name|SORTED_SET
condition|)
block|{
name|values
operator|=
name|docValuesProducer
operator|.
name|getSortedSet
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
name|values
operator|=
name|DocValues
operator|.
name|emptySortedSet
argument_list|()
expr_stmt|;
block|}
name|toMerge
operator|.
name|add
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
comment|// step 1: iterate thru each sub and mark terms still in use
name|TermsEnum
name|liveTerms
index|[]
init|=
operator|new
name|TermsEnum
index|[
name|toMerge
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|long
index|[]
name|weights
init|=
operator|new
name|long
index|[
name|liveTerms
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|sub
init|=
literal|0
init|;
name|sub
operator|<
name|liveTerms
operator|.
name|length
condition|;
name|sub
operator|++
control|)
block|{
name|SortedSetDocValues
name|dv
init|=
name|toMerge
operator|.
name|get
argument_list|(
name|sub
argument_list|)
decl_stmt|;
name|Bits
name|liveDocs
init|=
name|mergeState
operator|.
name|liveDocs
index|[
name|sub
index|]
decl_stmt|;
if|if
condition|(
name|liveDocs
operator|==
literal|null
condition|)
block|{
name|liveTerms
index|[
name|sub
index|]
operator|=
name|dv
operator|.
name|termsEnum
argument_list|()
expr_stmt|;
name|weights
index|[
name|sub
index|]
operator|=
name|dv
operator|.
name|getValueCount
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LongBitSet
name|bitset
init|=
operator|new
name|LongBitSet
argument_list|(
name|dv
operator|.
name|getValueCount
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|docID
decl_stmt|;
while|while
condition|(
operator|(
name|docID
operator|=
name|dv
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|liveDocs
operator|.
name|get
argument_list|(
name|docID
argument_list|)
condition|)
block|{
name|long
name|ord
decl_stmt|;
while|while
condition|(
operator|(
name|ord
operator|=
name|dv
operator|.
name|nextOrd
argument_list|()
operator|)
operator|!=
name|SortedSetDocValues
operator|.
name|NO_MORE_ORDS
condition|)
block|{
name|bitset
operator|.
name|set
argument_list|(
name|ord
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|liveTerms
index|[
name|sub
index|]
operator|=
operator|new
name|BitsFilteredTermsEnum
argument_list|(
name|dv
operator|.
name|termsEnum
argument_list|()
argument_list|,
name|bitset
argument_list|)
expr_stmt|;
name|weights
index|[
name|sub
index|]
operator|=
name|bitset
operator|.
name|cardinality
argument_list|()
expr_stmt|;
block|}
block|}
comment|// step 2: create ordinal map (this conceptually does the "merging")
specifier|final
name|OrdinalMap
name|map
init|=
name|OrdinalMap
operator|.
name|build
argument_list|(
name|this
argument_list|,
name|liveTerms
argument_list|,
name|weights
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|)
decl_stmt|;
comment|// step 3: add field
name|addSortedSetField
argument_list|(
name|mergeFieldInfo
argument_list|,
operator|new
name|EmptyDocValuesProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SortedSetDocValues
name|getSortedSet
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldInfo
operator|!=
name|mergeFieldInfo
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"wrong FieldInfo"
argument_list|)
throw|;
block|}
comment|// We must make new iterators + DocIDMerger for each iterator:
name|List
argument_list|<
name|SortedSetDocValuesSub
argument_list|>
name|subs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|long
name|cost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mergeState
operator|.
name|docValuesProducers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SortedSetDocValues
name|values
init|=
literal|null
decl_stmt|;
name|DocValuesProducer
name|docValuesProducer
init|=
name|mergeState
operator|.
name|docValuesProducers
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|docValuesProducer
operator|!=
literal|null
condition|)
block|{
name|FieldInfo
name|readerFieldInfo
init|=
name|mergeState
operator|.
name|fieldInfos
index|[
name|i
index|]
operator|.
name|fieldInfo
argument_list|(
name|mergeFieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|readerFieldInfo
operator|!=
literal|null
operator|&&
name|readerFieldInfo
operator|.
name|getDocValuesType
argument_list|()
operator|==
name|DocValuesType
operator|.
name|SORTED_SET
condition|)
block|{
name|values
operator|=
name|docValuesProducer
operator|.
name|getSortedSet
argument_list|(
name|readerFieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
name|values
operator|=
name|DocValues
operator|.
name|emptySortedSet
argument_list|()
expr_stmt|;
block|}
name|cost
operator|+=
name|values
operator|.
name|cost
argument_list|()
expr_stmt|;
name|subs
operator|.
name|add
argument_list|(
operator|new
name|SortedSetDocValuesSub
argument_list|(
name|mergeState
operator|.
name|docMaps
index|[
name|i
index|]
argument_list|,
name|values
argument_list|,
name|map
operator|.
name|getGlobalOrds
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DocIDMerger
argument_list|<
name|SortedSetDocValuesSub
argument_list|>
name|docIDMerger
init|=
name|DocIDMerger
operator|.
name|of
argument_list|(
name|subs
argument_list|,
name|mergeState
operator|.
name|needsIndexSort
argument_list|)
decl_stmt|;
specifier|final
name|long
name|finalCost
init|=
name|cost
decl_stmt|;
return|return
operator|new
name|SortedSetDocValues
argument_list|()
block|{
specifier|private
name|int
name|docID
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|SortedSetDocValuesSub
name|currentSub
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
name|currentSub
operator|=
name|docIDMerger
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentSub
operator|==
literal|null
condition|)
block|{
name|docID
operator|=
name|NO_MORE_DOCS
expr_stmt|;
block|}
else|else
block|{
name|docID
operator|=
name|currentSub
operator|.
name|mappedDocID
expr_stmt|;
block|}
return|return
name|docID
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advanceExact
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|nextOrd
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|subOrd
init|=
name|currentSub
operator|.
name|values
operator|.
name|nextOrd
argument_list|()
decl_stmt|;
if|if
condition|(
name|subOrd
operator|==
name|NO_MORE_ORDS
condition|)
block|{
return|return
name|NO_MORE_ORDS
return|;
block|}
return|return
name|currentSub
operator|.
name|map
operator|.
name|get
argument_list|(
name|subOrd
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|finalCost
return|;
block|}
annotation|@
name|Override
specifier|public
name|BytesRef
name|lookupOrd
parameter_list|(
name|long
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|segmentNumber
init|=
name|map
operator|.
name|getFirstSegmentNumber
argument_list|(
name|ord
argument_list|)
decl_stmt|;
name|long
name|segmentOrd
init|=
name|map
operator|.
name|getFirstSegmentOrd
argument_list|(
name|ord
argument_list|)
decl_stmt|;
return|return
name|toMerge
operator|.
name|get
argument_list|(
name|segmentNumber
argument_list|)
operator|.
name|lookupOrd
argument_list|(
name|segmentOrd
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getValueCount
parameter_list|()
block|{
return|return
name|map
operator|.
name|getValueCount
argument_list|()
return|;
block|}
block|}
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// TODO: seek-by-ord to nextSetBit
DECL|class|BitsFilteredTermsEnum
specifier|static
class|class
name|BitsFilteredTermsEnum
extends|extends
name|FilteredTermsEnum
block|{
DECL|field|liveTerms
specifier|final
name|LongBitSet
name|liveTerms
decl_stmt|;
DECL|method|BitsFilteredTermsEnum
name|BitsFilteredTermsEnum
parameter_list|(
name|TermsEnum
name|in
parameter_list|,
name|LongBitSet
name|liveTerms
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//<-- not passing false here wasted about 3 hours of my time!!!!!!!!!!!!!
assert|assert
name|liveTerms
operator|!=
literal|null
assert|;
name|this
operator|.
name|liveTerms
operator|=
name|liveTerms
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|accept
specifier|protected
name|AcceptStatus
name|accept
parameter_list|(
name|BytesRef
name|term
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|liveTerms
operator|.
name|get
argument_list|(
name|ord
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|AcceptStatus
operator|.
name|YES
return|;
block|}
else|else
block|{
return|return
name|AcceptStatus
operator|.
name|NO
return|;
block|}
block|}
block|}
comment|/** Helper: returns true if the given docToValue count contains only at most one value */
DECL|method|isSingleValued
specifier|public
specifier|static
name|boolean
name|isSingleValued
parameter_list|(
name|Iterable
argument_list|<
name|Number
argument_list|>
name|docToValueCount
parameter_list|)
block|{
for|for
control|(
name|Number
name|count
range|:
name|docToValueCount
control|)
block|{
if|if
condition|(
name|count
operator|.
name|longValue
argument_list|()
operator|>
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** Helper: returns single-valued view, using {@code missingValue} when count is zero */
DECL|method|singletonView
specifier|public
specifier|static
name|Iterable
argument_list|<
name|Number
argument_list|>
name|singletonView
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|Number
argument_list|>
name|docToValueCount
parameter_list|,
specifier|final
name|Iterable
argument_list|<
name|Number
argument_list|>
name|values
parameter_list|,
specifier|final
name|Number
name|missingValue
parameter_list|)
block|{
assert|assert
name|isSingleValued
argument_list|(
name|docToValueCount
argument_list|)
assert|;
return|return
operator|new
name|Iterable
argument_list|<
name|Number
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Number
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Number
argument_list|>
name|countIterator
init|=
name|docToValueCount
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|Number
argument_list|>
name|valuesIterator
init|=
name|values
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|Number
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|countIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Number
name|next
parameter_list|()
block|{
name|int
name|count
init|=
name|countIterator
operator|.
name|next
argument_list|()
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
return|return
name|missingValue
return|;
block|}
else|else
block|{
return|return
name|valuesIterator
operator|.
name|next
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
block|}
end_class

end_unit

