begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.codecs.lucene70
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene70
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|DocValuesConsumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|DocValuesFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|DocValuesProducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentReadState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentWriteState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|SmallFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|DirectWriter
import|;
end_import

begin_comment
comment|/**  * Lucene 7.0 DocValues format.  *<p>  * Documents that have a value for the field are encoded in a way that it is always possible to  * know the ordinal of the current document in the set of documents that have a value. For instance,  * say the set of documents that have a value for the field is<tt>{1, 5, 6, 11}</tt>. When the  * iterator is on<tt>6</tt>, it knows that this is the 3rd item of the set. This way, values can  * be stored densely and accessed based on their index at search time. If all documents in a segment  * have a value for the field, the index is the same as the doc ID, so this case is encoded implicitly  * and is very fast at query time. On the other hand if some documents are missing a value for the  * field then the set of documents that have a value is encoded into blocks. All doc IDs that share  * the same upper 16 bits are encoded into the same block with the following strategies:  *<ul>  *<li>SPARSE: This strategy is used when a block contains at most 4095 documents. The lower 16  *         bits of doc IDs are stored as {@link DataOutput#writeShort(short) shorts} while the upper  *         16 bits are given by the block ID.  *<li>DENSE: This strategy is used when a block contains between 4096 and 65535 documents. The  *         lower bits of doc IDs are stored in a bit set. Advancing is performed using  *         {@link Long#numberOfTrailingZeros(long) ntz} operations while the index is computed by  *         accumulating the {@link Long#bitCount(long) bit counts} of the visited longs.  *<li>ALL: This strategy is used when a block contains exactly 65536 documents, meaning that  *         the block is full. In that case doc IDs do not need to be stored explicitly. This is  *         typically faster than both SPARSE and DENSE which is a reason why it is preferable to have  *         all documents that have a value for a field using contiguous doc IDs, for instance by  *         using {@link IndexWriterConfig#setIndexSort(org.apache.lucene.search.Sort) index sorting}.  *</ul>  *<p>  * Then the five per-document value types (Numeric,Binary,Sorted,SortedSet,SortedNumeric) are  * encoded using the following strategies:  *<p>  * {@link DocValuesType#NUMERIC NUMERIC}:  *<ul>  *<li>Delta-compressed: per-document integers written as deltas from the minimum value,  *        compressed with bitpacking. For more information, see {@link DirectWriter}.  *<li>Table-compressed: when the number of unique values is very small (&lt; 256), and  *        when there are unused "gaps" in the range of values used (such as {@link SmallFloat}),  *        a lookup table is written instead. Each per-document entry is instead the ordinal  *        to this table, and those ordinals are compressed with bitpacking ({@link DirectWriter}).  *<li>GCD-compressed: when all numbers share a common divisor, such as dates, the greatest  *        common denominator (GCD) is computed, and quotients are stored using Delta-compressed Numerics.  *<li>Monotonic-compressed: when all numbers are monotonically increasing offsets, they are written  *        as blocks of bitpacked integers, encoding the deviation from the expected delta.  *<li>Const-compressed: when there is only one possible value, no per-document data is needed and  *        this value is encoded alone.  *</ul>  *<p>  * {@link DocValuesType#BINARY BINARY}:  *<ul>  *<li>Fixed-width Binary: one large concatenated byte[] is written, along with the fixed length.  *        Each document's value can be addressed directly with multiplication ({@code docID * length}).  *<li>Variable-width Binary: one large concatenated byte[] is written, along with end addresses  *        for each document. The addresses are written as Monotonic-compressed numerics.  *<li>Prefix-compressed Binary: values are written in chunks of 16, with the first value written  *        completely and other values sharing prefixes. chunk addresses are written as Monotonic-compressed  *        numerics. A reverse lookup index is written from a portion of every 1024th term.  *</ul>  *<p>  * {@link DocValuesType#SORTED SORTED}:  *<ul>  *<li>Sorted: a mapping of ordinals to deduplicated terms is written as Prefix-compressed Binary,  *        along with the per-document ordinals written using one of the numeric strategies above.  *</ul>  *<p>  * {@link DocValuesType#SORTED_SET SORTED_SET}:  *<ul>  *<li>Single: if all documents have 0 or 1 value, then data are written like SORTED.  *<li>SortedSet: a mapping of ordinals to deduplicated terms is written as Binary,  *        an ordinal list and per-document index into this list are written using the numeric strategies  *        above.  *</ul>  *<p>  * {@link DocValuesType#SORTED_NUMERIC SORTED_NUMERIC}:  *<ul>  *<li>Single: if all documents have 0 or 1 value, then data are written like NUMERIC.  *<li>SortedNumeric: a value list and per-document index into this list are written using the numeric  *        strategies above.  *</ul>  *<p>  * Files:  *<ol>  *<li><tt>.dvd</tt>: DocValues data</li>  *<li><tt>.dvm</tt>: DocValues metadata</li>  *</ol>  * @lucene.experimental  */
end_comment

begin_class
DECL|class|Lucene70DocValuesFormat
specifier|public
specifier|final
class|class
name|Lucene70DocValuesFormat
extends|extends
name|DocValuesFormat
block|{
comment|/** Sole Constructor */
DECL|method|Lucene70DocValuesFormat
specifier|public
name|Lucene70DocValuesFormat
parameter_list|()
block|{
name|super
argument_list|(
literal|"Lucene70"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|fieldsConsumer
specifier|public
name|DocValuesConsumer
name|fieldsConsumer
parameter_list|(
name|SegmentWriteState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Lucene70DocValuesConsumer
argument_list|(
name|state
argument_list|,
name|DATA_CODEC
argument_list|,
name|DATA_EXTENSION
argument_list|,
name|META_CODEC
argument_list|,
name|META_EXTENSION
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|fieldsProducer
specifier|public
name|DocValuesProducer
name|fieldsProducer
parameter_list|(
name|SegmentReadState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Lucene70DocValuesProducer
argument_list|(
name|state
argument_list|,
name|DATA_CODEC
argument_list|,
name|DATA_EXTENSION
argument_list|,
name|META_CODEC
argument_list|,
name|META_EXTENSION
argument_list|)
return|;
block|}
DECL|field|DATA_CODEC
specifier|static
specifier|final
name|String
name|DATA_CODEC
init|=
literal|"Lucene70DocValuesData"
decl_stmt|;
DECL|field|DATA_EXTENSION
specifier|static
specifier|final
name|String
name|DATA_EXTENSION
init|=
literal|"dvd"
decl_stmt|;
DECL|field|META_CODEC
specifier|static
specifier|final
name|String
name|META_CODEC
init|=
literal|"Lucene70DocValuesMetadata"
decl_stmt|;
DECL|field|META_EXTENSION
specifier|static
specifier|final
name|String
name|META_EXTENSION
init|=
literal|"dvm"
decl_stmt|;
DECL|field|VERSION_START
specifier|static
specifier|final
name|int
name|VERSION_START
init|=
literal|0
decl_stmt|;
DECL|field|VERSION_CURRENT
specifier|static
specifier|final
name|int
name|VERSION_CURRENT
init|=
name|VERSION_START
decl_stmt|;
comment|// indicates docvalues type
DECL|field|NUMERIC
specifier|static
specifier|final
name|byte
name|NUMERIC
init|=
literal|0
decl_stmt|;
DECL|field|BINARY
specifier|static
specifier|final
name|byte
name|BINARY
init|=
literal|1
decl_stmt|;
DECL|field|SORTED
specifier|static
specifier|final
name|byte
name|SORTED
init|=
literal|2
decl_stmt|;
DECL|field|SORTED_SET
specifier|static
specifier|final
name|byte
name|SORTED_SET
init|=
literal|3
decl_stmt|;
DECL|field|SORTED_NUMERIC
specifier|static
specifier|final
name|byte
name|SORTED_NUMERIC
init|=
literal|4
decl_stmt|;
DECL|field|DIRECT_MONOTONIC_BLOCK_SHIFT
specifier|static
specifier|final
name|int
name|DIRECT_MONOTONIC_BLOCK_SHIFT
init|=
literal|16
decl_stmt|;
DECL|field|NUMERIC_BLOCK_SHIFT
specifier|static
specifier|final
name|int
name|NUMERIC_BLOCK_SHIFT
init|=
literal|14
decl_stmt|;
DECL|field|NUMERIC_BLOCK_SIZE
specifier|static
specifier|final
name|int
name|NUMERIC_BLOCK_SIZE
init|=
literal|1
operator|<<
name|NUMERIC_BLOCK_SHIFT
decl_stmt|;
DECL|field|TERMS_DICT_BLOCK_SHIFT
specifier|static
specifier|final
name|int
name|TERMS_DICT_BLOCK_SHIFT
init|=
literal|4
decl_stmt|;
DECL|field|TERMS_DICT_BLOCK_SIZE
specifier|static
specifier|final
name|int
name|TERMS_DICT_BLOCK_SIZE
init|=
literal|1
operator|<<
name|TERMS_DICT_BLOCK_SHIFT
decl_stmt|;
DECL|field|TERMS_DICT_BLOCK_MASK
specifier|static
specifier|final
name|int
name|TERMS_DICT_BLOCK_MASK
init|=
name|TERMS_DICT_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|field|TERMS_DICT_REVERSE_INDEX_SHIFT
specifier|static
specifier|final
name|int
name|TERMS_DICT_REVERSE_INDEX_SHIFT
init|=
literal|10
decl_stmt|;
DECL|field|TERMS_DICT_REVERSE_INDEX_SIZE
specifier|static
specifier|final
name|int
name|TERMS_DICT_REVERSE_INDEX_SIZE
init|=
literal|1
operator|<<
name|TERMS_DICT_REVERSE_INDEX_SHIFT
decl_stmt|;
DECL|field|TERMS_DICT_REVERSE_INDEX_MASK
specifier|static
specifier|final
name|int
name|TERMS_DICT_REVERSE_INDEX_MASK
init|=
name|TERMS_DICT_REVERSE_INDEX_SIZE
operator|-
literal|1
decl_stmt|;
block|}
end_class

end_unit

