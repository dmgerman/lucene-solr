begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.codecs.perfield
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|perfield
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|FieldsProducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import

begin_comment
comment|/**  * Utility class to update the {@link MergeState} instance to be restricted to a set of fields.  *<p>  * Warning: the input {@linkplain MergeState} instance will be updated when calling {@link #apply(Collection)}.  *<p>  * It should be called within a {@code try&#123;...&#125; finally&#123;...&#125;} block to make sure that the mergeState instance is  * restored to its original state:  *<pre>  * PerFieldMergeState pfMergeState = new PerFieldMergeState(mergeState);  * try {  *   doSomething(pfMergeState.apply(fields));  *   ...  * } finally {  *   pfMergeState.reset();  * }  *</pre>  */
end_comment

begin_class
DECL|class|PerFieldMergeState
specifier|final
class|class
name|PerFieldMergeState
block|{
DECL|field|in
specifier|private
specifier|final
name|MergeState
name|in
decl_stmt|;
DECL|field|orgMergeFieldInfos
specifier|private
specifier|final
name|FieldInfos
name|orgMergeFieldInfos
decl_stmt|;
DECL|field|orgFieldInfos
specifier|private
specifier|final
name|FieldInfos
index|[]
name|orgFieldInfos
decl_stmt|;
DECL|field|orgFieldsProducers
specifier|private
specifier|final
name|FieldsProducer
index|[]
name|orgFieldsProducers
decl_stmt|;
DECL|method|PerFieldMergeState
name|PerFieldMergeState
parameter_list|(
name|MergeState
name|in
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|orgMergeFieldInfos
operator|=
name|in
operator|.
name|mergeFieldInfos
expr_stmt|;
name|this
operator|.
name|orgFieldInfos
operator|=
operator|new
name|FieldInfos
index|[
name|in
operator|.
name|fieldInfos
operator|.
name|length
index|]
expr_stmt|;
name|this
operator|.
name|orgFieldsProducers
operator|=
operator|new
name|FieldsProducer
index|[
name|in
operator|.
name|fieldsProducers
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|in
operator|.
name|fieldInfos
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|orgFieldInfos
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|orgFieldInfos
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|in
operator|.
name|fieldsProducers
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|orgFieldsProducers
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|orgFieldsProducers
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Update the input {@link MergeState} instance to restrict the fields to the given ones.    *    * @param fields The fields to keep in the updated instance.    * @return The updated instance.    */
DECL|method|apply
name|MergeState
name|apply
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
block|{
name|in
operator|.
name|mergeFieldInfos
operator|=
operator|new
name|FilterFieldInfos
argument_list|(
name|orgMergeFieldInfos
argument_list|,
name|fields
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|orgFieldInfos
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|in
operator|.
name|fieldInfos
index|[
name|i
index|]
operator|=
operator|new
name|FilterFieldInfos
argument_list|(
name|orgFieldInfos
index|[
name|i
index|]
argument_list|,
name|fields
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|orgFieldsProducers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|in
operator|.
name|fieldsProducers
index|[
name|i
index|]
operator|=
operator|new
name|FilterFieldsProducer
argument_list|(
name|orgFieldsProducers
index|[
name|i
index|]
argument_list|,
name|fields
argument_list|)
expr_stmt|;
block|}
return|return
name|in
return|;
block|}
comment|/**    * Resets the input {@link MergeState} instance to its original state.    *    * @return The reset instance.    */
DECL|method|reset
name|MergeState
name|reset
parameter_list|()
block|{
name|in
operator|.
name|mergeFieldInfos
operator|=
name|orgMergeFieldInfos
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|orgFieldInfos
argument_list|,
literal|0
argument_list|,
name|in
operator|.
name|fieldInfos
argument_list|,
literal|0
argument_list|,
name|in
operator|.
name|fieldInfos
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|orgFieldsProducers
argument_list|,
literal|0
argument_list|,
name|in
operator|.
name|fieldsProducers
argument_list|,
literal|0
argument_list|,
name|in
operator|.
name|fieldsProducers
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
DECL|class|FilterFieldInfos
specifier|private
specifier|static
class|class
name|FilterFieldInfos
extends|extends
name|FieldInfos
block|{
DECL|field|filteredNames
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|filteredNames
decl_stmt|;
DECL|field|filtered
specifier|private
specifier|final
name|List
argument_list|<
name|FieldInfo
argument_list|>
name|filtered
decl_stmt|;
comment|// Copy of the private fields from FieldInfos
comment|// Renamed so as to be less confusing about which fields we're referring to
DECL|field|filteredHasVectors
specifier|private
specifier|final
name|boolean
name|filteredHasVectors
decl_stmt|;
DECL|field|filteredHasProx
specifier|private
specifier|final
name|boolean
name|filteredHasProx
decl_stmt|;
DECL|field|filteredHasPayloads
specifier|private
specifier|final
name|boolean
name|filteredHasPayloads
decl_stmt|;
DECL|field|filteredHasOffsets
specifier|private
specifier|final
name|boolean
name|filteredHasOffsets
decl_stmt|;
DECL|field|filteredHasFreq
specifier|private
specifier|final
name|boolean
name|filteredHasFreq
decl_stmt|;
DECL|field|filteredHasNorms
specifier|private
specifier|final
name|boolean
name|filteredHasNorms
decl_stmt|;
DECL|field|filteredHasDocValues
specifier|private
specifier|final
name|boolean
name|filteredHasDocValues
decl_stmt|;
DECL|field|filteredHasPointValues
specifier|private
specifier|final
name|boolean
name|filteredHasPointValues
decl_stmt|;
DECL|method|FilterFieldInfos
name|FilterFieldInfos
parameter_list|(
name|FieldInfos
name|src
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|filterFields
parameter_list|)
block|{
comment|// Copy all the input FieldInfo objects since the field numbering must be kept consistent
name|super
argument_list|(
name|toArray
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|hasVectors
init|=
literal|false
decl_stmt|;
name|boolean
name|hasProx
init|=
literal|false
decl_stmt|;
name|boolean
name|hasPayloads
init|=
literal|false
decl_stmt|;
name|boolean
name|hasOffsets
init|=
literal|false
decl_stmt|;
name|boolean
name|hasFreq
init|=
literal|false
decl_stmt|;
name|boolean
name|hasNorms
init|=
literal|false
decl_stmt|;
name|boolean
name|hasDocValues
init|=
literal|false
decl_stmt|;
name|boolean
name|hasPointValues
init|=
literal|false
decl_stmt|;
name|this
operator|.
name|filteredNames
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|filterFields
argument_list|)
expr_stmt|;
name|this
operator|.
name|filtered
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|filterFields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|src
control|)
block|{
if|if
condition|(
name|filterFields
operator|.
name|contains
argument_list|(
name|fi
operator|.
name|name
argument_list|)
condition|)
block|{
name|this
operator|.
name|filtered
operator|.
name|add
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|hasVectors
operator||=
name|fi
operator|.
name|hasVectors
argument_list|()
expr_stmt|;
name|hasProx
operator||=
name|fi
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|hasFreq
operator||=
name|fi
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS
expr_stmt|;
name|hasOffsets
operator||=
name|fi
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|hasNorms
operator||=
name|fi
operator|.
name|hasNorms
argument_list|()
expr_stmt|;
name|hasDocValues
operator||=
name|fi
operator|.
name|getDocValuesType
argument_list|()
operator|!=
name|DocValuesType
operator|.
name|NONE
expr_stmt|;
name|hasPayloads
operator||=
name|fi
operator|.
name|hasPayloads
argument_list|()
expr_stmt|;
name|hasPointValues
operator||=
operator|(
name|fi
operator|.
name|getPointDimensionCount
argument_list|()
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|filteredHasVectors
operator|=
name|hasVectors
expr_stmt|;
name|this
operator|.
name|filteredHasProx
operator|=
name|hasProx
expr_stmt|;
name|this
operator|.
name|filteredHasPayloads
operator|=
name|hasPayloads
expr_stmt|;
name|this
operator|.
name|filteredHasOffsets
operator|=
name|hasOffsets
expr_stmt|;
name|this
operator|.
name|filteredHasFreq
operator|=
name|hasFreq
expr_stmt|;
name|this
operator|.
name|filteredHasNorms
operator|=
name|hasNorms
expr_stmt|;
name|this
operator|.
name|filteredHasDocValues
operator|=
name|hasDocValues
expr_stmt|;
name|this
operator|.
name|filteredHasPointValues
operator|=
name|hasPointValues
expr_stmt|;
block|}
DECL|method|toArray
specifier|private
specifier|static
name|FieldInfo
index|[]
name|toArray
parameter_list|(
name|FieldInfos
name|src
parameter_list|)
block|{
name|FieldInfo
index|[]
name|res
init|=
operator|new
name|FieldInfo
index|[
name|src
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|src
control|)
block|{
name|res
index|[
name|i
operator|++
index|]
operator|=
name|fi
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|FieldInfo
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|filtered
operator|.
name|iterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasFreq
specifier|public
name|boolean
name|hasFreq
parameter_list|()
block|{
return|return
name|filteredHasFreq
return|;
block|}
annotation|@
name|Override
DECL|method|hasProx
specifier|public
name|boolean
name|hasProx
parameter_list|()
block|{
return|return
name|filteredHasProx
return|;
block|}
annotation|@
name|Override
DECL|method|hasPayloads
specifier|public
name|boolean
name|hasPayloads
parameter_list|()
block|{
return|return
name|filteredHasPayloads
return|;
block|}
annotation|@
name|Override
DECL|method|hasOffsets
specifier|public
name|boolean
name|hasOffsets
parameter_list|()
block|{
return|return
name|filteredHasOffsets
return|;
block|}
annotation|@
name|Override
DECL|method|hasVectors
specifier|public
name|boolean
name|hasVectors
parameter_list|()
block|{
return|return
name|filteredHasVectors
return|;
block|}
annotation|@
name|Override
DECL|method|hasNorms
specifier|public
name|boolean
name|hasNorms
parameter_list|()
block|{
return|return
name|filteredHasNorms
return|;
block|}
annotation|@
name|Override
DECL|method|hasDocValues
specifier|public
name|boolean
name|hasDocValues
parameter_list|()
block|{
return|return
name|filteredHasDocValues
return|;
block|}
annotation|@
name|Override
DECL|method|hasPointValues
specifier|public
name|boolean
name|hasPointValues
parameter_list|()
block|{
return|return
name|filteredHasPointValues
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|filtered
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|fieldInfo
specifier|public
name|FieldInfo
name|fieldInfo
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|filteredNames
operator|.
name|contains
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
comment|// Throw IAE to be consistent with fieldInfo(int) which throws it as well on invalid numbers
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The field named '"
operator|+
name|fieldName
operator|+
literal|"' is not accessible in the current "
operator|+
literal|"merge context, available ones are: "
operator|+
name|filteredNames
argument_list|)
throw|;
block|}
return|return
name|super
operator|.
name|fieldInfo
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|fieldInfo
specifier|public
name|FieldInfo
name|fieldInfo
parameter_list|(
name|int
name|fieldNumber
parameter_list|)
block|{
name|FieldInfo
name|res
init|=
name|super
operator|.
name|fieldInfo
argument_list|(
name|fieldNumber
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|filteredNames
operator|.
name|contains
argument_list|(
name|res
operator|.
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The field named '"
operator|+
name|res
operator|.
name|name
operator|+
literal|"' numbered '"
operator|+
name|fieldNumber
operator|+
literal|"' is not "
operator|+
literal|"accessible in the current merge context, available ones are: "
operator|+
name|filteredNames
argument_list|)
throw|;
block|}
return|return
name|res
return|;
block|}
block|}
DECL|class|FilterFieldsProducer
specifier|private
specifier|static
class|class
name|FilterFieldsProducer
extends|extends
name|FieldsProducer
block|{
DECL|field|in
specifier|private
specifier|final
name|FieldsProducer
name|in
decl_stmt|;
DECL|field|filtered
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|filtered
decl_stmt|;
DECL|method|FilterFieldsProducer
name|FilterFieldsProducer
parameter_list|(
name|FieldsProducer
name|in
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|filterFields
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|filtered
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|filterFields
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
name|in
operator|.
name|ramBytesUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|filtered
operator|.
name|iterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|terms
specifier|public
name|Terms
name|terms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|filtered
operator|.
name|contains
argument_list|(
name|field
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The field named '"
operator|+
name|field
operator|+
literal|"' is not accessible in the current "
operator|+
literal|"merge context, available ones are: "
operator|+
name|filtered
argument_list|)
throw|;
block|}
return|return
name|in
operator|.
name|terms
argument_list|(
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|filtered
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|checkIntegrity
specifier|public
name|void
name|checkIntegrity
parameter_list|()
throws|throws
name|IOException
block|{
name|in
operator|.
name|checkIntegrity
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

