begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.analysis.miscellaneous
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|CharArraySet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|core
operator|.
name|WhitespaceTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|standard
operator|.
name|StandardTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|CharTermAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|OffsetAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionIncrementAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionLengthAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|TypeAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|PhraseQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|AttributeSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InPlaceMergeSorter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import

begin_comment
comment|/**  * Splits words into subwords and performs optional transformations on subword  * groups, producing a correct token graph so that e.g. {@link PhraseQuery} can  * work correctly when this filter is used in the search-time analyzer.  Unlike  * the deprecated {@link WordDelimiterFilter}, this token filter produces a  * correct token graph as output.  However, it cannot consume an input token  * graph correctly.  *  *<p>  * Words are split into subwords with the following rules:  *<ul>  *<li>split on intra-word delimiters (by default, all non alpha-numeric  * characters):<code>"Wi-Fi"</code>&#8594;<code>"Wi", "Fi"</code></li>  *<li>split on case transitions:<code>"PowerShot"</code>&#8594;  *<code>"Power", "Shot"</code></li>  *<li>split on letter-number transitions:<code>"SD500"</code>&#8594;  *<code>"SD", "500"</code></li>  *<li>leading and trailing intra-word delimiters on each subword are ignored:  *<code>"//hello---there, 'dude'"</code>&#8594;  *<code>"hello", "there", "dude"</code></li>  *<li>trailing "'s" are removed for each subword:<code>"O'Neil's"</code>  *&#8594;<code>"O", "Neil"</code>  *<ul>  *<li>Note: this step isn't performed in a separate filter because of possible  * subword combinations.</li>  *</ul>  *</li>  *</ul>  *   * The<b>combinations</b> parameter affects how subwords are combined:  *<ul>  *<li>combinations="0" causes no subword combinations:<code>"PowerShot"</code>  *&#8594;<code>0:"Power", 1:"Shot"</code> (0 and 1 are the token positions)</li>  *<li>combinations="1" means that in addition to the subwords, maximum runs of  * non-numeric subwords are catenated and produced at the same position of the  * last subword in the run:  *<ul>  *<li><code>"PowerShot"</code>&#8594;  *<code>0:"Power", 1:"Shot" 1:"PowerShot"</code></li>  *<li><code>"A's+B's&amp;C's"</code>&gt;<code>0:"A", 1:"B", 2:"C", 2:"ABC"</code>  *</li>  *<li><code>"Super-Duper-XL500-42-AutoCoder!"</code>&#8594;  *<code>0:"Super", 1:"Duper", 2:"XL", 2:"SuperDuperXL", 3:"500" 4:"42", 5:"Auto", 6:"Coder", 6:"AutoCoder"</code>  *</li>  *</ul>  *</li>  *</ul>  * One use for {@link WordDelimiterGraphFilter} is to help match words with different  * subword delimiters. For example, if the source text contained "wi-fi" one may  * want "wifi" "WiFi" "wi-fi" "wi+fi" queries to all match. One way of doing so  * is to specify combinations="1" in the analyzer used for indexing, and  * combinations="0" (the default) in the analyzer used for querying. Given that  * the current {@link StandardTokenizer} immediately removes many intra-word  * delimiters, it is recommended that this filter be used after a tokenizer that  * does not do this (such as {@link WhitespaceTokenizer}).  */
end_comment

begin_class
DECL|class|WordDelimiterGraphFilter
specifier|public
specifier|final
class|class
name|WordDelimiterGraphFilter
extends|extends
name|TokenFilter
block|{
comment|/**    * Causes parts of words to be generated:    *<p>    * "PowerShot" =&gt; "Power" "Shot"    */
DECL|field|GENERATE_WORD_PARTS
specifier|public
specifier|static
specifier|final
name|int
name|GENERATE_WORD_PARTS
init|=
literal|1
decl_stmt|;
comment|/**    * Causes number subwords to be generated:    *<p>    * "500-42" =&gt; "500" "42"    */
DECL|field|GENERATE_NUMBER_PARTS
specifier|public
specifier|static
specifier|final
name|int
name|GENERATE_NUMBER_PARTS
init|=
literal|2
decl_stmt|;
comment|/**    * Causes maximum runs of word parts to be catenated:    *<p>    * "wi-fi" =&gt; "wifi"    */
DECL|field|CATENATE_WORDS
specifier|public
specifier|static
specifier|final
name|int
name|CATENATE_WORDS
init|=
literal|4
decl_stmt|;
comment|/**    * Causes maximum runs of number parts to be catenated:    *<p>    * "500-42" =&gt; "50042"    */
DECL|field|CATENATE_NUMBERS
specifier|public
specifier|static
specifier|final
name|int
name|CATENATE_NUMBERS
init|=
literal|8
decl_stmt|;
comment|/**    * Causes all subword parts to be catenated:    *<p>    * "wi-fi-4000" =&gt; "wifi4000"    */
DECL|field|CATENATE_ALL
specifier|public
specifier|static
specifier|final
name|int
name|CATENATE_ALL
init|=
literal|16
decl_stmt|;
comment|/**    * Causes original words are preserved and added to the subword list (Defaults to false)    *<p>    * "500-42" =&gt; "500" "42" "500-42"    */
DECL|field|PRESERVE_ORIGINAL
specifier|public
specifier|static
specifier|final
name|int
name|PRESERVE_ORIGINAL
init|=
literal|32
decl_stmt|;
comment|/**    * Causes lowercase -&gt; uppercase transition to start a new subword.    */
DECL|field|SPLIT_ON_CASE_CHANGE
specifier|public
specifier|static
specifier|final
name|int
name|SPLIT_ON_CASE_CHANGE
init|=
literal|64
decl_stmt|;
comment|/**    * If not set, causes numeric changes to be ignored (subwords will only be generated    * given SUBWORD_DELIM tokens).    */
DECL|field|SPLIT_ON_NUMERICS
specifier|public
specifier|static
specifier|final
name|int
name|SPLIT_ON_NUMERICS
init|=
literal|128
decl_stmt|;
comment|/**    * Causes trailing "'s" to be removed for each subword    *<p>    * "O'Neil's" =&gt; "O", "Neil"    */
DECL|field|STEM_ENGLISH_POSSESSIVE
specifier|public
specifier|static
specifier|final
name|int
name|STEM_ENGLISH_POSSESSIVE
init|=
literal|256
decl_stmt|;
comment|/**    * If not null is the set of tokens to protect from being delimited    *    */
DECL|field|protWords
specifier|final
name|CharArraySet
name|protWords
decl_stmt|;
DECL|field|flags
specifier|private
specifier|final
name|int
name|flags
decl_stmt|;
comment|// packs start pos, end pos, start part, end part (= slice of the term text) for each buffered part:
DECL|field|bufferedParts
specifier|private
name|int
index|[]
name|bufferedParts
init|=
operator|new
name|int
index|[
literal|16
index|]
decl_stmt|;
DECL|field|bufferedLen
specifier|private
name|int
name|bufferedLen
decl_stmt|;
DECL|field|bufferedPos
specifier|private
name|int
name|bufferedPos
decl_stmt|;
comment|// holds text for each buffered part, or null if it's a simple slice of the original term
DECL|field|bufferedTermParts
specifier|private
name|char
index|[]
index|[]
name|bufferedTermParts
init|=
operator|new
name|char
index|[
literal|4
index|]
index|[]
decl_stmt|;
DECL|field|termAttribute
specifier|private
specifier|final
name|CharTermAttribute
name|termAttribute
init|=
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|offsetAttribute
specifier|private
specifier|final
name|OffsetAttribute
name|offsetAttribute
init|=
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|posIncAttribute
specifier|private
specifier|final
name|PositionIncrementAttribute
name|posIncAttribute
init|=
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|posLenAttribute
specifier|private
specifier|final
name|PositionLengthAttribute
name|posLenAttribute
init|=
name|addAttribute
argument_list|(
name|PositionLengthAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|typeAttribute
specifier|private
specifier|final
name|TypeAttribute
name|typeAttribute
init|=
name|addAttribute
argument_list|(
name|TypeAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// used for iterating word delimiter breaks
DECL|field|iterator
specifier|private
specifier|final
name|WordDelimiterIterator
name|iterator
decl_stmt|;
comment|// used for concatenating runs of similar typed subwords (word,number)
DECL|field|concat
specifier|private
specifier|final
name|WordDelimiterConcatenation
name|concat
init|=
operator|new
name|WordDelimiterConcatenation
argument_list|()
decl_stmt|;
comment|// number of subwords last output by concat.
DECL|field|lastConcatCount
specifier|private
name|int
name|lastConcatCount
decl_stmt|;
comment|// used for catenate all
DECL|field|concatAll
specifier|private
specifier|final
name|WordDelimiterConcatenation
name|concatAll
init|=
operator|new
name|WordDelimiterConcatenation
argument_list|()
decl_stmt|;
comment|// used for accumulating position increment gaps so that we preserve incoming holes:
DECL|field|accumPosInc
specifier|private
name|int
name|accumPosInc
decl_stmt|;
DECL|field|savedTermBuffer
specifier|private
name|char
index|[]
name|savedTermBuffer
init|=
operator|new
name|char
index|[
literal|16
index|]
decl_stmt|;
DECL|field|savedTermLength
specifier|private
name|int
name|savedTermLength
decl_stmt|;
DECL|field|savedStartOffset
specifier|private
name|int
name|savedStartOffset
decl_stmt|;
DECL|field|savedEndOffset
specifier|private
name|int
name|savedEndOffset
decl_stmt|;
DECL|field|savedState
specifier|private
name|AttributeSource
operator|.
name|State
name|savedState
decl_stmt|;
DECL|field|lastStartOffset
specifier|private
name|int
name|lastStartOffset
decl_stmt|;
comment|// if length by start + end offsets doesn't match the term text then assume
comment|// this is a synonym and don't adjust the offsets.
DECL|field|hasIllegalOffsets
specifier|private
name|boolean
name|hasIllegalOffsets
decl_stmt|;
DECL|field|wordPos
specifier|private
name|int
name|wordPos
decl_stmt|;
comment|/**    * Creates a new WordDelimiterGraphFilter    *    * @param in TokenStream to be filtered    * @param charTypeTable table containing character types    * @param configurationFlags Flags configuring the filter    * @param protWords If not null is the set of tokens to protect from being delimited    */
DECL|method|WordDelimiterGraphFilter
specifier|public
name|WordDelimiterGraphFilter
parameter_list|(
name|TokenStream
name|in
parameter_list|,
name|byte
index|[]
name|charTypeTable
parameter_list|,
name|int
name|configurationFlags
parameter_list|,
name|CharArraySet
name|protWords
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|configurationFlags
operator|&
operator|~
operator|(
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|CATENATE_WORDS
operator||
name|CATENATE_NUMBERS
operator||
name|CATENATE_ALL
operator||
name|PRESERVE_ORIGINAL
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
operator||
name|STEM_ENGLISH_POSSESSIVE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"flags contains unrecognized flag: "
operator|+
name|configurationFlags
argument_list|)
throw|;
block|}
name|this
operator|.
name|flags
operator|=
name|configurationFlags
expr_stmt|;
name|this
operator|.
name|protWords
operator|=
name|protWords
expr_stmt|;
name|this
operator|.
name|iterator
operator|=
operator|new
name|WordDelimiterIterator
argument_list|(
name|charTypeTable
argument_list|,
name|has
argument_list|(
name|SPLIT_ON_CASE_CHANGE
argument_list|)
argument_list|,
name|has
argument_list|(
name|SPLIT_ON_NUMERICS
argument_list|)
argument_list|,
name|has
argument_list|(
name|STEM_ENGLISH_POSSESSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new WordDelimiterGraphFilter using {@link WordDelimiterIterator#DEFAULT_WORD_DELIM_TABLE}    * as its charTypeTable    *    * @param in TokenStream to be filtered    * @param configurationFlags Flags configuring the filter    * @param protWords If not null is the set of tokens to protect from being delimited    */
DECL|method|WordDelimiterGraphFilter
specifier|public
name|WordDelimiterGraphFilter
parameter_list|(
name|TokenStream
name|in
parameter_list|,
name|int
name|configurationFlags
parameter_list|,
name|CharArraySet
name|protWords
parameter_list|)
block|{
name|this
argument_list|(
name|in
argument_list|,
name|WordDelimiterIterator
operator|.
name|DEFAULT_WORD_DELIM_TABLE
argument_list|,
name|configurationFlags
argument_list|,
name|protWords
argument_list|)
expr_stmt|;
block|}
comment|/** Iterates all words parts and concatenations, buffering up the term parts we should return. */
DECL|method|bufferWordParts
specifier|private
name|void
name|bufferWordParts
parameter_list|()
throws|throws
name|IOException
block|{
name|saveState
argument_list|()
expr_stmt|;
comment|// if length by start + end offsets doesn't match the term's text then set offsets for all our word parts/concats to the incoming
comment|// offsets.  this can happen if WDGF is applied to an injected synonym, or to a stem'd form, etc:
name|hasIllegalOffsets
operator|=
operator|(
name|savedEndOffset
operator|-
name|savedStartOffset
operator|!=
name|savedTermLength
operator|)
expr_stmt|;
name|bufferedLen
operator|=
literal|0
expr_stmt|;
name|lastConcatCount
operator|=
literal|0
expr_stmt|;
name|wordPos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iterator
operator|.
name|isSingleWord
argument_list|()
condition|)
block|{
name|buffer
argument_list|(
name|wordPos
argument_list|,
name|wordPos
operator|+
literal|1
argument_list|,
name|iterator
operator|.
name|current
argument_list|,
name|iterator
operator|.
name|end
argument_list|)
expr_stmt|;
name|wordPos
operator|++
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// iterate all words parts, possibly buffering them, building up concatenations and possibly buffering them too:
while|while
condition|(
name|iterator
operator|.
name|end
operator|!=
name|WordDelimiterIterator
operator|.
name|DONE
condition|)
block|{
name|int
name|wordType
init|=
name|iterator
operator|.
name|type
argument_list|()
decl_stmt|;
comment|// do we already have queued up incompatible concatenations?
if|if
condition|(
name|concat
operator|.
name|isNotEmpty
argument_list|()
operator|&&
operator|(
name|concat
operator|.
name|type
operator|&
name|wordType
operator|)
operator|==
literal|0
condition|)
block|{
name|flushConcatenation
argument_list|(
name|concat
argument_list|)
expr_stmt|;
block|}
comment|// add subwords depending upon options
if|if
condition|(
name|shouldConcatenate
argument_list|(
name|wordType
argument_list|)
condition|)
block|{
name|concatenate
argument_list|(
name|concat
argument_list|)
expr_stmt|;
block|}
comment|// add all subwords (catenateAll)
if|if
condition|(
name|has
argument_list|(
name|CATENATE_ALL
argument_list|)
condition|)
block|{
name|concatenate
argument_list|(
name|concatAll
argument_list|)
expr_stmt|;
block|}
comment|// if we should output the word or number part
if|if
condition|(
name|shouldGenerateParts
argument_list|(
name|wordType
argument_list|)
condition|)
block|{
name|buffer
argument_list|(
name|wordPos
argument_list|,
name|wordPos
operator|+
literal|1
argument_list|,
name|iterator
operator|.
name|current
argument_list|,
name|iterator
operator|.
name|end
argument_list|)
expr_stmt|;
name|wordPos
operator|++
expr_stmt|;
block|}
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|concat
operator|.
name|isNotEmpty
argument_list|()
condition|)
block|{
comment|// flush final concatenation
name|flushConcatenation
argument_list|(
name|concat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|concatAll
operator|.
name|isNotEmpty
argument_list|()
condition|)
block|{
comment|// only if we haven't output this same combo above, e.g. PowerShot with CATENATE_WORDS:
if|if
condition|(
name|concatAll
operator|.
name|subwordCount
operator|>
name|lastConcatCount
condition|)
block|{
if|if
condition|(
name|wordPos
operator|==
name|concatAll
operator|.
name|startPos
condition|)
block|{
comment|// we are not generating parts, so we must advance wordPos now
name|wordPos
operator|++
expr_stmt|;
block|}
name|concatAll
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
name|concatAll
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|has
argument_list|(
name|PRESERVE_ORIGINAL
argument_list|)
condition|)
block|{
if|if
condition|(
name|wordPos
operator|==
literal|0
condition|)
block|{
comment|// can happen w/ strange flag combos and inputs :)
name|wordPos
operator|++
expr_stmt|;
block|}
comment|// add the original token now so that we can set the correct end position
name|buffer
argument_list|(
literal|0
argument_list|,
name|wordPos
argument_list|,
literal|0
argument_list|,
name|savedTermLength
argument_list|)
expr_stmt|;
block|}
name|sorter
operator|.
name|sort
argument_list|(
literal|0
argument_list|,
name|bufferedLen
argument_list|)
expr_stmt|;
name|wordPos
operator|=
literal|0
expr_stmt|;
comment|// set back to 0 for iterating from the buffer
name|bufferedPos
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|incrementToken
specifier|public
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|savedState
operator|==
literal|null
condition|)
block|{
comment|// process a new input token
if|if
condition|(
name|input
operator|.
name|incrementToken
argument_list|()
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|termLength
init|=
name|termAttribute
operator|.
name|length
argument_list|()
decl_stmt|;
name|char
index|[]
name|termBuffer
init|=
name|termAttribute
operator|.
name|buffer
argument_list|()
decl_stmt|;
name|accumPosInc
operator|+=
name|posIncAttribute
operator|.
name|getPositionIncrement
argument_list|()
expr_stmt|;
comment|// iterate& cache all word parts up front:
name|iterator
operator|.
name|setText
argument_list|(
name|termBuffer
argument_list|,
name|termLength
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// word of no delimiters, or protected word: just return it
if|if
condition|(
operator|(
name|iterator
operator|.
name|current
operator|==
literal|0
operator|&&
name|iterator
operator|.
name|end
operator|==
name|termLength
operator|)
operator|||
operator|(
name|protWords
operator|!=
literal|null
operator|&&
name|protWords
operator|.
name|contains
argument_list|(
name|termBuffer
argument_list|,
literal|0
argument_list|,
name|termLength
argument_list|)
operator|)
condition|)
block|{
name|posIncAttribute
operator|.
name|setPositionIncrement
argument_list|(
name|accumPosInc
argument_list|)
expr_stmt|;
name|accumPosInc
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// word of simply delimiters: swallow this token, creating a hole, and move on to next token
if|if
condition|(
name|iterator
operator|.
name|end
operator|==
name|WordDelimiterIterator
operator|.
name|DONE
condition|)
block|{
if|if
condition|(
name|has
argument_list|(
name|PRESERVE_ORIGINAL
argument_list|)
operator|==
literal|false
condition|)
block|{
continue|continue;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// otherwise, we have delimiters, process& buffer all parts:
name|bufferWordParts
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bufferedPos
operator|<
name|bufferedLen
condition|)
block|{
name|clearAttributes
argument_list|()
expr_stmt|;
name|restoreState
argument_list|(
name|savedState
argument_list|)
expr_stmt|;
name|char
index|[]
name|termPart
init|=
name|bufferedTermParts
index|[
name|bufferedPos
index|]
decl_stmt|;
name|int
name|startPos
init|=
name|bufferedParts
index|[
literal|4
operator|*
name|bufferedPos
index|]
decl_stmt|;
name|int
name|endPos
init|=
name|bufferedParts
index|[
literal|4
operator|*
name|bufferedPos
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|startPart
init|=
name|bufferedParts
index|[
literal|4
operator|*
name|bufferedPos
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|endPart
init|=
name|bufferedParts
index|[
literal|4
operator|*
name|bufferedPos
operator|+
literal|3
index|]
decl_stmt|;
name|bufferedPos
operator|++
expr_stmt|;
name|int
name|startOffset
decl_stmt|;
name|int
name|endOffset
decl_stmt|;
if|if
condition|(
name|hasIllegalOffsets
condition|)
block|{
name|startOffset
operator|=
name|savedStartOffset
expr_stmt|;
name|endOffset
operator|=
name|savedEndOffset
expr_stmt|;
block|}
else|else
block|{
name|startOffset
operator|=
name|savedStartOffset
operator|+
name|startPart
expr_stmt|;
name|endOffset
operator|=
name|savedStartOffset
operator|+
name|endPart
expr_stmt|;
block|}
comment|// never let offsets go backwards:
name|startOffset
operator|=
name|Math
operator|.
name|max
argument_list|(
name|startOffset
argument_list|,
name|lastStartOffset
argument_list|)
expr_stmt|;
name|endOffset
operator|=
name|Math
operator|.
name|max
argument_list|(
name|endOffset
argument_list|,
name|lastStartOffset
argument_list|)
expr_stmt|;
name|offsetAttribute
operator|.
name|setOffset
argument_list|(
name|startOffset
argument_list|,
name|endOffset
argument_list|)
expr_stmt|;
name|lastStartOffset
operator|=
name|startOffset
expr_stmt|;
if|if
condition|(
name|termPart
operator|==
literal|null
condition|)
block|{
name|termAttribute
operator|.
name|copyBuffer
argument_list|(
name|savedTermBuffer
argument_list|,
name|startPart
argument_list|,
name|endPart
operator|-
name|startPart
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|termAttribute
operator|.
name|copyBuffer
argument_list|(
name|termPart
argument_list|,
literal|0
argument_list|,
name|termPart
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|posIncAttribute
operator|.
name|setPositionIncrement
argument_list|(
name|accumPosInc
operator|+
name|startPos
operator|-
name|wordPos
argument_list|)
expr_stmt|;
name|accumPosInc
operator|=
literal|0
expr_stmt|;
name|posLenAttribute
operator|.
name|setPositionLength
argument_list|(
name|endPos
operator|-
name|startPos
argument_list|)
expr_stmt|;
name|wordPos
operator|=
name|startPos
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// no saved concatenations, on to the next input word
name|savedState
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|accumPosInc
operator|=
literal|0
expr_stmt|;
name|savedState
operator|=
literal|null
expr_stmt|;
name|lastStartOffset
operator|=
literal|0
expr_stmt|;
name|concat
operator|.
name|clear
argument_list|()
expr_stmt|;
name|concatAll
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// ================================================= Helper Methods ================================================
DECL|class|PositionSorter
specifier|private
class|class
name|PositionSorter
extends|extends
name|InPlaceMergeSorter
block|{
annotation|@
name|Override
DECL|method|compare
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
comment|// sort by smaller start position
name|int
name|iPosStart
init|=
name|bufferedParts
index|[
literal|4
operator|*
name|i
index|]
decl_stmt|;
name|int
name|jPosStart
init|=
name|bufferedParts
index|[
literal|4
operator|*
name|j
index|]
decl_stmt|;
name|int
name|cmp
init|=
name|Integer
operator|.
name|compare
argument_list|(
name|iPosStart
argument_list|,
name|jPosStart
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
comment|// tie break by longest pos length:
name|int
name|iPosEnd
init|=
name|bufferedParts
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|jPosEnd
init|=
name|bufferedParts
index|[
literal|4
operator|*
name|j
operator|+
literal|1
index|]
decl_stmt|;
return|return
name|Integer
operator|.
name|compare
argument_list|(
name|jPosEnd
argument_list|,
name|iPosEnd
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|swap
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iOffset
init|=
literal|4
operator|*
name|i
decl_stmt|;
name|int
name|jOffset
init|=
literal|4
operator|*
name|j
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
name|int
name|tmp
init|=
name|bufferedParts
index|[
name|iOffset
operator|+
name|x
index|]
decl_stmt|;
name|bufferedParts
index|[
name|iOffset
operator|+
name|x
index|]
operator|=
name|bufferedParts
index|[
name|jOffset
operator|+
name|x
index|]
expr_stmt|;
name|bufferedParts
index|[
name|jOffset
operator|+
name|x
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|char
index|[]
name|tmp2
init|=
name|bufferedTermParts
index|[
name|i
index|]
decl_stmt|;
name|bufferedTermParts
index|[
name|i
index|]
operator|=
name|bufferedTermParts
index|[
name|j
index|]
expr_stmt|;
name|bufferedTermParts
index|[
name|j
index|]
operator|=
name|tmp2
expr_stmt|;
block|}
block|}
DECL|field|sorter
specifier|final
name|PositionSorter
name|sorter
init|=
operator|new
name|PositionSorter
argument_list|()
decl_stmt|;
comment|/**     * startPos, endPos -> graph start/end position    * startPart, endPart -> slice of the original term for this part    */
DECL|method|buffer
name|void
name|buffer
parameter_list|(
name|int
name|startPos
parameter_list|,
name|int
name|endPos
parameter_list|,
name|int
name|startPart
parameter_list|,
name|int
name|endPart
parameter_list|)
block|{
name|buffer
argument_list|(
literal|null
argument_list|,
name|startPos
argument_list|,
name|endPos
argument_list|,
name|startPart
argument_list|,
name|endPart
argument_list|)
expr_stmt|;
block|}
comment|/**     * a null termPart means it's a simple slice of the original term    */
DECL|method|buffer
name|void
name|buffer
parameter_list|(
name|char
index|[]
name|termPart
parameter_list|,
name|int
name|startPos
parameter_list|,
name|int
name|endPos
parameter_list|,
name|int
name|startPart
parameter_list|,
name|int
name|endPart
parameter_list|)
block|{
comment|/*     System.out.println("buffer: pos=" + startPos + "-" + endPos + " part=" + startPart + "-" + endPart);     if (termPart != null) {       System.out.println("  termIn=" + new String(termPart));     } else {       System.out.println("  term=" + new String(savedTermBuffer, startPart, endPart-startPart));     }     */
assert|assert
name|endPos
operator|>
name|startPos
operator|:
literal|"startPos="
operator|+
name|startPos
operator|+
literal|" endPos="
operator|+
name|endPos
assert|;
assert|assert
name|endPart
operator|>
name|startPart
operator|||
operator|(
name|endPart
operator|==
literal|0
operator|&&
name|startPart
operator|==
literal|0
operator|&&
name|savedTermLength
operator|==
literal|0
operator|)
operator|:
literal|"startPart="
operator|+
name|startPart
operator|+
literal|" endPart="
operator|+
name|endPart
assert|;
if|if
condition|(
operator|(
name|bufferedLen
operator|+
literal|1
operator|)
operator|*
literal|4
operator|>
name|bufferedParts
operator|.
name|length
condition|)
block|{
name|bufferedParts
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|bufferedParts
argument_list|,
operator|(
name|bufferedLen
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufferedTermParts
operator|.
name|length
operator|==
name|bufferedLen
condition|)
block|{
name|int
name|newSize
init|=
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|bufferedLen
operator|+
literal|1
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
decl_stmt|;
name|char
index|[]
index|[]
name|newArray
init|=
operator|new
name|char
index|[
name|newSize
index|]
index|[]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bufferedTermParts
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|bufferedTermParts
operator|.
name|length
argument_list|)
expr_stmt|;
name|bufferedTermParts
operator|=
name|newArray
expr_stmt|;
block|}
name|bufferedTermParts
index|[
name|bufferedLen
index|]
operator|=
name|termPart
expr_stmt|;
name|bufferedParts
index|[
name|bufferedLen
operator|*
literal|4
index|]
operator|=
name|startPos
expr_stmt|;
name|bufferedParts
index|[
name|bufferedLen
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
name|endPos
expr_stmt|;
name|bufferedParts
index|[
name|bufferedLen
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
name|startPart
expr_stmt|;
name|bufferedParts
index|[
name|bufferedLen
operator|*
literal|4
operator|+
literal|3
index|]
operator|=
name|endPart
expr_stmt|;
name|bufferedLen
operator|++
expr_stmt|;
block|}
comment|/**    * Saves the existing attribute states    */
DECL|method|saveState
specifier|private
name|void
name|saveState
parameter_list|()
block|{
name|savedTermLength
operator|=
name|termAttribute
operator|.
name|length
argument_list|()
expr_stmt|;
name|savedStartOffset
operator|=
name|offsetAttribute
operator|.
name|startOffset
argument_list|()
expr_stmt|;
name|savedEndOffset
operator|=
name|offsetAttribute
operator|.
name|endOffset
argument_list|()
expr_stmt|;
name|savedState
operator|=
name|captureState
argument_list|()
expr_stmt|;
if|if
condition|(
name|savedTermBuffer
operator|.
name|length
operator|<
name|savedTermLength
condition|)
block|{
name|savedTermBuffer
operator|=
operator|new
name|char
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|savedTermLength
argument_list|,
name|Character
operator|.
name|BYTES
argument_list|)
index|]
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|termAttribute
operator|.
name|buffer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|savedTermBuffer
argument_list|,
literal|0
argument_list|,
name|savedTermLength
argument_list|)
expr_stmt|;
block|}
comment|/**    * Flushes the given WordDelimiterConcatenation by either writing its concat and then clearing, or just clearing.    *    * @param concat WordDelimiterConcatenation that will be flushed    */
DECL|method|flushConcatenation
specifier|private
name|void
name|flushConcatenation
parameter_list|(
name|WordDelimiterConcatenation
name|concat
parameter_list|)
block|{
if|if
condition|(
name|wordPos
operator|==
name|concat
operator|.
name|startPos
condition|)
block|{
comment|// we are not generating parts, so we must advance wordPos now
name|wordPos
operator|++
expr_stmt|;
block|}
name|lastConcatCount
operator|=
name|concat
operator|.
name|subwordCount
expr_stmt|;
if|if
condition|(
name|concat
operator|.
name|subwordCount
operator|!=
literal|1
operator|||
name|shouldGenerateParts
argument_list|(
name|concat
operator|.
name|type
argument_list|)
operator|==
literal|false
condition|)
block|{
name|concat
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
name|concat
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Determines whether to concatenate a word or number if the current word is the given type    *    * @param wordType Type of the current word used to determine if it should be concatenated    * @return {@code true} if concatenation should occur, {@code false} otherwise    */
DECL|method|shouldConcatenate
specifier|private
name|boolean
name|shouldConcatenate
parameter_list|(
name|int
name|wordType
parameter_list|)
block|{
return|return
operator|(
name|has
argument_list|(
name|CATENATE_WORDS
argument_list|)
operator|&&
name|WordDelimiterIterator
operator|.
name|isAlpha
argument_list|(
name|wordType
argument_list|)
operator|)
operator|||
operator|(
name|has
argument_list|(
name|CATENATE_NUMBERS
argument_list|)
operator|&&
name|WordDelimiterIterator
operator|.
name|isDigit
argument_list|(
name|wordType
argument_list|)
operator|)
return|;
block|}
comment|/**    * Determines whether a word/number part should be generated for a word of the given type    *    * @param wordType Type of the word used to determine if a word/number part should be generated    * @return {@code true} if a word/number part should be generated, {@code false} otherwise    */
DECL|method|shouldGenerateParts
specifier|private
name|boolean
name|shouldGenerateParts
parameter_list|(
name|int
name|wordType
parameter_list|)
block|{
return|return
operator|(
name|has
argument_list|(
name|GENERATE_WORD_PARTS
argument_list|)
operator|&&
name|WordDelimiterIterator
operator|.
name|isAlpha
argument_list|(
name|wordType
argument_list|)
operator|)
operator|||
operator|(
name|has
argument_list|(
name|GENERATE_NUMBER_PARTS
argument_list|)
operator|&&
name|WordDelimiterIterator
operator|.
name|isDigit
argument_list|(
name|wordType
argument_list|)
operator|)
return|;
block|}
comment|/**    * Concatenates the saved buffer to the given WordDelimiterConcatenation    *    * @param concatenation WordDelimiterConcatenation to concatenate the buffer to    */
DECL|method|concatenate
specifier|private
name|void
name|concatenate
parameter_list|(
name|WordDelimiterConcatenation
name|concatenation
parameter_list|)
block|{
if|if
condition|(
name|concatenation
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|concatenation
operator|.
name|type
operator|=
name|iterator
operator|.
name|type
argument_list|()
expr_stmt|;
name|concatenation
operator|.
name|startPart
operator|=
name|iterator
operator|.
name|current
expr_stmt|;
name|concatenation
operator|.
name|startPos
operator|=
name|wordPos
expr_stmt|;
block|}
name|concatenation
operator|.
name|append
argument_list|(
name|savedTermBuffer
argument_list|,
name|iterator
operator|.
name|current
argument_list|,
name|iterator
operator|.
name|end
operator|-
name|iterator
operator|.
name|current
argument_list|)
expr_stmt|;
name|concatenation
operator|.
name|endPart
operator|=
name|iterator
operator|.
name|end
expr_stmt|;
block|}
comment|/**    * Determines whether the given flag is set    *    * @param flag Flag to see if set    * @return {@code true} if flag is set    */
DECL|method|has
specifier|private
name|boolean
name|has
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
return|return
operator|(
name|flags
operator|&
name|flag
operator|)
operator|!=
literal|0
return|;
block|}
comment|// ================================================= Inner Classes =================================================
comment|/**    * A WDF concatenated 'run'    */
DECL|class|WordDelimiterConcatenation
specifier|final
class|class
name|WordDelimiterConcatenation
block|{
DECL|field|buffer
specifier|final
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
DECL|field|startPart
name|int
name|startPart
decl_stmt|;
DECL|field|endPart
name|int
name|endPart
decl_stmt|;
DECL|field|startPos
name|int
name|startPos
decl_stmt|;
DECL|field|type
name|int
name|type
decl_stmt|;
DECL|field|subwordCount
name|int
name|subwordCount
decl_stmt|;
comment|/**      * Appends the given text of the given length, to the concetenation at the given offset      *      * @param text Text to append      * @param offset Offset in the concetenation to add the text      * @param length Length of the text to append      */
DECL|method|append
name|void
name|append
parameter_list|(
name|char
name|text
index|[]
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|text
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|subwordCount
operator|++
expr_stmt|;
block|}
comment|/**      * Writes the concatenation to part buffer      */
DECL|method|write
name|void
name|write
parameter_list|()
block|{
name|char
index|[]
name|termPart
init|=
operator|new
name|char
index|[
name|buffer
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
name|buffer
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|buffer
operator|.
name|length
argument_list|()
argument_list|,
name|termPart
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buffer
argument_list|(
name|termPart
argument_list|,
name|startPos
argument_list|,
name|wordPos
argument_list|,
name|startPart
argument_list|,
name|endPart
argument_list|)
expr_stmt|;
block|}
comment|/**      * Determines if the concatenation is empty      *      * @return {@code true} if the concatenation is empty, {@code false} otherwise      */
DECL|method|isEmpty
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|buffer
operator|.
name|length
argument_list|()
operator|==
literal|0
return|;
block|}
DECL|method|isNotEmpty
name|boolean
name|isNotEmpty
parameter_list|()
block|{
return|return
name|isEmpty
argument_list|()
operator|==
literal|false
return|;
block|}
comment|/**      * Clears the concatenation and resets its state      */
DECL|method|clear
name|void
name|clear
parameter_list|()
block|{
name|buffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|startPart
operator|=
name|endPart
operator|=
name|type
operator|=
name|subwordCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/** Returns string representation of configuration flags */
DECL|method|flagsToString
specifier|public
specifier|static
name|String
name|flagsToString
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|GENERATE_WORD_PARTS
operator|)
operator|!=
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"GENERATE_WORD_PARTS"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|GENERATE_NUMBER_PARTS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"GENERATE_NUMBER_PARTS"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|CATENATE_WORDS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"CATENATE_WORDS"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|CATENATE_NUMBERS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"CATENATE_NUMBERS"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|CATENATE_ALL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"CATENATE_ALL"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|PRESERVE_ORIGINAL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"PRESERVE_ORIGINAL"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|SPLIT_ON_CASE_CHANGE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"SPLIT_ON_CASE_CHANGE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|SPLIT_ON_NUMERICS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"SPLIT_ON_NUMERICS"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|STEM_ENGLISH_POSSESSIVE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"STEM_ENGLISH_POSSESSIVE"
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"WordDelimiterGraphFilter(flags="
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|flagsToString
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// questions:
comment|// negative numbers?  -42 indexed as just 42?
comment|// dollar sign?  $42
comment|// percent sign?  33%
comment|// downsides:  if source text is "powershot" then a query of "PowerShot" won't match!
block|}
end_class

end_unit

