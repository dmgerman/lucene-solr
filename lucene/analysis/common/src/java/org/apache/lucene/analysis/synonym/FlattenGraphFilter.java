begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.analysis.synonym
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|synonym
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|OffsetAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionIncrementAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionLengthAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|AttributeSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RollingBuffer
import|;
end_import

begin_comment
comment|/**  * Converts an incoming graph token stream, such as one from  * {@link SynonymGraphFilter}, into a flat form so that  * all nodes form a single linear chain with no side paths.  Every  * path through the graph touches every node.  This is necessary  * when indexing a graph token stream, because the index does not  * save {@link PositionLengthAttribute} and so it cannot  * preserve the graph structure.  However, at search time,  * query parsers can correctly handle the graph and this token  * filter should<b>not</b> be used.  *  *<p>If the graph was not already flat to start, this  * is likely a lossy process, i.e. it will often cause the   * graph to accept token sequences it should not, and to  * reject token sequences it should not.  *  *<p>However, when applying synonyms during indexing, this  * is necessary because Lucene already does not index a graph   * and so the indexing process is already lossy  * (it ignores the {@link PositionLengthAttribute}).  *  * @lucene.experimental  */
end_comment

begin_class
DECL|class|FlattenGraphFilter
specifier|public
specifier|final
class|class
name|FlattenGraphFilter
extends|extends
name|TokenFilter
block|{
comment|/** Holds all tokens leaving a given input position. */
DECL|class|InputNode
specifier|private
specifier|final
specifier|static
class|class
name|InputNode
implements|implements
name|RollingBuffer
operator|.
name|Resettable
block|{
DECL|field|tokens
specifier|private
specifier|final
name|List
argument_list|<
name|AttributeSource
operator|.
name|State
argument_list|>
name|tokens
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Our input node, or -1 if we haven't been assigned yet */
DECL|field|node
name|int
name|node
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Maximum to input node for all tokens leaving here; we use this      *  to know when we can freeze. */
DECL|field|maxToNode
name|int
name|maxToNode
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Where we currently map to; this changes (can only      *  increase as we see more input tokens), until we are finished      *  with this position. */
DECL|field|outputNode
name|int
name|outputNode
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Which token (index into {@link #tokens}) we will next output. */
DECL|field|nextOut
name|int
name|nextOut
decl_stmt|;
annotation|@
name|Override
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|tokens
operator|.
name|clear
argument_list|()
expr_stmt|;
name|node
operator|=
operator|-
literal|1
expr_stmt|;
name|outputNode
operator|=
operator|-
literal|1
expr_stmt|;
name|maxToNode
operator|=
operator|-
literal|1
expr_stmt|;
name|nextOut
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/** Gathers up merged input positions into a single output position,    *  only for the current "frontier" of nodes we've seen but can't yet    *  output because they are not frozen. */
DECL|class|OutputNode
specifier|private
specifier|final
specifier|static
class|class
name|OutputNode
implements|implements
name|RollingBuffer
operator|.
name|Resettable
block|{
DECL|field|inputNodes
specifier|private
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|inputNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Node ID for this output, or -1 if we haven't been assigned yet. */
DECL|field|node
name|int
name|node
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Which input node (index into {@link #inputNodes}) we will next output. */
DECL|field|nextOut
name|int
name|nextOut
decl_stmt|;
comment|/** Start offset of tokens leaving this node. */
DECL|field|startOffset
name|int
name|startOffset
init|=
operator|-
literal|1
decl_stmt|;
comment|/** End offset of tokens arriving to this node. */
DECL|field|endOffset
name|int
name|endOffset
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Override
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|inputNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|node
operator|=
operator|-
literal|1
expr_stmt|;
name|nextOut
operator|=
literal|0
expr_stmt|;
name|startOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|endOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
DECL|field|inputNodes
specifier|private
specifier|final
name|RollingBuffer
argument_list|<
name|InputNode
argument_list|>
name|inputNodes
init|=
operator|new
name|RollingBuffer
argument_list|<
name|InputNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|InputNode
name|newInstance
parameter_list|()
block|{
return|return
operator|new
name|InputNode
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|field|outputNodes
specifier|private
specifier|final
name|RollingBuffer
argument_list|<
name|OutputNode
argument_list|>
name|outputNodes
init|=
operator|new
name|RollingBuffer
argument_list|<
name|OutputNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|OutputNode
name|newInstance
parameter_list|()
block|{
return|return
operator|new
name|OutputNode
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|field|posIncAtt
specifier|private
specifier|final
name|PositionIncrementAttribute
name|posIncAtt
init|=
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|posLenAtt
specifier|private
specifier|final
name|PositionLengthAttribute
name|posLenAtt
init|=
name|addAttribute
argument_list|(
name|PositionLengthAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|offsetAtt
specifier|private
specifier|final
name|OffsetAttribute
name|offsetAtt
init|=
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Which input node the last seen token leaves from */
DECL|field|inputFrom
specifier|private
name|int
name|inputFrom
decl_stmt|;
comment|/** We are currently releasing tokens leaving from this output node */
DECL|field|outputFrom
specifier|private
name|int
name|outputFrom
decl_stmt|;
comment|// for debugging:
comment|//private int retOutputFrom;
DECL|field|done
specifier|private
name|boolean
name|done
decl_stmt|;
DECL|field|lastOutputFrom
specifier|private
name|int
name|lastOutputFrom
decl_stmt|;
DECL|field|finalOffset
specifier|private
name|int
name|finalOffset
decl_stmt|;
DECL|field|finalPosInc
specifier|private
name|int
name|finalPosInc
decl_stmt|;
DECL|field|maxLookaheadUsed
specifier|private
name|int
name|maxLookaheadUsed
decl_stmt|;
DECL|field|lastStartOffset
specifier|private
name|int
name|lastStartOffset
decl_stmt|;
DECL|method|FlattenGraphFilter
specifier|public
name|FlattenGraphFilter
parameter_list|(
name|TokenStream
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
DECL|method|releaseBufferedToken
specifier|private
name|boolean
name|releaseBufferedToken
parameter_list|()
block|{
comment|// We only need the while loop (retry) if we have a hole (an output node that has no tokens leaving):
while|while
condition|(
name|outputFrom
operator|<
name|outputNodes
operator|.
name|getMaxPos
argument_list|()
condition|)
block|{
name|OutputNode
name|output
init|=
name|outputNodes
operator|.
name|get
argument_list|(
name|outputFrom
argument_list|)
decl_stmt|;
if|if
condition|(
name|output
operator|.
name|inputNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No tokens arrived to this node, which happens for the first node
comment|// after a hole:
comment|//System.out.println("    skip empty outputFrom=" + outputFrom);
name|outputFrom
operator|++
expr_stmt|;
continue|continue;
block|}
name|int
name|maxToNode
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|inputNodeID
range|:
name|output
operator|.
name|inputNodes
control|)
block|{
name|InputNode
name|inputNode
init|=
name|inputNodes
operator|.
name|get
argument_list|(
name|inputNodeID
argument_list|)
decl_stmt|;
assert|assert
name|inputNode
operator|.
name|outputNode
operator|==
name|outputFrom
assert|;
name|maxToNode
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxToNode
argument_list|,
name|inputNode
operator|.
name|maxToNode
argument_list|)
expr_stmt|;
block|}
comment|//System.out.println("  release maxToNode=" + maxToNode + " vs inputFrom=" + inputFrom);
comment|// TODO: we could shrink the frontier here somewhat if we
comment|// always output posLen=1 as part of our "sausagizing":
if|if
condition|(
name|maxToNode
operator|<=
name|inputFrom
operator|||
name|done
condition|)
block|{
comment|//System.out.println("  output node merged these inputs: " + output.inputNodes);
comment|// These tokens are now frozen
assert|assert
name|output
operator|.
name|nextOut
operator|<
name|output
operator|.
name|inputNodes
operator|.
name|size
argument_list|()
operator|:
literal|"output.nextOut="
operator|+
name|output
operator|.
name|nextOut
operator|+
literal|" vs output.inputNodes.size()="
operator|+
name|output
operator|.
name|inputNodes
operator|.
name|size
argument_list|()
assert|;
name|InputNode
name|inputNode
init|=
name|inputNodes
operator|.
name|get
argument_list|(
name|output
operator|.
name|inputNodes
operator|.
name|get
argument_list|(
name|output
operator|.
name|nextOut
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|done
operator|&&
name|inputNode
operator|.
name|tokens
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|outputFrom
operator|>=
name|outputNodes
operator|.
name|getMaxPos
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|inputNode
operator|.
name|tokens
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
assert|assert
name|inputNode
operator|.
name|nextOut
operator|==
literal|0
assert|;
assert|assert
name|output
operator|.
name|nextOut
operator|==
literal|0
assert|;
comment|// Hole dest nodes should never be merged since 1) we always
comment|// assign them to a new output position, and 2) since they never
comment|// have arriving tokens they cannot be pushed:
assert|assert
name|output
operator|.
name|inputNodes
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|:
name|output
operator|.
name|inputNodes
operator|.
name|size
argument_list|()
assert|;
name|outputFrom
operator|++
expr_stmt|;
name|inputNodes
operator|.
name|freeBefore
argument_list|(
name|output
operator|.
name|inputNodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|outputNodes
operator|.
name|freeBefore
argument_list|(
name|outputFrom
argument_list|)
expr_stmt|;
continue|continue;
block|}
assert|assert
name|inputNode
operator|.
name|nextOut
operator|<
name|inputNode
operator|.
name|tokens
operator|.
name|size
argument_list|()
assert|;
name|restoreState
argument_list|(
name|inputNode
operator|.
name|tokens
operator|.
name|get
argument_list|(
name|inputNode
operator|.
name|nextOut
argument_list|)
argument_list|)
expr_stmt|;
comment|// Correct posInc
assert|assert
name|outputFrom
operator|>=
name|lastOutputFrom
assert|;
name|posIncAtt
operator|.
name|setPositionIncrement
argument_list|(
name|outputFrom
operator|-
name|lastOutputFrom
argument_list|)
expr_stmt|;
name|int
name|toInputNodeID
init|=
name|inputNode
operator|.
name|node
operator|+
name|posLenAtt
operator|.
name|getPositionLength
argument_list|()
decl_stmt|;
name|InputNode
name|toInputNode
init|=
name|inputNodes
operator|.
name|get
argument_list|(
name|toInputNodeID
argument_list|)
decl_stmt|;
comment|// Correct posLen
assert|assert
name|toInputNode
operator|.
name|outputNode
operator|>
name|outputFrom
assert|;
name|posLenAtt
operator|.
name|setPositionLength
argument_list|(
name|toInputNode
operator|.
name|outputNode
operator|-
name|outputFrom
argument_list|)
expr_stmt|;
name|lastOutputFrom
operator|=
name|outputFrom
expr_stmt|;
name|inputNode
operator|.
name|nextOut
operator|++
expr_stmt|;
comment|//System.out.println("  ret " + this);
name|OutputNode
name|outputEndNode
init|=
name|outputNodes
operator|.
name|get
argument_list|(
name|toInputNode
operator|.
name|outputNode
argument_list|)
decl_stmt|;
comment|// Correct offsets
comment|// This is a bit messy; we must do this so offset don't go backwards,
comment|// which would otherwise happen if the replacement has more tokens
comment|// than the input:
name|int
name|startOffset
init|=
name|Math
operator|.
name|max
argument_list|(
name|lastStartOffset
argument_list|,
name|output
operator|.
name|startOffset
argument_list|)
decl_stmt|;
comment|// We must do this in case the incoming tokens have broken offsets:
name|int
name|endOffset
init|=
name|Math
operator|.
name|max
argument_list|(
name|startOffset
argument_list|,
name|outputEndNode
operator|.
name|endOffset
argument_list|)
decl_stmt|;
name|offsetAtt
operator|.
name|setOffset
argument_list|(
name|startOffset
argument_list|,
name|endOffset
argument_list|)
expr_stmt|;
name|lastStartOffset
operator|=
name|startOffset
expr_stmt|;
if|if
condition|(
name|inputNode
operator|.
name|nextOut
operator|==
name|inputNode
operator|.
name|tokens
operator|.
name|size
argument_list|()
condition|)
block|{
name|output
operator|.
name|nextOut
operator|++
expr_stmt|;
if|if
condition|(
name|output
operator|.
name|nextOut
operator|==
name|output
operator|.
name|inputNodes
operator|.
name|size
argument_list|()
condition|)
block|{
name|outputFrom
operator|++
expr_stmt|;
name|inputNodes
operator|.
name|freeBefore
argument_list|(
name|output
operator|.
name|inputNodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|outputNodes
operator|.
name|freeBefore
argument_list|(
name|outputFrom
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|//System.out.println("    break false");
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|incrementToken
specifier|public
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("\nF.increment inputFrom=" + inputFrom + " outputFrom=" + outputFrom);
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|releaseBufferedToken
argument_list|()
condition|)
block|{
comment|//retOutputFrom += posIncAtt.getPositionIncrement();
comment|//System.out.println("    return buffered: " + termAtt + " " + retOutputFrom + "-" + (retOutputFrom + posLenAtt.getPositionLength()));
comment|//printStates();
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|done
condition|)
block|{
comment|//System.out.println("    done, return false");
return|return
literal|false
return|;
block|}
if|if
condition|(
name|input
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
comment|// Input node this token leaves from:
name|inputFrom
operator|+=
name|posIncAtt
operator|.
name|getPositionIncrement
argument_list|()
expr_stmt|;
name|int
name|startOffset
init|=
name|offsetAtt
operator|.
name|startOffset
argument_list|()
decl_stmt|;
name|int
name|endOffset
init|=
name|offsetAtt
operator|.
name|endOffset
argument_list|()
decl_stmt|;
comment|// Input node this token goes to:
name|int
name|inputTo
init|=
name|inputFrom
operator|+
name|posLenAtt
operator|.
name|getPositionLength
argument_list|()
decl_stmt|;
comment|//System.out.println("  input.inc " + termAtt + ": " + inputFrom + "-" + inputTo);
name|InputNode
name|src
init|=
name|inputNodes
operator|.
name|get
argument_list|(
name|inputFrom
argument_list|)
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|node
operator|==
operator|-
literal|1
condition|)
block|{
comment|// This means the "from" node of this token was never seen as a "to" node,
comment|// which should only happen if we just crossed a hole.  This is a challenging
comment|// case for us because we normally rely on the full dependencies expressed
comment|// by the arcs to assign outgoing node IDs.  It would be better if tokens
comment|// were never dropped but instead just marked deleted with a new
comment|// TermDeletedAttribute (boolean valued) ... but until that future, we have
comment|// a hack here to forcefully jump the output node ID:
assert|assert
name|src
operator|.
name|outputNode
operator|==
operator|-
literal|1
assert|;
name|src
operator|.
name|node
operator|=
name|inputFrom
expr_stmt|;
name|src
operator|.
name|outputNode
operator|=
name|outputNodes
operator|.
name|getMaxPos
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|//System.out.println("    hole: force to outputNode=" + src.outputNode);
name|OutputNode
name|outSrc
init|=
name|outputNodes
operator|.
name|get
argument_list|(
name|src
operator|.
name|outputNode
argument_list|)
decl_stmt|;
comment|// Not assigned yet:
assert|assert
name|outSrc
operator|.
name|node
operator|==
operator|-
literal|1
assert|;
name|outSrc
operator|.
name|node
operator|=
name|src
operator|.
name|outputNode
expr_stmt|;
name|outSrc
operator|.
name|inputNodes
operator|.
name|add
argument_list|(
name|inputFrom
argument_list|)
expr_stmt|;
name|outSrc
operator|.
name|startOffset
operator|=
name|startOffset
expr_stmt|;
block|}
else|else
block|{
name|OutputNode
name|outSrc
init|=
name|outputNodes
operator|.
name|get
argument_list|(
name|src
operator|.
name|outputNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|outSrc
operator|.
name|startOffset
operator|==
operator|-
literal|1
operator|||
name|startOffset
operator|>
name|outSrc
operator|.
name|startOffset
condition|)
block|{
comment|// "shrink wrap" the offsets so the original tokens (with most
comment|// restrictive offsets) win:
name|outSrc
operator|.
name|startOffset
operator|=
name|Math
operator|.
name|max
argument_list|(
name|startOffset
argument_list|,
name|outSrc
operator|.
name|startOffset
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Buffer this token:
name|src
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|captureState
argument_list|()
argument_list|)
expr_stmt|;
name|src
operator|.
name|maxToNode
operator|=
name|Math
operator|.
name|max
argument_list|(
name|src
operator|.
name|maxToNode
argument_list|,
name|inputTo
argument_list|)
expr_stmt|;
name|maxLookaheadUsed
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxLookaheadUsed
argument_list|,
name|inputNodes
operator|.
name|getBufferSize
argument_list|()
argument_list|)
expr_stmt|;
name|InputNode
name|dest
init|=
name|inputNodes
operator|.
name|get
argument_list|(
name|inputTo
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|.
name|node
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Common case: first time a token is arriving to this input position:
name|dest
operator|.
name|node
operator|=
name|inputTo
expr_stmt|;
block|}
comment|// Always number output nodes sequentially:
name|int
name|outputEndNode
init|=
name|src
operator|.
name|outputNode
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|outputEndNode
operator|>
name|dest
operator|.
name|outputNode
condition|)
block|{
if|if
condition|(
name|dest
operator|.
name|outputNode
operator|!=
operator|-
literal|1
condition|)
block|{
name|boolean
name|removed
init|=
name|outputNodes
operator|.
name|get
argument_list|(
name|dest
operator|.
name|outputNode
argument_list|)
operator|.
name|inputNodes
operator|.
name|remove
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|inputTo
argument_list|)
argument_list|)
decl_stmt|;
assert|assert
name|removed
assert|;
block|}
comment|//System.out.println("    increase output node: " + dest.outputNode + " vs " + outputEndNode);
name|outputNodes
operator|.
name|get
argument_list|(
name|outputEndNode
argument_list|)
operator|.
name|inputNodes
operator|.
name|add
argument_list|(
name|inputTo
argument_list|)
expr_stmt|;
name|dest
operator|.
name|outputNode
operator|=
name|outputEndNode
expr_stmt|;
comment|// Since all we ever do is merge incoming nodes together, and then renumber
comment|// the merged nodes sequentially, we should only ever assign smaller node
comment|// numbers:
assert|assert
name|outputEndNode
operator|<=
name|inputTo
operator|:
literal|"outputEndNode="
operator|+
name|outputEndNode
operator|+
literal|" vs inputTo="
operator|+
name|inputTo
assert|;
block|}
name|OutputNode
name|outDest
init|=
name|outputNodes
operator|.
name|get
argument_list|(
name|dest
operator|.
name|outputNode
argument_list|)
decl_stmt|;
comment|// "shrink wrap" the offsets so the original tokens (with most
comment|// restrictive offsets) win:
if|if
condition|(
name|outDest
operator|.
name|endOffset
operator|==
operator|-
literal|1
operator|||
name|endOffset
operator|<
name|outDest
operator|.
name|endOffset
condition|)
block|{
name|outDest
operator|.
name|endOffset
operator|=
name|endOffset
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//System.out.println("  got false from input");
name|input
operator|.
name|end
argument_list|()
expr_stmt|;
name|finalPosInc
operator|=
name|posIncAtt
operator|.
name|getPositionIncrement
argument_list|()
expr_stmt|;
name|finalOffset
operator|=
name|offsetAtt
operator|.
name|endOffset
argument_list|()
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
comment|// Don't return false here: we need to force release any buffered tokens now
block|}
block|}
block|}
comment|// Only for debugging:
comment|/*   private void printStates() {     System.out.println("states:");     for(int i=outputFrom;i<outputNodes.getMaxPos();i++) {       OutputNode outputNode = outputNodes.get(i);       System.out.println("  output " + i + ": inputs " + outputNode.inputNodes);       for(int inputNodeID : outputNode.inputNodes) {         InputNode inputNode = inputNodes.get(inputNodeID);         assert inputNode.outputNode == i;       }     }   }   */
annotation|@
name|Override
DECL|method|end
specifier|public
name|void
name|end
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|done
operator|==
literal|false
condition|)
block|{
name|super
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// NOTE, shady: don't call super.end, because we did already from incrementToken
block|}
name|clearAttributes
argument_list|()
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
comment|// On exc, done is false, and we will not have set these:
name|posIncAtt
operator|.
name|setPositionIncrement
argument_list|(
name|finalPosInc
argument_list|)
expr_stmt|;
name|offsetAtt
operator|.
name|setOffset
argument_list|(
name|finalOffset
argument_list|,
name|finalOffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|super
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("F: reset");
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|inputFrom
operator|=
operator|-
literal|1
expr_stmt|;
name|inputNodes
operator|.
name|reset
argument_list|()
expr_stmt|;
name|InputNode
name|in
init|=
name|inputNodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|in
operator|.
name|node
operator|=
literal|0
expr_stmt|;
name|in
operator|.
name|outputNode
operator|=
literal|0
expr_stmt|;
name|outputNodes
operator|.
name|reset
argument_list|()
expr_stmt|;
name|OutputNode
name|out
init|=
name|outputNodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|out
operator|.
name|node
operator|=
literal|0
expr_stmt|;
name|out
operator|.
name|inputNodes
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|out
operator|.
name|startOffset
operator|=
literal|0
expr_stmt|;
name|outputFrom
operator|=
literal|0
expr_stmt|;
comment|//retOutputFrom = -1;
name|lastOutputFrom
operator|=
operator|-
literal|1
expr_stmt|;
name|done
operator|=
literal|false
expr_stmt|;
name|finalPosInc
operator|=
operator|-
literal|1
expr_stmt|;
name|finalOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|lastStartOffset
operator|=
literal|0
expr_stmt|;
name|maxLookaheadUsed
operator|=
literal|0
expr_stmt|;
block|}
comment|// for testing
DECL|method|getMaxLookaheadUsed
name|int
name|getMaxLookaheadUsed
parameter_list|()
block|{
return|return
name|maxLookaheadUsed
return|;
block|}
block|}
end_class

end_unit

