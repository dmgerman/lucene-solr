begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.analysis.miscellaneous
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|CharArraySet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|StopFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|core
operator|.
name|KeywordTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|standard
operator|.
name|StandardAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|CharTermAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionIncrementAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
operator|.
name|WordDelimiterGraphFilter
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
operator|.
name|WordDelimiterIterator
operator|.
name|DEFAULT_WORD_DELIM_TABLE
import|;
end_import

begin_comment
comment|/**  * New WordDelimiterGraphFilter tests... most of the tests are in ConvertedLegacyTest  * TODO: should explicitly test things like protWords and not rely on  * the factory tests in Solr.  */
end_comment

begin_class
DECL|class|TestWordDelimiterGraphFilter
specifier|public
class|class
name|TestWordDelimiterGraphFilter
extends|extends
name|BaseTokenStreamTestCase
block|{
DECL|method|testOffsets
specifier|public
name|void
name|testOffsets
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|flags
init|=
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|CATENATE_ALL
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
operator||
name|STEM_ENGLISH_POSSESSIVE
decl_stmt|;
comment|// test that subwords and catenated subwords have
comment|// the correct offsets.
name|WordDelimiterGraphFilter
name|wdf
init|=
operator|new
name|WordDelimiterGraphFilter
argument_list|(
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
argument_list|(
literal|"foo-bar"
argument_list|,
literal|5
argument_list|,
literal|12
argument_list|)
argument_list|)
argument_list|,
name|DEFAULT_WORD_DELIM_TABLE
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTokenStreamContents
argument_list|(
name|wdf
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"foobar"
block|,
literal|"foo"
block|,
literal|"bar"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|5
block|,
literal|5
block|,
literal|9
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|12
block|,
literal|8
block|,
literal|12
block|}
argument_list|)
expr_stmt|;
comment|// with illegal offsets:
name|wdf
operator|=
operator|new
name|WordDelimiterGraphFilter
argument_list|(
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
argument_list|(
literal|"foo-bar"
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
argument_list|)
argument_list|,
name|DEFAULT_WORD_DELIM_TABLE
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertTokenStreamContents
argument_list|(
name|wdf
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"foobar"
block|,
literal|"foo"
block|,
literal|"bar"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|5
block|,
literal|5
block|,
literal|5
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|6
block|,
literal|6
block|,
literal|6
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testOffsetChange
specifier|public
name|void
name|testOffsetChange
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|flags
init|=
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|CATENATE_ALL
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
operator||
name|STEM_ENGLISH_POSSESSIVE
decl_stmt|;
name|WordDelimiterGraphFilter
name|wdf
init|=
operator|new
name|WordDelimiterGraphFilter
argument_list|(
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
argument_list|(
literal|"Ã¼belkeit)"
argument_list|,
literal|7
argument_list|,
literal|16
argument_list|)
argument_list|)
argument_list|,
name|DEFAULT_WORD_DELIM_TABLE
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTokenStreamContents
argument_list|(
name|wdf
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"Ã¼belkeit"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|7
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|15
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testOffsetChange2
specifier|public
name|void
name|testOffsetChange2
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|flags
init|=
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|CATENATE_ALL
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
operator||
name|STEM_ENGLISH_POSSESSIVE
decl_stmt|;
name|WordDelimiterGraphFilter
name|wdf
init|=
operator|new
name|WordDelimiterGraphFilter
argument_list|(
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
argument_list|(
literal|"(Ã¼belkeit"
argument_list|,
literal|7
argument_list|,
literal|17
argument_list|)
argument_list|)
argument_list|,
name|DEFAULT_WORD_DELIM_TABLE
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// illegal offsets:
name|assertTokenStreamContents
argument_list|(
name|wdf
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"Ã¼belkeit"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|7
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|17
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testOffsetChange3
specifier|public
name|void
name|testOffsetChange3
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|flags
init|=
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|CATENATE_ALL
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
operator||
name|STEM_ENGLISH_POSSESSIVE
decl_stmt|;
name|WordDelimiterGraphFilter
name|wdf
init|=
operator|new
name|WordDelimiterGraphFilter
argument_list|(
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
argument_list|(
literal|"(Ã¼belkeit"
argument_list|,
literal|7
argument_list|,
literal|16
argument_list|)
argument_list|)
argument_list|,
name|DEFAULT_WORD_DELIM_TABLE
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTokenStreamContents
argument_list|(
name|wdf
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"Ã¼belkeit"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|8
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|16
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testOffsetChange4
specifier|public
name|void
name|testOffsetChange4
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|flags
init|=
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|CATENATE_ALL
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
operator||
name|STEM_ENGLISH_POSSESSIVE
decl_stmt|;
name|WordDelimiterGraphFilter
name|wdf
init|=
operator|new
name|WordDelimiterGraphFilter
argument_list|(
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
argument_list|(
literal|"(foo,bar)"
argument_list|,
literal|7
argument_list|,
literal|16
argument_list|)
argument_list|)
argument_list|,
name|DEFAULT_WORD_DELIM_TABLE
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTokenStreamContents
argument_list|(
name|wdf
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"foobar"
block|,
literal|"foo"
block|,
literal|"bar"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|8
block|,
literal|8
block|,
literal|12
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|15
block|,
literal|11
block|,
literal|15
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|doSplit
specifier|public
name|void
name|doSplit
parameter_list|(
specifier|final
name|String
name|input
parameter_list|,
name|String
modifier|...
name|output
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|flags
init|=
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
operator||
name|STEM_ENGLISH_POSSESSIVE
decl_stmt|;
name|WordDelimiterGraphFilter
name|wdf
init|=
operator|new
name|WordDelimiterGraphFilter
argument_list|(
name|keywordMockTokenizer
argument_list|(
name|input
argument_list|)
argument_list|,
name|WordDelimiterIterator
operator|.
name|DEFAULT_WORD_DELIM_TABLE
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTokenStreamContents
argument_list|(
name|wdf
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
DECL|method|testSplits
specifier|public
name|void
name|testSplits
parameter_list|()
throws|throws
name|Exception
block|{
name|doSplit
argument_list|(
literal|"basic-split"
argument_list|,
literal|"basic"
argument_list|,
literal|"split"
argument_list|)
expr_stmt|;
name|doSplit
argument_list|(
literal|"camelCase"
argument_list|,
literal|"camel"
argument_list|,
literal|"Case"
argument_list|)
expr_stmt|;
comment|// non-space marking symbol shouldn't cause split
comment|// this is an example in Thai
name|doSplit
argument_list|(
literal|"\u0e1a\u0e49\u0e32\u0e19"
argument_list|,
literal|"\u0e1a\u0e49\u0e32\u0e19"
argument_list|)
expr_stmt|;
comment|// possessive followed by delimiter
name|doSplit
argument_list|(
literal|"test's'"
argument_list|,
literal|"test"
argument_list|)
expr_stmt|;
comment|// some russian upper and lowercase
name|doSplit
argument_list|(
literal|"Ð Ð¾Ð±ÐµÑÑ"
argument_list|,
literal|"Ð Ð¾Ð±ÐµÑÑ"
argument_list|)
expr_stmt|;
comment|// now cause a split (russian camelCase)
name|doSplit
argument_list|(
literal|"Ð Ð¾Ð±ÐÑÑ"
argument_list|,
literal|"Ð Ð¾Ð±"
argument_list|,
literal|"ÐÑÑ"
argument_list|)
expr_stmt|;
comment|// a composed titlecase character, don't split
name|doSplit
argument_list|(
literal|"aÇungla"
argument_list|,
literal|"aÇungla"
argument_list|)
expr_stmt|;
comment|// a modifier letter, don't split
name|doSplit
argument_list|(
literal|"Ø³ÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙØ§Ù"
argument_list|,
literal|"Ø³ÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙØ§Ù"
argument_list|)
expr_stmt|;
comment|// enclosing mark, don't split
name|doSplit
argument_list|(
literal|"testâ"
argument_list|,
literal|"testâ"
argument_list|)
expr_stmt|;
comment|// combining spacing mark (the virama), don't split
name|doSplit
argument_list|(
literal|"à¤¹à¤¿à¤¨à¥à¤¦à¥"
argument_list|,
literal|"à¤¹à¤¿à¤¨à¥à¤¦à¥"
argument_list|)
expr_stmt|;
comment|// don't split non-ascii digits
name|doSplit
argument_list|(
literal|"Ù¡Ù¢Ù£Ù¤"
argument_list|,
literal|"Ù¡Ù¢Ù£Ù¤"
argument_list|)
expr_stmt|;
comment|// don't split supplementaries into unpaired surrogates
name|doSplit
argument_list|(
literal|"ð ð "
argument_list|,
literal|"ð ð "
argument_list|)
expr_stmt|;
block|}
DECL|method|doSplitPossessive
specifier|public
name|void
name|doSplitPossessive
parameter_list|(
name|int
name|stemPossessive
parameter_list|,
specifier|final
name|String
name|input
parameter_list|,
specifier|final
name|String
modifier|...
name|output
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|flags
init|=
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
decl_stmt|;
name|flags
operator||=
operator|(
name|stemPossessive
operator|==
literal|1
operator|)
condition|?
name|STEM_ENGLISH_POSSESSIVE
else|:
literal|0
expr_stmt|;
name|WordDelimiterGraphFilter
name|wdf
init|=
operator|new
name|WordDelimiterGraphFilter
argument_list|(
name|keywordMockTokenizer
argument_list|(
name|input
argument_list|)
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTokenStreamContents
argument_list|(
name|wdf
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
comment|/*    * Test option that allows disabling the special "'s" stemming, instead treating the single quote like other delimiters.     */
DECL|method|testPossessives
specifier|public
name|void
name|testPossessives
parameter_list|()
throws|throws
name|Exception
block|{
name|doSplitPossessive
argument_list|(
literal|1
argument_list|,
literal|"ra's"
argument_list|,
literal|"ra"
argument_list|)
expr_stmt|;
name|doSplitPossessive
argument_list|(
literal|0
argument_list|,
literal|"ra's"
argument_list|,
literal|"ra"
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
block|}
DECL|method|testTokenType
specifier|public
name|void
name|testTokenType
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|flags
init|=
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|CATENATE_ALL
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
operator||
name|STEM_ENGLISH_POSSESSIVE
decl_stmt|;
comment|// test that subwords and catenated subwords have
comment|// the correct offsets.
name|Token
name|token
init|=
operator|new
name|Token
argument_list|(
literal|"foo-bar"
argument_list|,
literal|5
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|token
operator|.
name|setType
argument_list|(
literal|"mytype"
argument_list|)
expr_stmt|;
name|WordDelimiterGraphFilter
name|wdf
init|=
operator|new
name|WordDelimiterGraphFilter
argument_list|(
operator|new
name|CannedTokenStream
argument_list|(
name|token
argument_list|)
argument_list|,
name|DEFAULT_WORD_DELIM_TABLE
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTokenStreamContents
argument_list|(
name|wdf
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"foobar"
block|,
literal|"foo"
block|,
literal|"bar"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"mytype"
block|,
literal|"mytype"
block|,
literal|"mytype"
block|}
argument_list|)
expr_stmt|;
block|}
comment|/*    * Set a large position increment gap of 10 if the token is "largegap" or "/"    */
DECL|class|LargePosIncTokenFilter
specifier|private
specifier|final
class|class
name|LargePosIncTokenFilter
extends|extends
name|TokenFilter
block|{
DECL|field|termAtt
specifier|private
name|CharTermAttribute
name|termAtt
init|=
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|posIncAtt
specifier|private
name|PositionIncrementAttribute
name|posIncAtt
init|=
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|LargePosIncTokenFilter
specifier|protected
name|LargePosIncTokenFilter
parameter_list|(
name|TokenStream
name|input
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|incrementToken
specifier|public
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|input
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
if|if
condition|(
name|termAtt
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
literal|"largegap"
argument_list|)
operator|||
name|termAtt
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
literal|"/"
argument_list|)
condition|)
name|posIncAtt
operator|.
name|setPositionIncrement
argument_list|(
literal|10
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
DECL|method|testPositionIncrements
specifier|public
name|void
name|testPositionIncrements
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|flags
init|=
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|CATENATE_ALL
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
operator||
name|STEM_ENGLISH_POSSESSIVE
decl_stmt|;
specifier|final
name|CharArraySet
name|protWords
init|=
operator|new
name|CharArraySet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"NUTCH"
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/* analyzer that uses whitespace + wdf */
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|field
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|WordDelimiterGraphFilter
argument_list|(
name|tokenizer
argument_list|,
name|flags
argument_list|,
name|protWords
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/* in this case, works as expected. */
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"LUCENE / SOLR"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"LUCENE"
block|,
literal|"SOLR"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|9
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|6
block|,
literal|13
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|}
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|/* only in this case, posInc of 2 ?! */
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"LUCENE / solR"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"LUCENE"
block|,
literal|"solR"
block|,
literal|"sol"
block|,
literal|"R"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|9
block|,
literal|9
block|,
literal|12
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|6
block|,
literal|13
block|,
literal|12
block|,
literal|13
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"LUCENE / NUTCH SOLR"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"LUCENE"
block|,
literal|"NUTCH"
block|,
literal|"SOLR"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|9
block|,
literal|15
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|6
block|,
literal|14
block|,
literal|19
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|1
block|}
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|/* analyzer that will consume tokens with large position increments */
name|Analyzer
name|a2
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|field
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|WordDelimiterGraphFilter
argument_list|(
operator|new
name|LargePosIncTokenFilter
argument_list|(
name|tokenizer
argument_list|)
argument_list|,
name|flags
argument_list|,
name|protWords
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/* increment of "largegap" is preserved */
name|assertAnalyzesTo
argument_list|(
name|a2
argument_list|,
literal|"LUCENE largegap SOLR"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"LUCENE"
block|,
literal|"largegap"
block|,
literal|"SOLR"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|7
block|,
literal|16
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|6
block|,
literal|15
block|,
literal|20
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|10
block|,
literal|1
block|}
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|/* the "/" had a position increment of 10, where did it go?!?!! */
name|assertAnalyzesTo
argument_list|(
name|a2
argument_list|,
literal|"LUCENE / SOLR"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"LUCENE"
block|,
literal|"SOLR"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|9
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|6
block|,
literal|13
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|11
block|}
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|/* in this case, the increment of 10 from the "/" is carried over */
name|assertAnalyzesTo
argument_list|(
name|a2
argument_list|,
literal|"LUCENE / solR"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"LUCENE"
block|,
literal|"solR"
block|,
literal|"sol"
block|,
literal|"R"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|9
block|,
literal|9
block|,
literal|12
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|6
block|,
literal|13
block|,
literal|12
block|,
literal|13
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|11
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a2
argument_list|,
literal|"LUCENE / NUTCH SOLR"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"LUCENE"
block|,
literal|"NUTCH"
block|,
literal|"SOLR"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|9
block|,
literal|15
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|6
block|,
literal|14
block|,
literal|19
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|11
block|,
literal|1
block|}
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Analyzer
name|a3
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|field
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|StopFilter
name|filter
init|=
operator|new
name|StopFilter
argument_list|(
name|tokenizer
argument_list|,
name|StandardAnalyzer
operator|.
name|STOP_WORDS_SET
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|WordDelimiterGraphFilter
argument_list|(
name|filter
argument_list|,
name|flags
argument_list|,
name|protWords
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a3
argument_list|,
literal|"lucene.solr"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"lucenesolr"
block|,
literal|"lucene"
block|,
literal|"solr"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|7
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|11
block|,
literal|6
block|,
literal|11
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|/* the stopword should add a gap here */
name|assertAnalyzesTo
argument_list|(
name|a3
argument_list|,
literal|"the lucene.solr"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"lucenesolr"
block|,
literal|"lucene"
block|,
literal|"solr"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|4
block|,
literal|4
block|,
literal|11
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|15
block|,
literal|10
block|,
literal|15
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|2
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|close
argument_list|(
name|a
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
block|}
comment|/** concat numbers + words + all */
DECL|method|testLotsOfConcatenating
specifier|public
name|void
name|testLotsOfConcatenating
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|flags
init|=
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|CATENATE_WORDS
operator||
name|CATENATE_NUMBERS
operator||
name|CATENATE_ALL
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
operator||
name|STEM_ENGLISH_POSSESSIVE
decl_stmt|;
comment|/* analyzer that uses whitespace + wdf */
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|field
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|WordDelimiterGraphFilter
argument_list|(
name|tokenizer
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"abc-def-123-456"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"abcdef123456"
block|,
literal|"abcdef"
block|,
literal|"abc"
block|,
literal|"def"
block|,
literal|"123456"
block|,
literal|"123"
block|,
literal|"456"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|8
block|,
literal|8
block|,
literal|12
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|15
block|,
literal|7
block|,
literal|3
block|,
literal|7
block|,
literal|15
block|,
literal|11
block|,
literal|15
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** concat numbers + words + all + preserve original */
DECL|method|testLotsOfConcatenating2
specifier|public
name|void
name|testLotsOfConcatenating2
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|flags
init|=
name|PRESERVE_ORIGINAL
operator||
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|CATENATE_WORDS
operator||
name|CATENATE_NUMBERS
operator||
name|CATENATE_ALL
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
operator||
name|STEM_ENGLISH_POSSESSIVE
decl_stmt|;
comment|/* analyzer that uses whitespace + wdf */
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|field
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|WordDelimiterGraphFilter
argument_list|(
name|tokenizer
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"abc-def-123-456"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"abcdef123456"
block|,
literal|"abc-def-123-456"
block|,
literal|"abcdef"
block|,
literal|"abc"
block|,
literal|"def"
block|,
literal|"123456"
block|,
literal|"123"
block|,
literal|"456"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|8
block|,
literal|8
block|,
literal|12
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|15
block|,
literal|15
block|,
literal|7
block|,
literal|3
block|,
literal|7
block|,
literal|15
block|,
literal|11
block|,
literal|15
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** blast some random strings through the analyzer */
DECL|method|testRandomStrings
specifier|public
name|void
name|testRandomStrings
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|numIterations
init|=
name|atLeast
argument_list|(
literal|5
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIterations
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|flags
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|512
argument_list|)
decl_stmt|;
specifier|final
name|CharArraySet
name|protectedWords
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|protectedWords
operator|=
operator|new
name|CharArraySet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"cd"
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|protectedWords
operator|=
literal|null
expr_stmt|;
block|}
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|WordDelimiterGraphFilter
argument_list|(
name|tokenizer
argument_list|,
name|flags
argument_list|,
name|protectedWords
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|// TODO: properly support positionLengthAttribute
name|checkRandomData
argument_list|(
name|random
argument_list|()
argument_list|,
name|a
argument_list|,
literal|200
operator|*
name|RANDOM_MULTIPLIER
argument_list|,
literal|20
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** blast some enormous random strings through the analyzer */
DECL|method|testRandomHugeStrings
specifier|public
name|void
name|testRandomHugeStrings
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|numIterations
init|=
name|atLeast
argument_list|(
literal|5
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIterations
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|flags
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|512
argument_list|)
decl_stmt|;
specifier|final
name|CharArraySet
name|protectedWords
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|protectedWords
operator|=
operator|new
name|CharArraySet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"cd"
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|protectedWords
operator|=
literal|null
expr_stmt|;
block|}
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|TokenStream
name|wdgf
init|=
operator|new
name|WordDelimiterGraphFilter
argument_list|(
name|tokenizer
argument_list|,
name|flags
argument_list|,
name|protectedWords
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
name|wdgf
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|// TODO: properly support positionLengthAttribute
name|checkRandomData
argument_list|(
name|random
argument_list|()
argument_list|,
name|a
argument_list|,
literal|20
operator|*
name|RANDOM_MULTIPLIER
argument_list|,
literal|8192
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testEmptyTerm
specifier|public
name|void
name|testEmptyTerm
parameter_list|()
throws|throws
name|IOException
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|flags
init|=
name|i
decl_stmt|;
specifier|final
name|CharArraySet
name|protectedWords
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|protectedWords
operator|=
operator|new
name|CharArraySet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"cd"
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|protectedWords
operator|=
literal|null
expr_stmt|;
block|}
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|KeywordTokenizer
argument_list|()
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|WordDelimiterGraphFilter
argument_list|(
name|tokenizer
argument_list|,
name|flags
argument_list|,
name|protectedWords
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|// depending upon options, this thing may or may not preserve the empty term
name|checkAnalysisConsistency
argument_list|(
name|random
argument_list|,
name|a
argument_list|,
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getAnalyzer
specifier|private
name|Analyzer
name|getAnalyzer
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
return|return
name|getAnalyzer
argument_list|(
name|flags
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|getAnalyzer
specifier|private
name|Analyzer
name|getAnalyzer
parameter_list|(
name|int
name|flags
parameter_list|,
name|CharArraySet
name|protectedWords
parameter_list|)
block|{
return|return
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|KeywordTokenizer
argument_list|()
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|WordDelimiterGraphFilter
argument_list|(
name|tokenizer
argument_list|,
name|flags
argument_list|,
name|protectedWords
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|has
specifier|private
specifier|static
name|boolean
name|has
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
return|return
operator|(
name|flags
operator|&
name|flag
operator|)
operator|!=
literal|0
return|;
block|}
DECL|method|isEnglishPossessive
specifier|private
specifier|static
name|boolean
name|isEnglishPossessive
parameter_list|(
name|String
name|text
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|>
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|text
operator|.
name|charAt
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|'s'
operator|||
name|text
operator|.
name|charAt
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|pos
operator|==
name|text
operator|.
name|length
argument_list|()
operator|||
name|text
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
operator|!=
literal|'-'
operator|)
condition|)
block|{
name|text
operator|=
name|text
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|text
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|class|WordPart
specifier|private
specifier|static
class|class
name|WordPart
block|{
DECL|field|part
specifier|final
name|String
name|part
decl_stmt|;
DECL|field|startOffset
specifier|final
name|int
name|startOffset
decl_stmt|;
DECL|field|endOffset
specifier|final
name|int
name|endOffset
decl_stmt|;
DECL|field|type
specifier|final
name|int
name|type
decl_stmt|;
DECL|method|WordPart
specifier|public
name|WordPart
parameter_list|(
name|String
name|text
parameter_list|,
name|int
name|startOffset
parameter_list|,
name|int
name|endOffset
parameter_list|)
block|{
name|this
operator|.
name|part
operator|=
name|text
operator|.
name|substring
argument_list|(
name|startOffset
argument_list|,
name|endOffset
argument_list|)
expr_stmt|;
name|this
operator|.
name|startOffset
operator|=
name|startOffset
expr_stmt|;
name|this
operator|.
name|endOffset
operator|=
name|endOffset
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|toType
argument_list|(
name|part
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"WordPart("
operator|+
name|part
operator|+
literal|" "
operator|+
name|startOffset
operator|+
literal|"-"
operator|+
name|endOffset
operator|+
literal|")"
return|;
block|}
block|}
DECL|field|NUMBER
specifier|private
specifier|static
specifier|final
name|int
name|NUMBER
init|=
literal|0
decl_stmt|;
DECL|field|LETTER
specifier|private
specifier|static
specifier|final
name|int
name|LETTER
init|=
literal|1
decl_stmt|;
DECL|field|DELIM
specifier|private
specifier|static
specifier|final
name|int
name|DELIM
init|=
literal|2
decl_stmt|;
DECL|method|toType
specifier|private
specifier|static
name|int
name|toType
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|// numbers
return|return
name|NUMBER
return|;
block|}
elseif|else
if|if
condition|(
name|Character
operator|.
name|isLetter
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|// letters
return|return
name|LETTER
return|;
block|}
else|else
block|{
comment|// delimiter
return|return
name|DELIM
return|;
block|}
block|}
comment|/** Does (hopefully) the same thing as WordDelimiterGraphFilter, according to the flags, but more slowly, returning all string paths combinations. */
DECL|method|slowWDF
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|slowWDF
parameter_list|(
name|String
name|text
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|// first make word parts:
name|List
argument_list|<
name|WordPart
argument_list|>
name|wordParts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|lastCH
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|wordPartStart
init|=
literal|0
decl_stmt|;
name|boolean
name|inToken
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|text
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|text
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|toType
argument_list|(
name|ch
argument_list|)
operator|==
name|DELIM
condition|)
block|{
comment|// delimiter
if|if
condition|(
name|inToken
condition|)
block|{
comment|// end current token
name|wordParts
operator|.
name|add
argument_list|(
operator|new
name|WordPart
argument_list|(
name|text
argument_list|,
name|wordPartStart
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|inToken
operator|=
literal|false
expr_stmt|;
block|}
comment|// strip english possessive at the end of this token?:
if|if
condition|(
name|has
argument_list|(
name|flags
argument_list|,
name|STEM_ENGLISH_POSSESSIVE
argument_list|)
operator|&&
name|ch
operator|==
literal|'\''
operator|&&
name|i
operator|>
literal|0
operator|&&
name|i
operator|<
name|text
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|&&
operator|(
name|text
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
literal|'s'
operator|||
name|text
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
literal|'S'
operator|)
operator|&&
name|toType
argument_list|(
name|text
operator|.
name|charAt
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|LETTER
operator|&&
operator|(
name|i
operator|+
literal|2
operator|==
name|text
operator|.
name|length
argument_list|()
operator|||
name|toType
argument_list|(
name|text
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|)
operator|==
name|DELIM
operator|)
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inToken
operator|==
literal|false
condition|)
block|{
comment|// start new token
name|inToken
operator|=
literal|true
expr_stmt|;
name|wordPartStart
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|newToken
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isLetter
argument_list|(
name|lastCH
argument_list|)
condition|)
block|{
if|if
condition|(
name|Character
operator|.
name|isLetter
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|has
argument_list|(
name|flags
argument_list|,
name|SPLIT_ON_CASE_CHANGE
argument_list|)
operator|&&
name|Character
operator|.
name|isLowerCase
argument_list|(
name|lastCH
argument_list|)
operator|&&
name|Character
operator|.
name|isLowerCase
argument_list|(
name|ch
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// start new token on lower -> UPPER case change (but not vice versa!)
name|newToken
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|has
argument_list|(
name|flags
argument_list|,
name|SPLIT_ON_NUMERICS
argument_list|)
operator|&&
name|Character
operator|.
name|isDigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|// start new token on letter -> number change
name|newToken
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|Character
operator|.
name|isDigit
argument_list|(
name|lastCH
argument_list|)
assert|;
if|if
condition|(
name|Character
operator|.
name|isLetter
argument_list|(
name|ch
argument_list|)
operator|&&
name|has
argument_list|(
name|flags
argument_list|,
name|SPLIT_ON_NUMERICS
argument_list|)
condition|)
block|{
comment|// start new token on number -> letter change
name|newToken
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newToken
condition|)
block|{
name|wordParts
operator|.
name|add
argument_list|(
operator|new
name|WordPart
argument_list|(
name|text
argument_list|,
name|wordPartStart
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|wordPartStart
operator|=
name|i
expr_stmt|;
block|}
block|}
name|lastCH
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|inToken
condition|)
block|{
comment|// add last token
name|wordParts
operator|.
name|add
argument_list|(
operator|new
name|WordPart
argument_list|(
name|text
argument_list|,
name|wordPartStart
argument_list|,
name|text
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|paths
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|wordParts
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|enumerate
argument_list|(
name|flags
argument_list|,
literal|0
argument_list|,
name|text
argument_list|,
name|wordParts
argument_list|,
name|paths
argument_list|,
operator|new
name|StringBuilder
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has
argument_list|(
name|flags
argument_list|,
name|PRESERVE_ORIGINAL
argument_list|)
condition|)
block|{
name|paths
operator|.
name|add
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has
argument_list|(
name|flags
argument_list|,
name|CATENATE_ALL
argument_list|)
operator|&&
name|wordParts
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|WordPart
name|wordPart
range|:
name|wordParts
control|)
block|{
name|b
operator|.
name|append
argument_list|(
name|wordPart
operator|.
name|part
argument_list|)
expr_stmt|;
block|}
name|paths
operator|.
name|add
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|paths
return|;
block|}
DECL|method|add
specifier|private
name|void
name|add
parameter_list|(
name|StringBuilder
name|path
parameter_list|,
name|String
name|part
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|path
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|path
operator|.
name|append
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
DECL|method|add
specifier|private
name|void
name|add
parameter_list|(
name|StringBuilder
name|path
parameter_list|,
name|List
argument_list|<
name|WordPart
argument_list|>
name|wordParts
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|path
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|// no spaces:
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|<
name|to
condition|;
name|i
operator|++
control|)
block|{
name|path
operator|.
name|append
argument_list|(
name|wordParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|part
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addWithSpaces
specifier|private
name|void
name|addWithSpaces
parameter_list|(
name|StringBuilder
name|path
parameter_list|,
name|List
argument_list|<
name|WordPart
argument_list|>
name|wordParts
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|<
name|to
condition|;
name|i
operator|++
control|)
block|{
name|add
argument_list|(
name|path
argument_list|,
name|wordParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|part
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Finds the end (exclusive) of the series of part with the same type */
DECL|method|endOfRun
specifier|private
name|int
name|endOfRun
parameter_list|(
name|List
argument_list|<
name|WordPart
argument_list|>
name|wordParts
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|upto
init|=
name|start
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|wordParts
operator|.
name|size
argument_list|()
operator|&&
name|wordParts
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|type
operator|==
name|wordParts
operator|.
name|get
argument_list|(
name|start
argument_list|)
operator|.
name|type
condition|)
block|{
name|upto
operator|++
expr_stmt|;
block|}
return|return
name|upto
return|;
block|}
comment|/** Recursively enumerates all paths through the word parts */
DECL|method|enumerate
specifier|private
name|void
name|enumerate
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|upto
parameter_list|,
name|String
name|text
parameter_list|,
name|List
argument_list|<
name|WordPart
argument_list|>
name|wordParts
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|paths
parameter_list|,
name|StringBuilder
name|path
parameter_list|)
block|{
if|if
condition|(
name|upto
operator|==
name|wordParts
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|path
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|paths
operator|.
name|add
argument_list|(
name|path
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|savLength
init|=
name|path
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|end
init|=
name|endOfRun
argument_list|(
name|wordParts
argument_list|,
name|upto
argument_list|)
decl_stmt|;
if|if
condition|(
name|wordParts
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|type
operator|==
name|NUMBER
condition|)
block|{
comment|// always output single word, optionally surrounded by delims:
if|if
condition|(
name|has
argument_list|(
name|flags
argument_list|,
name|GENERATE_NUMBER_PARTS
argument_list|)
operator|||
name|wordParts
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|addWithSpaces
argument_list|(
name|path
argument_list|,
name|wordParts
argument_list|,
name|upto
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|has
argument_list|(
name|flags
argument_list|,
name|CATENATE_NUMBERS
argument_list|)
condition|)
block|{
comment|// recurse first with the parts
name|enumerate
argument_list|(
name|flags
argument_list|,
name|end
argument_list|,
name|text
argument_list|,
name|wordParts
argument_list|,
name|paths
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|path
operator|.
name|setLength
argument_list|(
name|savLength
argument_list|)
expr_stmt|;
comment|// .. and second with the concat
name|add
argument_list|(
name|path
argument_list|,
name|wordParts
argument_list|,
name|upto
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|has
argument_list|(
name|flags
argument_list|,
name|CATENATE_NUMBERS
argument_list|)
condition|)
block|{
name|add
argument_list|(
name|path
argument_list|,
name|wordParts
argument_list|,
name|upto
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
name|enumerate
argument_list|(
name|flags
argument_list|,
name|end
argument_list|,
name|text
argument_list|,
name|wordParts
argument_list|,
name|paths
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|path
operator|.
name|setLength
argument_list|(
name|savLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|wordParts
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|type
operator|==
name|LETTER
assert|;
comment|// always output single word, optionally surrounded by delims:
if|if
condition|(
name|has
argument_list|(
name|flags
argument_list|,
name|GENERATE_WORD_PARTS
argument_list|)
operator|||
name|wordParts
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|addWithSpaces
argument_list|(
name|path
argument_list|,
name|wordParts
argument_list|,
name|upto
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|has
argument_list|(
name|flags
argument_list|,
name|CATENATE_WORDS
argument_list|)
condition|)
block|{
comment|// recurse first with the parts
name|enumerate
argument_list|(
name|flags
argument_list|,
name|end
argument_list|,
name|text
argument_list|,
name|wordParts
argument_list|,
name|paths
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|path
operator|.
name|setLength
argument_list|(
name|savLength
argument_list|)
expr_stmt|;
comment|// .. and second with the concat
name|add
argument_list|(
name|path
argument_list|,
name|wordParts
argument_list|,
name|upto
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|has
argument_list|(
name|flags
argument_list|,
name|CATENATE_WORDS
argument_list|)
condition|)
block|{
name|add
argument_list|(
name|path
argument_list|,
name|wordParts
argument_list|,
name|upto
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
name|enumerate
argument_list|(
name|flags
argument_list|,
name|end
argument_list|,
name|text
argument_list|,
name|wordParts
argument_list|,
name|paths
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|path
operator|.
name|setLength
argument_list|(
name|savLength
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|testBasicGraphSplits
specifier|public
name|void
name|testBasicGraphSplits
parameter_list|()
throws|throws
name|Exception
block|{
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"PowerShotPlus"
argument_list|,
literal|"PowerShotPlus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
argument_list|)
argument_list|,
literal|"PowerShotPlus"
argument_list|,
literal|"PowerShotPlus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
argument_list|)
argument_list|,
literal|"PowerShotPlus"
argument_list|,
literal|"Power Shot Plus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|PRESERVE_ORIGINAL
argument_list|)
argument_list|,
literal|"PowerShotPlus"
argument_list|,
literal|"PowerShotPlus"
argument_list|,
literal|"Power Shot Plus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
argument_list|)
argument_list|,
literal|"Power-Shot-Plus"
argument_list|,
literal|"Power Shot Plus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
argument_list|)
argument_list|,
literal|"Power-Shot-Plus"
argument_list|,
literal|"Power Shot Plus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|PRESERVE_ORIGINAL
argument_list|)
argument_list|,
literal|"Power-Shot-Plus"
argument_list|,
literal|"Power-Shot-Plus"
argument_list|,
literal|"Power Shot Plus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
argument_list|)
argument_list|,
literal|"PowerShotPlus"
argument_list|,
literal|"Power Shot Plus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
argument_list|)
argument_list|,
literal|"PowerShot1000Plus"
argument_list|,
literal|"Power Shot1000Plus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
argument_list|)
argument_list|,
literal|"Power-Shot-Plus"
argument_list|,
literal|"Power Shot Plus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|CATENATE_WORDS
argument_list|)
argument_list|,
literal|"PowerShotPlus"
argument_list|,
literal|"Power Shot Plus"
argument_list|,
literal|"PowerShotPlus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|CATENATE_WORDS
argument_list|)
argument_list|,
literal|"PowerShot1000Plus"
argument_list|,
literal|"Power Shot1000Plus"
argument_list|,
literal|"PowerShot1000Plus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|CATENATE_WORDS
operator||
name|CATENATE_NUMBERS
argument_list|)
argument_list|,
literal|"Power-Shot-1000-17-Plus"
argument_list|,
literal|"Power Shot 1000 17 Plus"
argument_list|,
literal|"Power Shot 100017 Plus"
argument_list|,
literal|"PowerShot 1000 17 Plus"
argument_list|,
literal|"PowerShot 100017 Plus"
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|CATENATE_WORDS
operator||
name|CATENATE_NUMBERS
operator||
name|PRESERVE_ORIGINAL
argument_list|)
argument_list|,
literal|"Power-Shot-1000-17-Plus"
argument_list|,
literal|"Power-Shot-1000-17-Plus"
argument_list|,
literal|"Power Shot 1000 17 Plus"
argument_list|,
literal|"Power Shot 100017 Plus"
argument_list|,
literal|"PowerShot 1000 17 Plus"
argument_list|,
literal|"PowerShot 100017 Plus"
argument_list|)
expr_stmt|;
block|}
comment|/*   public void testToDot() throws Exception {     int flags = GENERATE_WORD_PARTS | GENERATE_NUMBER_PARTS | CATENATE_ALL | SPLIT_ON_CASE_CHANGE | SPLIT_ON_NUMERICS | STEM_ENGLISH_POSSESSIVE | PRESERVE_ORIGINAL | CATENATE_WORDS | CATENATE_NUMBERS | STEM_ENGLISH_POSSESSIVE;     String text = "PowerSystem2000-5-Shot's";     WordDelimiterGraphFilter wdf = new WordDelimiterGraphFilter(new CannedTokenStream(new Token(text, 0, text.length())), DEFAULT_WORD_DELIM_TABLE, flags, null);     //StringWriter sw = new StringWriter();     // TokenStreamToDot toDot = new TokenStreamToDot(text, wdf, new PrintWriter(sw));     PrintWriter pw = new PrintWriter("/tmp/foo2.dot");     TokenStreamToDot toDot = new TokenStreamToDot(text, wdf, pw);     toDot.toDot();     pw.close();     //System.out.println("DOT:\n" + sw.toString());   }   */
DECL|method|randomWDFText
specifier|private
name|String
name|randomWDFText
parameter_list|()
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|length
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|50
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|surpriseMe
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|37
argument_list|)
decl_stmt|;
name|int
name|lower
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|upper
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|surpriseMe
operator|<
literal|10
condition|)
block|{
comment|// lowercase letter
name|lower
operator|=
literal|'a'
expr_stmt|;
name|upper
operator|=
literal|'z'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|surpriseMe
operator|<
literal|20
condition|)
block|{
comment|// uppercase letter
name|lower
operator|=
literal|'A'
expr_stmt|;
name|upper
operator|=
literal|'Z'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|surpriseMe
operator|<
literal|30
condition|)
block|{
comment|// digit
name|lower
operator|=
literal|'0'
expr_stmt|;
name|upper
operator|=
literal|'9'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|surpriseMe
operator|<
literal|35
condition|)
block|{
comment|// punct
name|lower
operator|=
literal|'-'
expr_stmt|;
name|upper
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|append
argument_list|(
literal|"'s"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lower
operator|!=
operator|-
literal|1
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|testInvalidFlag
specifier|public
name|void
name|testInvalidFlag
parameter_list|()
throws|throws
name|Exception
block|{
name|expectThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
operator|new
name|WordDelimiterGraphFilter
argument_list|(
operator|new
name|CannedTokenStream
argument_list|()
argument_list|,
literal|1
operator|<<
literal|31
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testRandomPaths
specifier|public
name|void
name|testRandomPaths
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|iters
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|iters
condition|;
name|iter
operator|++
control|)
block|{
name|String
name|text
init|=
name|randomWDFText
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: text="
operator|+
name|text
operator|+
literal|" len="
operator|+
name|text
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|flags
operator||=
name|GENERATE_WORD_PARTS
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|flags
operator||=
name|GENERATE_NUMBER_PARTS
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|flags
operator||=
name|CATENATE_WORDS
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|flags
operator||=
name|CATENATE_NUMBERS
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|flags
operator||=
name|CATENATE_ALL
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|flags
operator||=
name|PRESERVE_ORIGINAL
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|flags
operator||=
name|SPLIT_ON_CASE_CHANGE
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|flags
operator||=
name|SPLIT_ON_NUMERICS
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|flags
operator||=
name|STEM_ENGLISH_POSSESSIVE
expr_stmt|;
block|}
name|verify
argument_list|(
name|text
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Runs normal and slow WDGF and compares results */
DECL|method|verify
specifier|private
name|void
name|verify
parameter_list|(
name|String
name|text
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|expected
init|=
name|slowWDF
argument_list|(
name|text
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
for|for
control|(
name|String
name|path
range|:
name|expected
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|actual
init|=
name|getGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|flags
argument_list|)
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|actual
operator|.
name|equals
argument_list|(
name|expected
argument_list|)
operator|==
literal|false
condition|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"\n\nFAIL: text="
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" flags="
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|WordDelimiterGraphFilter
operator|.
name|flagsToString
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  expected paths:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|expected
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual
operator|.
name|contains
argument_list|(
name|s
argument_list|)
operator|==
literal|false
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" [missing!]"
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"  actual paths:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|actual
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected
operator|.
name|contains
argument_list|(
name|s
argument_list|)
operator|==
literal|false
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" [unexpected!]"
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|fail
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testOnlyNumbers
specifier|public
name|void
name|testOnlyNumbers
parameter_list|()
throws|throws
name|Exception
block|{
comment|// no token should be produced
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
argument_list|)
argument_list|,
literal|"7-586"
argument_list|)
expr_stmt|;
block|}
DECL|method|testNoCatenate
specifier|public
name|void
name|testNoCatenate
parameter_list|()
throws|throws
name|Exception
block|{
comment|// no token should be produced
name|assertGraphStrings
argument_list|(
name|getAnalyzer
argument_list|(
name|GENERATE_WORD_PARTS
operator||
name|GENERATE_NUMBER_PARTS
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
argument_list|)
argument_list|,
literal|"a-b-c-9-d"
argument_list|,
literal|"a b c 9 d"
argument_list|)
expr_stmt|;
block|}
DECL|method|testCuriousCase1
specifier|public
name|void
name|testCuriousCase1
parameter_list|()
throws|throws
name|Exception
block|{
name|verify
argument_list|(
literal|"u-0L-4836-ip4Gw--13--q7--L07E1"
argument_list|,
name|CATENATE_WORDS
operator||
name|CATENATE_ALL
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
operator||
name|STEM_ENGLISH_POSSESSIVE
argument_list|)
expr_stmt|;
block|}
DECL|method|testCuriousCase2
specifier|public
name|void
name|testCuriousCase2
parameter_list|()
throws|throws
name|Exception
block|{
name|verify
argument_list|(
literal|"u-l-p"
argument_list|,
name|CATENATE_ALL
argument_list|)
expr_stmt|;
block|}
DECL|method|testOriginalPosLength
specifier|public
name|void
name|testOriginalPosLength
parameter_list|()
throws|throws
name|Exception
block|{
name|verify
argument_list|(
literal|"Foo-Bar-Baz"
argument_list|,
name|CATENATE_WORDS
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|PRESERVE_ORIGINAL
argument_list|)
expr_stmt|;
block|}
DECL|method|testCuriousCase3
specifier|public
name|void
name|testCuriousCase3
parameter_list|()
throws|throws
name|Exception
block|{
name|verify
argument_list|(
literal|"cQzk4-GL0izl0mKM-J8--4m-'s"
argument_list|,
name|GENERATE_NUMBER_PARTS
operator||
name|CATENATE_NUMBERS
operator||
name|SPLIT_ON_CASE_CHANGE
operator||
name|SPLIT_ON_NUMERICS
argument_list|)
expr_stmt|;
block|}
DECL|method|testEmptyString
specifier|public
name|void
name|testEmptyString
parameter_list|()
throws|throws
name|Exception
block|{
name|WordDelimiterGraphFilter
name|wdf
init|=
operator|new
name|WordDelimiterGraphFilter
argument_list|(
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|DEFAULT_WORD_DELIM_TABLE
argument_list|,
name|GENERATE_WORD_PARTS
operator||
name|CATENATE_ALL
operator||
name|PRESERVE_ORIGINAL
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|wdf
operator|.
name|reset
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|wdf
operator|.
name|incrementToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|wdf
operator|.
name|incrementToken
argument_list|()
argument_list|)
expr_stmt|;
name|wdf
operator|.
name|end
argument_list|()
expr_stmt|;
name|wdf
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testProtectedWords
specifier|public
name|void
name|testProtectedWords
parameter_list|()
throws|throws
name|Exception
block|{
name|TokenStream
name|tokens
init|=
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
argument_list|(
literal|"foo17-bar"
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|)
argument_list|,
operator|new
name|Token
argument_list|(
literal|"foo-bar"
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
argument_list|)
decl_stmt|;
name|CharArraySet
name|protectedWords
init|=
operator|new
name|CharArraySet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"foo17-BAR"
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|WordDelimiterGraphFilter
name|wdf
init|=
operator|new
name|WordDelimiterGraphFilter
argument_list|(
name|tokens
argument_list|,
name|DEFAULT_WORD_DELIM_TABLE
argument_list|,
name|GENERATE_WORD_PARTS
operator||
name|PRESERVE_ORIGINAL
operator||
name|CATENATE_ALL
argument_list|,
name|protectedWords
argument_list|)
decl_stmt|;
name|assertGraphStrings
argument_list|(
name|wdf
argument_list|,
literal|"foo17-bar foo bar"
argument_list|,
literal|"foo17-bar foo-bar"
argument_list|,
literal|"foo17-bar foobar"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

