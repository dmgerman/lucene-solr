begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.analysis.synonym
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|synonym
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|BaseTokenStreamTestCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockGraphTokenFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Tokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|core
operator|.
name|FlattenGraphFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|RandomIndexWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|PhraseQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CharsRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CharsRefBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRefBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Automaton
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|AutomatonTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Operations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|TooComplexToDeterminizeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Transition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Util
import|;
end_import

begin_class
DECL|class|TestSynonymGraphFilter
specifier|public
class|class
name|TestSynonymGraphFilter
extends|extends
name|BaseTokenStreamTestCase
block|{
comment|/** Set as a side effect by {@link #getAnalyzer} and {@link #getFlattenAnalyzer}. */
DECL|field|synFilter
specifier|private
name|SynonymGraphFilter
name|synFilter
decl_stmt|;
DECL|field|flattenFilter
specifier|private
name|FlattenGraphFilter
name|flattenFilter
decl_stmt|;
DECL|method|testBasicKeepOrigOneOutput
specifier|public
name|void
name|testBasicKeepOrigOneOutput
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c a b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"x"
block|,
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|5
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testMixedKeepOrig
specifier|public
name|void
name|testMixedKeepOrig
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"e f"
argument_list|,
literal|"y"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c a b c e f g"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"x"
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"y"
block|,
literal|"g"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|,
literal|12
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|11
block|,
literal|13
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testNoParseAfterBuffer
specifier|public
name|void
name|testNoParseAfterBuffer
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"b a"
argument_list|,
literal|"x"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"b b b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"b"
block|,
literal|"b"
block|,
literal|"b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testOneInputMultipleOutputKeepOrig
specifier|public
name|void
name|testOneInputMultipleOutputKeepOrig
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"y"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c a b c"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"x"
block|,
literal|"y"
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Verify type of token and positionLength after analyzer.    */
DECL|method|testPositionLengthAndTypeSimple
specifier|public
name|void
name|testPositionLengthAndTypeSimple
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|testFile
init|=
literal|"spider man, spiderman"
decl_stmt|;
name|Analyzer
name|analyzer
init|=
name|solrSynsToAnalyzer
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|assertAnalyzesToPositions
argument_list|(
name|analyzer
argument_list|,
literal|"spider man"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"spiderman"
block|,
literal|"spider"
block|,
literal|"man"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|2
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * parse a syn file with some escaped syntax chars    */
DECL|method|testEscapedStuff
specifier|public
name|void
name|testEscapedStuff
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|testFile
init|=
literal|"a\\=>a => b\\=>b\n"
operator|+
literal|"a\\,a => b\\,b"
decl_stmt|;
name|Analyzer
name|analyzer
init|=
name|solrSynsToAnalyzer
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"ball"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ball"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"a=>a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"b=>b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"a,a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"b,b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|}
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * parse a syn file with bad syntax    */
DECL|method|testInvalidAnalyzesToNothingOutput
specifier|public
name|void
name|testInvalidAnalyzesToNothingOutput
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|testFile
init|=
literal|"a => 1"
decl_stmt|;
name|Analyzer
name|analyzer
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|SolrSynonymParser
name|parser
init|=
operator|new
name|SolrSynonymParser
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
name|analyzer
argument_list|)
decl_stmt|;
try|try
block|{
name|parser
operator|.
name|parse
argument_list|(
operator|new
name|StringReader
argument_list|(
name|testFile
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"didn't get expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|expected
parameter_list|)
block|{
comment|// expected exc
block|}
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * parse a syn file with bad syntax    */
DECL|method|testInvalidDoubleMap
specifier|public
name|void
name|testInvalidDoubleMap
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|testFile
init|=
literal|"a => b => c"
decl_stmt|;
name|Analyzer
name|analyzer
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|SolrSynonymParser
name|parser
init|=
operator|new
name|SolrSynonymParser
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
name|analyzer
argument_list|)
decl_stmt|;
try|try
block|{
name|parser
operator|.
name|parse
argument_list|(
operator|new
name|StringReader
argument_list|(
name|testFile
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"didn't get expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|expected
parameter_list|)
block|{
comment|// expected exc
block|}
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Tests some simple examples from the solr wiki    */
DECL|method|testSimple
specifier|public
name|void
name|testSimple
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|testFile
init|=
literal|"i-pod, ipod, ipoooood\n"
operator|+
literal|"foo => foo bar\n"
operator|+
literal|"foo => baz\n"
operator|+
literal|"this test, that testing"
decl_stmt|;
name|Analyzer
name|analyzer
init|=
name|solrSynsToAnalyzer
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"ball"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ball"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"i-pod"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ipod"
block|,
literal|"ipoooood"
block|,
literal|"i-pod"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"foo"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"foo"
block|,
literal|"baz"
block|,
literal|"bar"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"this test"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"that"
block|,
literal|"this"
block|,
literal|"testing"
block|,
literal|"test"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testBufferLength
specifier|public
name|void
name|testBufferLength
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|testFile
init|=
literal|"c => 8 2 5 6 7\n"
operator|+
literal|"f c e d f, 1\n"
operator|+
literal|"c g a f d, 6 5 5\n"
operator|+
literal|"e c => 4\n"
operator|+
literal|"g => 5\n"
operator|+
literal|"a g b f e => 5 0 7 7\n"
operator|+
literal|"b => 1"
decl_stmt|;
name|Analyzer
name|analyzer
init|=
name|solrSynsToAnalyzer
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|String
name|doc
init|=
literal|"b c g a f b d"
decl_stmt|;
name|String
index|[]
name|expected
init|=
operator|new
name|String
index|[]
block|{
literal|"1"
block|,
literal|"8"
block|,
literal|"2"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"5"
block|,
literal|"a"
block|,
literal|"f"
block|,
literal|"1"
block|,
literal|"d"
block|}
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
name|doc
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
DECL|method|solrSynsToAnalyzer
specifier|private
name|Analyzer
name|solrSynsToAnalyzer
parameter_list|(
name|String
name|syns
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
block|{
name|Analyzer
name|analyzer
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|SolrSynonymParser
name|parser
init|=
operator|new
name|SolrSynonymParser
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
name|analyzer
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|(
operator|new
name|StringReader
argument_list|(
name|syns
argument_list|)
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|getFlattenAnalyzer
argument_list|(
name|parser
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|testMoreThanOneLookAhead
specifier|public
name|void
name|testMoreThanOneLookAhead
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b c d"
argument_list|,
literal|"x"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a b c e"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"e"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testLookaheadAfterParse
specifier|public
name|void
name|testLookaheadAfterParse
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"b b"
argument_list|,
literal|"x"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"b"
argument_list|,
literal|"y"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"b a b b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"y"
block|,
literal|"b"
block|,
literal|"a"
block|,
literal|"x"
block|,
literal|"b"
block|,
literal|"b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|6
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|7
block|,
literal|5
block|,
literal|7
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|testLookaheadSecondParse
specifier|public
name|void
name|testLookaheadSecondParse
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"b b b"
argument_list|,
literal|"x"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"b"
argument_list|,
literal|"y"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"b b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"y"
block|,
literal|"b"
block|,
literal|"y"
block|,
literal|"b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|2
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|testOneInputMultipleOutputNoKeepOrig
specifier|public
name|void
name|testOneInputMultipleOutputNoKeepOrig
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"y"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c a b c"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"x"
block|,
literal|"y"
block|,
literal|"c"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|6
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testOneInputMultipleOutputMixedKeepOrig
specifier|public
name|void
name|testOneInputMultipleOutputMixedKeepOrig
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"y"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c a b c"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"x"
block|,
literal|"y"
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testSynAtEnd
specifier|public
name|void
name|testSynAtEnd
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c d e a b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"d"
block|,
literal|"e"
block|,
literal|"x"
block|,
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|6
block|,
literal|8
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|9
block|,
literal|7
block|,
literal|9
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testTwoSynsInARow
specifier|public
name|void
name|testTwoSynsInARow
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a"
argument_list|,
literal|"x"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c a a b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"x"
block|,
literal|"x"
block|,
literal|"b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testBasicKeepOrigTwoOutputs
specifier|public
name|void
name|testBasicKeepOrigTwoOutputs
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x y"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"m n o"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c a b d"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"x"
block|,
literal|"m"
block|,
literal|"a"
block|,
literal|"y"
block|,
literal|"n"
block|,
literal|"o"
block|,
literal|"b"
block|,
literal|"d"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testNoCaptureIfNoMatch
specifier|public
name|void
name|testNoCaptureIfNoMatch
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x y"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c d d"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"d"
block|,
literal|"d"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|synFilter
operator|.
name|getCaptureCount
argument_list|()
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testBasicNotKeepOrigOneOutput
specifier|public
name|void
name|testBasicNotKeepOrigOneOutput
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c a b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"x"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testBasicNoKeepOrigTwoOutputs
specifier|public
name|void
name|testBasicNoKeepOrigTwoOutputs
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x y"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"m n o"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c a b d"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"x"
block|,
literal|"m"
block|,
literal|"y"
block|,
literal|"n"
block|,
literal|"o"
block|,
literal|"d"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|6
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testIgnoreCase
specifier|public
name|void
name|testIgnoreCase
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x y"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"m n o"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c A B D"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"x"
block|,
literal|"m"
block|,
literal|"y"
block|,
literal|"n"
block|,
literal|"o"
block|,
literal|"D"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|6
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testDoNotIgnoreCase
specifier|public
name|void
name|testDoNotIgnoreCase
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x y"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"m n o"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c A B D"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"A"
block|,
literal|"B"
block|,
literal|"D"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testBufferedFinish1
specifier|public
name|void
name|testBufferedFinish1
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b c"
argument_list|,
literal|"m n o"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c a b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testBufferedFinish2
specifier|public
name|void
name|testBufferedFinish2
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"m n o"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"d e"
argument_list|,
literal|"m n o"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c a d"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"a"
block|,
literal|"d"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testCanReuse
specifier|public
name|void
name|testCanReuse
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"x"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c a b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"c"
block|,
literal|"x"
block|,
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|5
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
block|}
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Multiple input tokens map to a single output token */
DECL|method|testManyToOne
specifier|public
name|void
name|testManyToOne
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b c"
argument_list|,
literal|"z"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a b c d"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"z"
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|5
block|,
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testBufferAfterMatch
specifier|public
name|void
name|testBufferAfterMatch
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b c d"
argument_list|,
literal|"x"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"y"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// The 'c' token has to be buffered because SynGraphFilter
comment|// needs to know whether a b c d -> x matches:
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"f a b c e"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"f"
block|,
literal|"y"
block|,
literal|"c"
block|,
literal|"e"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|6
block|,
literal|8
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|,
literal|7
block|,
literal|9
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testZeroSyns
specifier|public
name|void
name|testZeroSyns
parameter_list|()
throws|throws
name|Exception
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|()
decl_stmt|;
name|tokenizer
operator|.
name|setReader
argument_list|(
operator|new
name|StringReader
argument_list|(
literal|"aa bb"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
operator|new
name|SynonymGraphFilter
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"did not hit expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
name|assertEquals
argument_list|(
literal|"fst must be non-null"
argument_list|,
name|iae
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testOutputHangsOffEnd
specifier|public
name|void
name|testOutputHangsOffEnd
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
comment|// b hangs off the end (no input token under it):
name|add
argument_list|(
name|b
argument_list|,
literal|"a"
argument_list|,
literal|"a b"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testDedup
specifier|public
name|void
name|testDedup
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ab"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testNoDedup
specifier|public
name|void
name|testNoDedup
parameter_list|()
throws|throws
name|Exception
block|{
comment|// dedup is false:
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ab"
block|,
literal|"ab"
block|,
literal|"ab"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testMatching
specifier|public
name|void
name|testMatching
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a c"
argument_list|,
literal|"ac"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a"
argument_list|,
literal|"aa"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"b"
argument_list|,
literal|"bb"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"z x c v"
argument_list|,
literal|"zxcv"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"x c"
argument_list|,
literal|"xc"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|checkOneTerm
argument_list|(
name|a
argument_list|,
literal|"$"
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
name|checkOneTerm
argument_list|(
name|a
argument_list|,
literal|"a"
argument_list|,
literal|"aa"
argument_list|)
expr_stmt|;
name|checkOneTerm
argument_list|(
name|a
argument_list|,
literal|"b"
argument_list|,
literal|"bb"
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a $"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aa"
block|,
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"$ a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"$"
block|,
literal|"aa"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aa"
block|,
literal|"aa"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"z x c v"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"zxcv"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"z x c $"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"z"
block|,
literal|"xc"
block|,
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testBasic1
specifier|public
name|void
name|testBasic1
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a"
argument_list|,
literal|"foo"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"bar fee"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"b c"
argument_list|,
literal|"dog collar"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"c d"
argument_list|,
literal|"dog harness holder extras"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"m c e"
argument_list|,
literal|"dog barks loudly"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"i j k"
argument_list|,
literal|"feep"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"e f"
argument_list|,
literal|"foo bar"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"e f"
argument_list|,
literal|"baz bee"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"z"
argument_list|,
literal|"boo"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"y"
argument_list|,
literal|"bee"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a b c"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"bar"
block|,
literal|"a"
block|,
literal|"fee"
block|,
literal|"b"
block|,
literal|"c"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"x a b c d"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"x"
block|,
literal|"bar"
block|,
literal|"a"
block|,
literal|"fee"
block|,
literal|"b"
block|,
literal|"dog"
block|,
literal|"c"
block|,
literal|"harness"
block|,
literal|"d"
block|,
literal|"holder"
block|,
literal|"extras"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a b a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"bar"
block|,
literal|"a"
block|,
literal|"fee"
block|,
literal|"b"
block|,
literal|"foo"
block|,
literal|"a"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
comment|// outputs no longer add to one another:
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c d c d"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"dog"
block|,
literal|"c"
block|,
literal|"harness"
block|,
literal|"d"
block|,
literal|"holder"
block|,
literal|"extras"
block|,
literal|"dog"
block|,
literal|"c"
block|,
literal|"harness"
block|,
literal|"d"
block|,
literal|"holder"
block|,
literal|"extras"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
comment|// two outputs for same input
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"e f"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"foo"
block|,
literal|"baz"
block|,
literal|"bar"
block|,
literal|"bee"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
comment|// verify multi-word / single-output offsets:
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"g i j k g"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"g"
block|,
literal|"feep"
block|,
literal|"i"
block|,
literal|"j"
block|,
literal|"k"
block|,
literal|"g"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
comment|// mixed keepOrig true/false:
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a m c e x"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"foo"
block|,
literal|"a"
block|,
literal|"dog"
block|,
literal|"barks"
block|,
literal|"loudly"
block|,
literal|"x"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"c d m c e x"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"dog"
block|,
literal|"c"
block|,
literal|"harness"
block|,
literal|"d"
block|,
literal|"holder"
block|,
literal|"extras"
block|,
literal|"dog"
block|,
literal|"barks"
block|,
literal|"loudly"
block|,
literal|"x"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|synFilter
operator|.
name|getCaptureCount
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// no captureStates when no syns matched
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"p q r s t"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"p"
block|,
literal|"q"
block|,
literal|"r"
block|,
literal|"s"
block|,
literal|"t"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|synFilter
operator|.
name|getCaptureCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// captureStates are necessary for the single-token syn case:
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"p q z y t"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"p"
block|,
literal|"q"
block|,
literal|"boo"
block|,
literal|"bee"
block|,
literal|"y"
block|,
literal|"t"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|synFilter
operator|.
name|getCaptureCount
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|testBasic2
specifier|public
name|void
name|testBasic2
parameter_list|()
throws|throws
name|Exception
block|{
name|boolean
name|keepOrig
init|=
literal|true
decl_stmt|;
do|do
block|{
name|keepOrig
operator|=
operator|!
name|keepOrig
expr_stmt|;
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"aaa"
argument_list|,
literal|"aaaa1 aaaa2 aaaa3"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"bbb"
argument_list|,
literal|"bbbb1 bbbb2"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|keepOrig
condition|)
block|{
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"xyzzy bbb pot of gold"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"xyzzy"
block|,
literal|"bbbb1"
block|,
literal|"bbb"
block|,
literal|"bbbb2"
block|,
literal|"pot"
block|,
literal|"of"
block|,
literal|"gold"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"xyzzy aaa pot of gold"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"xyzzy"
block|,
literal|"aaaa1"
block|,
literal|"aaa"
block|,
literal|"aaaa2"
block|,
literal|"aaaa2"
block|,
literal|"pot"
block|,
literal|"of"
block|,
literal|"gold"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"xyzzy bbb pot of gold"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"xyzzy"
block|,
literal|"bbbb1"
block|,
literal|"bbbb2"
block|,
literal|"pot"
block|,
literal|"of"
block|,
literal|"gold"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"xyzzy aaa pot of gold"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"xyzzy"
block|,
literal|"aaaa1"
block|,
literal|"aaaa2"
block|,
literal|"aaaa3"
block|,
literal|"pot"
block|,
literal|"of"
block|,
literal|"gold"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|keepOrig
condition|)
do|;
block|}
comment|/** If we expand synonyms during indexing, it's a bit better than    *  SynonymFilter is today, but still necessarily has false    *  positive and negative PhraseQuery matches because we do not      *  index posLength, so we lose information. */
DECL|method|testFlattenedGraph
specifier|public
name|void
name|testFlattenedGraph
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"wtf"
argument_list|,
literal|"what the fudge"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"wtf happened"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"what"
block|,
literal|"wtf"
block|,
literal|"the"
block|,
literal|"fudge"
block|,
literal|"happened"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|12
block|}
argument_list|,
literal|null
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|RandomIndexWriter
name|w
init|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|a
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"field"
argument_list|,
literal|"wtf happened"
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|IndexReader
name|r
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexSearcher
name|s
init|=
name|newSearcher
argument_list|(
name|r
argument_list|)
decl_stmt|;
comment|// Good (this should not match, and doesn't):
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|count
argument_list|(
operator|new
name|PhraseQuery
argument_list|(
literal|"field"
argument_list|,
literal|"what"
argument_list|,
literal|"happened"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Bad (this should match, but doesn't):
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|count
argument_list|(
operator|new
name|PhraseQuery
argument_list|(
literal|"field"
argument_list|,
literal|"wtf"
argument_list|,
literal|"happened"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Good (this should match, and does):
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|s
operator|.
name|count
argument_list|(
operator|new
name|PhraseQuery
argument_list|(
literal|"field"
argument_list|,
literal|"what"
argument_list|,
literal|"the"
argument_list|,
literal|"fudge"
argument_list|,
literal|"happened"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Bad (this should not match, but does):
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|s
operator|.
name|count
argument_list|(
operator|new
name|PhraseQuery
argument_list|(
literal|"field"
argument_list|,
literal|"wtf"
argument_list|,
literal|"the"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|close
argument_list|(
name|r
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
comment|// Needs TermAutomatonQuery, which is in sandbox still:
comment|/*   public void testAccurateGraphQuery1() throws Exception {     Directory dir = newDirectory();     RandomIndexWriter w = new RandomIndexWriter(random(), dir);     Document doc = new Document();     doc.add(newTextField("field", "wtf happened", Field.Store.NO));     w.addDocument(doc);     IndexReader r = w.getReader();     w.close();      IndexSearcher s = newSearcher(r);      SynonymMap.Builder b = new SynonymMap.Builder();     add(b, "what the fudge", "wtf", true);      SynonymMap map = b.build();      TokenStreamToTermAutomatonQuery ts2q = new TokenStreamToTermAutomatonQuery();      TokenStream in = new CannedTokenStream(0, 23, new Token[] {         token("what", 1, 1, 0, 4),         token("the", 1, 1, 5, 8),         token("fudge", 1, 1, 9, 14),         token("happened", 1, 1, 15, 23),       });      assertEquals(1, s.count(ts2q.toQuery("field", new SynonymGraphFilter(in, map, true))));      in = new CannedTokenStream(0, 12, new Token[] {         token("wtf", 1, 1, 0, 3),         token("happened", 1, 1, 4, 12),       });      assertEquals(1, s.count(ts2q.toQuery("field", new SynonymGraphFilter(in, map, true))));      // "what happened" should NOT match:     in = new CannedTokenStream(0, 13, new Token[] {         token("what", 1, 1, 0, 4),         token("happened", 1, 1, 5, 13),       });     assertEquals(0, s.count(ts2q.toQuery("field", new SynonymGraphFilter(in, map, true))));      IOUtils.close(r, dir);   }   */
comment|/** If we expand synonyms at search time, the results are correct. */
comment|// Needs TermAutomatonQuery, which is in sandbox still:
comment|/*   public void testAccurateGraphQuery2() throws Exception {     Directory dir = newDirectory();     RandomIndexWriter w = new RandomIndexWriter(random(), dir);     Document doc = new Document();     doc.add(newTextField("field", "say wtf happened", Field.Store.NO));     w.addDocument(doc);     IndexReader r = w.getReader();     w.close();      IndexSearcher s = newSearcher(r);      SynonymMap.Builder b = new SynonymMap.Builder();     add(b, "what the fudge", "wtf", true);      SynonymMap map = b.build();      TokenStream in = new CannedTokenStream(0, 26, new Token[] {         token("say", 1, 1, 0, 3),         token("what", 1, 1, 3, 7),         token("the", 1, 1, 8, 11),         token("fudge", 1, 1, 12, 17),         token("happened", 1, 1, 18, 26),       });      TokenStreamToTermAutomatonQuery ts2q = new TokenStreamToTermAutomatonQuery();      assertEquals(1, s.count(ts2q.toQuery("field", new SynonymGraphFilter(in, map, true))));      // "what happened" should NOT match:     in = new CannedTokenStream(0, 13, new Token[] {         token("what", 1, 1, 0, 4),         token("happened", 1, 1, 5, 13),       });     assertEquals(0, s.count(ts2q.toQuery("field", new SynonymGraphFilter(in, map, true))));      IOUtils.close(r, dir);   }   */
comment|// Needs TermAutomatonQuery, which is in sandbox still:
comment|/*   public void testAccurateGraphQuery3() throws Exception {     Directory dir = newDirectory();     RandomIndexWriter w = new RandomIndexWriter(random(), dir);     Document doc = new Document();     doc.add(newTextField("field", "say what the fudge happened", Field.Store.NO));     w.addDocument(doc);     IndexReader r = w.getReader();     w.close();      IndexSearcher s = newSearcher(r);      SynonymMap.Builder b = new SynonymMap.Builder();     add(b, "wtf", "what the fudge", true);      SynonymMap map = b.build();      TokenStream in = new CannedTokenStream(0, 15, new Token[] {         token("say", 1, 1, 0, 3),         token("wtf", 1, 1, 3, 6),         token("happened", 1, 1, 7, 15),       });      TokenStreamToTermAutomatonQuery ts2q = new TokenStreamToTermAutomatonQuery();      assertEquals(1, s.count(ts2q.toQuery("field", new SynonymGraphFilter(in, map, true))));      // "what happened" should NOT match:     in = new CannedTokenStream(0, 13, new Token[] {         token("what", 1, 1, 0, 4),         token("happened", 1, 1, 5, 13),       });     assertEquals(0, s.count(ts2q.toQuery("field", new SynonymGraphFilter(in, map, true))));      IOUtils.close(r, dir);   }    private static Token token(String term, int posInc, int posLength, int startOffset, int endOffset) {     final Token t = new Token(term, startOffset, endOffset);     t.setPositionIncrement(posInc);     t.setPositionLength(posLength);     return t;   }   */
DECL|method|randomNonEmptyString
specifier|private
name|String
name|randomNonEmptyString
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|s
init|=
name|TestUtil
operator|.
name|randomUnicodeString
argument_list|(
name|random
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
comment|//String s = TestUtil.randomSimpleString(random()).trim();
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|!=
literal|0
operator|&&
name|s
operator|.
name|indexOf
argument_list|(
literal|'\u0000'
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
block|}
comment|// Adds MockGraphTokenFilter after SynFilter:
DECL|method|testRandomGraphAfter
specifier|public
name|void
name|testRandomGraphAfter
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|numIters
init|=
name|atLeast
argument_list|(
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIters
condition|;
name|i
operator|++
control|)
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numEntries
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numEntries
condition|;
name|j
operator|++
control|)
block|{
name|add
argument_list|(
name|b
argument_list|,
name|randomNonEmptyString
argument_list|()
argument_list|,
name|randomNonEmptyString
argument_list|()
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SynonymMap
name|map
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|ignoreCase
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|doFlatten
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|Analyzer
name|analyzer
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|TokenStream
name|syns
init|=
operator|new
name|SynonymGraphFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
name|ignoreCase
argument_list|)
decl_stmt|;
name|TokenStream
name|graph
init|=
operator|new
name|MockGraphTokenFilter
argument_list|(
name|random
argument_list|()
argument_list|,
name|syns
argument_list|)
decl_stmt|;
if|if
condition|(
name|doFlatten
condition|)
block|{
name|graph
operator|=
operator|new
name|FlattenGraphFilter
argument_list|(
name|graph
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
name|graph
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|checkRandomData
argument_list|(
name|random
argument_list|()
argument_list|,
name|analyzer
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testEmptyStringInput
specifier|public
name|void
name|testEmptyStringInput
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|numIters
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIters
condition|;
name|i
operator|++
control|)
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numEntries
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numEntries
condition|;
name|j
operator|++
control|)
block|{
name|add
argument_list|(
name|b
argument_list|,
name|randomNonEmptyString
argument_list|()
argument_list|,
name|randomNonEmptyString
argument_list|()
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|ignoreCase
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
name|Analyzer
name|analyzer
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
name|ignoreCase
argument_list|)
decl_stmt|;
name|checkAnalysisConsistency
argument_list|(
name|random
argument_list|()
argument_list|,
name|analyzer
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** simple random test, doesn't verify correctness.    *  does verify it doesnt throw exceptions, or that the stream doesn't misbehave    */
DECL|method|testRandom2
specifier|public
name|void
name|testRandom2
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|numIters
init|=
name|atLeast
argument_list|(
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIters
condition|;
name|i
operator|++
control|)
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numEntries
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numEntries
condition|;
name|j
operator|++
control|)
block|{
name|add
argument_list|(
name|b
argument_list|,
name|randomNonEmptyString
argument_list|()
argument_list|,
name|randomNonEmptyString
argument_list|()
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|ignoreCase
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|doFlatten
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
name|Analyzer
name|analyzer
decl_stmt|;
if|if
condition|(
name|doFlatten
condition|)
block|{
name|analyzer
operator|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
name|ignoreCase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|analyzer
operator|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
name|ignoreCase
argument_list|)
expr_stmt|;
block|}
name|checkRandomData
argument_list|(
name|random
argument_list|()
argument_list|,
name|analyzer
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** simple random test like testRandom2, but for larger docs    */
DECL|method|testRandomHuge
specifier|public
name|void
name|testRandomHuge
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|numIters
init|=
name|atLeast
argument_list|(
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIters
condition|;
name|i
operator|++
control|)
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numEntries
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: iter="
operator|+
name|i
operator|+
literal|" numEntries="
operator|+
name|numEntries
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numEntries
condition|;
name|j
operator|++
control|)
block|{
name|add
argument_list|(
name|b
argument_list|,
name|randomNonEmptyString
argument_list|()
argument_list|,
name|randomNonEmptyString
argument_list|()
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|ignoreCase
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|doFlatten
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
name|Analyzer
name|analyzer
decl_stmt|;
if|if
condition|(
name|doFlatten
condition|)
block|{
name|analyzer
operator|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
name|ignoreCase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|analyzer
operator|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
name|ignoreCase
argument_list|)
expr_stmt|;
block|}
name|checkRandomData
argument_list|(
name|random
argument_list|()
argument_list|,
name|analyzer
argument_list|,
literal|100
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testEmptyTerm
specifier|public
name|void
name|testEmptyTerm
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|numIters
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIters
condition|;
name|i
operator|++
control|)
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numEntries
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numEntries
condition|;
name|j
operator|++
control|)
block|{
name|add
argument_list|(
name|b
argument_list|,
name|randomNonEmptyString
argument_list|()
argument_list|,
name|randomNonEmptyString
argument_list|()
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|ignoreCase
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|Analyzer
name|analyzer
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
name|ignoreCase
argument_list|)
decl_stmt|;
name|checkAnalysisConsistency
argument_list|(
name|random
argument_list|()
argument_list|,
name|analyzer
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// LUCENE-3375
DECL|method|testVanishingTermsNoFlatten
specifier|public
name|void
name|testVanishingTermsNoFlatten
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|testFile
init|=
literal|"aaa => aaaa1 aaaa2 aaaa3\n"
operator|+
literal|"bbb => bbbb1 bbbb2\n"
decl_stmt|;
name|Analyzer
name|analyzer
init|=
name|solrSynsToAnalyzer
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"xyzzy bbb pot of gold"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"xyzzy"
block|,
literal|"bbbb1"
block|,
literal|"bbbb2"
block|,
literal|"pot"
block|,
literal|"of"
block|,
literal|"gold"
block|}
argument_list|)
expr_stmt|;
comment|// xyzzy aaa pot of gold -> xyzzy aaaa1 aaaa2 aaaa3 gold
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"xyzzy aaa pot of gold"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"xyzzy"
block|,
literal|"aaaa1"
block|,
literal|"aaaa2"
block|,
literal|"aaaa3"
block|,
literal|"pot"
block|,
literal|"of"
block|,
literal|"gold"
block|}
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// LUCENE-3375
DECL|method|testVanishingTermsWithFlatten
specifier|public
name|void
name|testVanishingTermsWithFlatten
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|testFile
init|=
literal|"aaa => aaaa1 aaaa2 aaaa3\n"
operator|+
literal|"bbb => bbbb1 bbbb2\n"
decl_stmt|;
name|Analyzer
name|analyzer
init|=
name|solrSynsToAnalyzer
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"xyzzy bbb pot of gold"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"xyzzy"
block|,
literal|"bbbb1"
block|,
literal|"bbbb2"
block|,
literal|"pot"
block|,
literal|"of"
block|,
literal|"gold"
block|}
argument_list|)
expr_stmt|;
comment|// xyzzy aaa pot of gold -> xyzzy aaaa1 aaaa2 aaaa3 gold
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"xyzzy aaa pot of gold"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"xyzzy"
block|,
literal|"aaaa1"
block|,
literal|"aaaa2"
block|,
literal|"aaaa3"
block|,
literal|"pot"
block|,
literal|"of"
block|,
literal|"gold"
block|}
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testBuilderDedup
specifier|public
name|void
name|testBuilderDedup
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ab"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testBuilderNoDedup
specifier|public
name|void
name|testBuilderNoDedup
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ab"
block|,
literal|"ab"
block|,
literal|"ab"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testRecursion1
specifier|public
name|void
name|testRecursion1
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"zoo"
argument_list|,
literal|"zoo"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"zoo zoo $ zoo"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"$"
block|,
literal|"zoo"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testRecursion2
specifier|public
name|void
name|testRecursion2
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"zoo"
argument_list|,
literal|"zoo"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"zoo"
argument_list|,
literal|"zoo zoo"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// verify("zoo zoo $ zoo", "zoo/zoo zoo/zoo/zoo $/zoo zoo/zoo zoo");
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"zoo zoo $ zoo"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"$"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testRecursion3
specifier|public
name|void
name|testRecursion3
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|true
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"zoo zoo"
argument_list|,
literal|"zoo"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"zoo zoo $ zoo"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"$"
block|,
literal|"zoo"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testRecursion4
specifier|public
name|void
name|testRecursion4
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|true
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"zoo zoo"
argument_list|,
literal|"zoo"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"zoo"
argument_list|,
literal|"zoo zoo"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"zoo zoo $ zoo"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"$"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testKeepOrig
specifier|public
name|void
name|testKeepOrig
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|true
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a c"
argument_list|,
literal|"ac"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a"
argument_list|,
literal|"aa"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"b"
argument_list|,
literal|"bb"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"z x c v"
argument_list|,
literal|"zxcv"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"x c"
argument_list|,
literal|"xc"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"$"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aa"
block|,
literal|"a"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aa"
block|,
literal|"a"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"$ a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"$"
block|,
literal|"aa"
block|,
literal|"a"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a $"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aa"
block|,
literal|"a"
block|,
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"$ a !"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"$"
block|,
literal|"aa"
block|,
literal|"a"
block|,
literal|"!"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aa"
block|,
literal|"a"
block|,
literal|"aa"
block|,
literal|"a"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"bb"
block|,
literal|"b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"z x c v"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"zxcv"
block|,
literal|"z"
block|,
literal|"x"
block|,
literal|"c"
block|,
literal|"v"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"z x c $"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"z"
block|,
literal|"xc"
block|,
literal|"x"
block|,
literal|"c"
block|,
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * verify type of token and positionLengths on synonyms of different word counts, with non preserving, explicit rules.    */
DECL|method|testNonPreservingMultiwordSynonyms
specifier|public
name|void
name|testNonPreservingMultiwordSynonyms
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|testFile
init|=
literal|"aaa => two words\n"
operator|+
literal|"bbb => one two, very many multiple words\n"
operator|+
literal|"ee ff, gg, h i j k, h i => one\n"
operator|+
literal|"cc dd => usa,united states,u s a,united states of america"
decl_stmt|;
name|Analyzer
name|analyzer
init|=
name|solrSynsToAnalyzer
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"aaa"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"two"
block|,
literal|"words"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|3
block|,
literal|3
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesToPositions
argument_list|(
name|analyzer
argument_list|,
literal|"amazing aaa"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"amazing"
block|,
literal|"two"
block|,
literal|"words"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"p bbb s"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"p"
block|,
literal|"one"
block|,
literal|"very"
block|,
literal|"two"
block|,
literal|"many"
block|,
literal|"multiple"
block|,
literal|"words"
block|,
literal|"s"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|6
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"p ee ff s"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"p"
block|,
literal|"one"
block|,
literal|"s"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|8
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|7
block|,
literal|9
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"p h i j s"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"p"
block|,
literal|"one"
block|,
literal|"j"
block|,
literal|"s"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|,
literal|6
block|,
literal|8
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|5
block|,
literal|7
block|,
literal|9
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|getAnalyzer
specifier|private
name|Analyzer
name|getAnalyzer
parameter_list|(
name|SynonymMap
operator|.
name|Builder
name|b
parameter_list|,
specifier|final
name|boolean
name|ignoreCase
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|SynonymMap
name|map
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Make a local variable so testRandomHuge doesn't share it across threads!
name|SynonymGraphFilter
name|synFilter
init|=
operator|new
name|SynonymGraphFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
name|ignoreCase
argument_list|)
decl_stmt|;
name|TestSynonymGraphFilter
operator|.
name|this
operator|.
name|flattenFilter
operator|=
literal|null
expr_stmt|;
name|TestSynonymGraphFilter
operator|.
name|this
operator|.
name|synFilter
operator|=
name|synFilter
expr_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
name|synFilter
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Appends FlattenGraphFilter too */
DECL|method|getFlattenAnalyzer
specifier|private
name|Analyzer
name|getFlattenAnalyzer
parameter_list|(
name|SynonymMap
operator|.
name|Builder
name|b
parameter_list|,
name|boolean
name|ignoreCase
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|SynonymMap
name|map
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// Make a local variable so testRandomHuge doesn't share it across threads!
name|SynonymGraphFilter
name|synFilter
init|=
operator|new
name|SynonymGraphFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
name|ignoreCase
argument_list|)
decl_stmt|;
name|FlattenGraphFilter
name|flattenFilter
init|=
operator|new
name|FlattenGraphFilter
argument_list|(
name|synFilter
argument_list|)
decl_stmt|;
name|TestSynonymGraphFilter
operator|.
name|this
operator|.
name|synFilter
operator|=
name|synFilter
expr_stmt|;
name|TestSynonymGraphFilter
operator|.
name|this
operator|.
name|flattenFilter
operator|=
name|flattenFilter
expr_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
name|flattenFilter
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|add
specifier|private
name|void
name|add
parameter_list|(
name|SynonymMap
operator|.
name|Builder
name|b
parameter_list|,
name|String
name|input
parameter_list|,
name|String
name|output
parameter_list|,
name|boolean
name|keepOrig
parameter_list|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
comment|//System.out.println("  add input=" + input + " output=" + output + " keepOrig=" + keepOrig);
block|}
name|CharsRefBuilder
name|inputCharsRef
init|=
operator|new
name|CharsRefBuilder
argument_list|()
decl_stmt|;
name|SynonymMap
operator|.
name|Builder
operator|.
name|join
argument_list|(
name|input
operator|.
name|split
argument_list|(
literal|" +"
argument_list|)
argument_list|,
name|inputCharsRef
argument_list|)
expr_stmt|;
name|CharsRefBuilder
name|outputCharsRef
init|=
operator|new
name|CharsRefBuilder
argument_list|()
decl_stmt|;
name|SynonymMap
operator|.
name|Builder
operator|.
name|join
argument_list|(
name|output
operator|.
name|split
argument_list|(
literal|" +"
argument_list|)
argument_list|,
name|outputCharsRef
argument_list|)
expr_stmt|;
name|b
operator|.
name|add
argument_list|(
name|inputCharsRef
operator|.
name|get
argument_list|()
argument_list|,
name|outputCharsRef
operator|.
name|get
argument_list|()
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
block|}
DECL|method|randomBinaryChars
specifier|private
name|char
index|[]
name|randomBinaryChars
parameter_list|(
name|int
name|minLen
parameter_list|,
name|int
name|maxLen
parameter_list|,
name|double
name|bias
parameter_list|,
name|char
name|base
parameter_list|)
block|{
name|int
name|len
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
name|minLen
argument_list|,
name|maxLen
argument_list|)
decl_stmt|;
name|char
index|[]
name|chars
init|=
operator|new
name|char
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|<
name|bias
condition|)
block|{
name|ch
operator|=
name|base
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
call|(
name|char
call|)
argument_list|(
name|base
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|chars
index|[
name|i
index|]
operator|=
name|ch
expr_stmt|;
block|}
return|return
name|chars
return|;
block|}
DECL|method|toTokenString
specifier|private
specifier|static
name|String
name|toTokenString
parameter_list|(
name|char
index|[]
name|chars
parameter_list|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|char
name|c
range|:
name|chars
control|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|class|OneSyn
specifier|private
specifier|static
class|class
name|OneSyn
block|{
DECL|field|in
name|char
index|[]
name|in
decl_stmt|;
DECL|field|out
name|char
index|[]
name|out
decl_stmt|;
DECL|field|keepOrig
name|boolean
name|keepOrig
decl_stmt|;
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toTokenString
argument_list|(
name|in
argument_list|)
operator|+
literal|" --> "
operator|+
name|toTokenString
argument_list|(
name|out
argument_list|)
operator|+
literal|" (keepOrig="
operator|+
name|keepOrig
operator|+
literal|")"
return|;
block|}
block|}
DECL|method|testRandomSyns
specifier|public
name|void
name|testRandomSyns
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|synCount
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|double
name|bias
init|=
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
decl_stmt|;
name|boolean
name|dedup
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
name|boolean
name|flatten
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
name|dedup
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|OneSyn
argument_list|>
name|syns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Makes random syns from random a / b tokens, mapping to random x / y tokens
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: make "
operator|+
name|synCount
operator|+
literal|" syns"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  bias for a over b="
operator|+
name|bias
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  dedup="
operator|+
name|dedup
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  flatten="
operator|+
name|flatten
argument_list|)
expr_stmt|;
block|}
name|int
name|maxSynLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|synCount
condition|;
name|i
operator|++
control|)
block|{
name|OneSyn
name|syn
init|=
operator|new
name|OneSyn
argument_list|()
decl_stmt|;
name|syn
operator|.
name|in
operator|=
name|randomBinaryChars
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|,
name|bias
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
name|syn
operator|.
name|out
operator|=
name|randomBinaryChars
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|,
literal|0.5
argument_list|,
literal|'x'
argument_list|)
expr_stmt|;
name|syn
operator|.
name|keepOrig
operator|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
expr_stmt|;
name|syns
operator|.
name|add
argument_list|(
name|syn
argument_list|)
expr_stmt|;
name|maxSynLength
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxSynLength
argument_list|,
name|syn
operator|.
name|in
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|syn
argument_list|)
expr_stmt|;
block|}
name|add
argument_list|(
name|b
argument_list|,
name|toTokenString
argument_list|(
name|syn
operator|.
name|in
argument_list|)
argument_list|,
name|toTokenString
argument_list|(
name|syn
operator|.
name|out
argument_list|)
argument_list|,
name|syn
operator|.
name|keepOrig
argument_list|)
expr_stmt|;
block|}
comment|// Compute max allowed lookahead for flatten filter:
name|int
name|maxFlattenLookahead
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flatten
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|synCount
condition|;
name|i
operator|++
control|)
block|{
name|OneSyn
name|syn1
init|=
name|syns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|syn1
operator|.
name|out
operator|.
name|length
decl_stmt|;
name|boolean
name|keepOrig
init|=
name|syn1
operator|.
name|keepOrig
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|synCount
condition|;
name|j
operator|++
control|)
block|{
name|OneSyn
name|syn2
init|=
name|syns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|keepOrig
operator||=
name|syn2
operator|.
name|keepOrig
expr_stmt|;
if|if
condition|(
name|syn1
operator|.
name|in
operator|.
name|equals
argument_list|(
name|syn2
operator|.
name|in
argument_list|)
condition|)
block|{
name|count
operator|+=
name|syn2
operator|.
name|out
operator|.
name|length
expr_stmt|;
block|}
block|}
if|if
condition|(
name|keepOrig
condition|)
block|{
name|count
operator|+=
name|syn1
operator|.
name|in
operator|.
name|length
expr_stmt|;
block|}
name|maxFlattenLookahead
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxFlattenLookahead
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Only used w/ VERBOSE:
name|Analyzer
name|aNoFlattened
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|aNoFlattened
operator|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aNoFlattened
operator|=
literal|null
expr_stmt|;
block|}
name|Analyzer
name|a
decl_stmt|;
if|if
condition|(
name|flatten
condition|)
block|{
name|a
operator|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|getAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|int
name|iters
init|=
name|atLeast
argument_list|(
literal|20
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|iters
condition|;
name|iter
operator|++
control|)
block|{
name|String
name|doc
init|=
name|toTokenString
argument_list|(
name|randomBinaryChars
argument_list|(
literal|50
argument_list|,
literal|100
argument_list|,
name|bias
argument_list|,
literal|'a'
argument_list|)
argument_list|)
decl_stmt|;
comment|//String doc = toTokenString(randomBinaryChars(10, 50, bias, 'a'));
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: iter="
operator|+
name|iter
operator|+
literal|" doc="
operator|+
name|doc
argument_list|)
expr_stmt|;
block|}
name|Automaton
name|expected
init|=
name|slowSynFilter
argument_list|(
name|doc
argument_list|,
name|syns
argument_list|,
name|flatten
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  expected:\n"
operator|+
name|expected
operator|.
name|toDot
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|flatten
condition|)
block|{
name|Automaton
name|unflattened
init|=
name|toAutomaton
argument_list|(
name|aNoFlattened
operator|.
name|tokenStream
argument_list|(
literal|"field"
argument_list|,
operator|new
name|StringReader
argument_list|(
name|doc
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  actual unflattened:\n"
operator|+
name|unflattened
operator|.
name|toDot
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Automaton
name|actual
init|=
name|toAutomaton
argument_list|(
name|a
operator|.
name|tokenStream
argument_list|(
literal|"field"
argument_list|,
operator|new
name|StringReader
argument_list|(
name|doc
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  actual:\n"
operator|+
name|actual
operator|.
name|toDot
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
literal|"maxLookaheadUsed="
operator|+
name|synFilter
operator|.
name|getMaxLookaheadUsed
argument_list|()
operator|+
literal|" maxSynLength="
operator|+
name|maxSynLength
argument_list|,
name|synFilter
operator|.
name|getMaxLookaheadUsed
argument_list|()
operator|<=
name|maxSynLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|flatten
condition|)
block|{
name|assertTrue
argument_list|(
literal|"flatten maxLookaheadUsed="
operator|+
name|flattenFilter
operator|.
name|getMaxLookaheadUsed
argument_list|()
operator|+
literal|" maxFlattenLookahead="
operator|+
name|maxFlattenLookahead
argument_list|,
name|flattenFilter
operator|.
name|getMaxLookaheadUsed
argument_list|()
operator|<=
name|maxFlattenLookahead
argument_list|)
expr_stmt|;
block|}
name|checkAnalysisConsistency
argument_list|(
name|random
argument_list|()
argument_list|,
name|a
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|// We can easily have a non-deterministic automaton at this point, e.g. if
comment|// more than one syn matched at given point, or if the syn mapped to an
comment|// output token that also happens to be in the input:
try|try
block|{
name|actual
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|actual
argument_list|,
literal|50000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TooComplexToDeterminizeException
name|tctde
parameter_list|)
block|{
comment|// Unfortunately the syns can easily create difficult-to-determinize graphs:
name|assertTrue
argument_list|(
name|approxEquals
argument_list|(
name|actual
argument_list|,
name|expected
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
try|try
block|{
name|expected
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|expected
argument_list|,
literal|50000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TooComplexToDeterminizeException
name|tctde
parameter_list|)
block|{
comment|// Unfortunately the syns can easily create difficult-to-determinize graphs:
name|assertTrue
argument_list|(
name|approxEquals
argument_list|(
name|actual
argument_list|,
name|expected
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|assertTrue
argument_list|(
name|approxEquals
argument_list|(
name|actual
argument_list|,
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|sameLanguage
argument_list|(
name|actual
argument_list|,
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Only used when true equality is too costly to check! */
DECL|method|approxEquals
specifier|private
name|boolean
name|approxEquals
parameter_list|(
name|Automaton
name|actual
parameter_list|,
name|Automaton
name|expected
parameter_list|)
block|{
comment|// Don't collapse these into one line else the thread stack won't say which direction failed!:
name|boolean
name|b1
init|=
name|approxSubsetOf
argument_list|(
name|actual
argument_list|,
name|expected
argument_list|)
decl_stmt|;
name|boolean
name|b2
init|=
name|approxSubsetOf
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
decl_stmt|;
return|return
name|b1
operator|&&
name|b2
return|;
block|}
DECL|method|approxSubsetOf
specifier|private
name|boolean
name|approxSubsetOf
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
name|AutomatonTestUtil
operator|.
name|RandomAcceptedStrings
name|ras
init|=
operator|new
name|AutomatonTestUtil
operator|.
name|RandomAcceptedStrings
argument_list|(
name|a1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2000
condition|;
name|i
operator|++
control|)
block|{
name|int
index|[]
name|ints
init|=
name|ras
operator|.
name|getRandomAcceptedString
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|IntsRef
name|path
init|=
operator|new
name|IntsRef
argument_list|(
name|ints
argument_list|,
literal|0
argument_list|,
name|ints
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|accepts
argument_list|(
name|a2
argument_list|,
name|path
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"a2 does not accept "
operator|+
name|path
argument_list|)
throw|;
block|}
block|}
comment|// Presumed true
return|return
literal|true
return|;
block|}
comment|/** Like {@link Operations#run} except the incoming automaton is allowed to be non-deterministic. */
DECL|method|accepts
specifier|private
specifier|static
name|boolean
name|accepts
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|IntsRef
name|path
parameter_list|)
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|states
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|states
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|digit
init|=
name|path
operator|.
name|ints
index|[
name|path
operator|.
name|offset
operator|+
name|i
index|]
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|nextStates
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|state
range|:
name|states
control|)
block|{
name|int
name|count
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|state
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
name|t
operator|.
name|min
operator|&&
name|digit
operator|<=
name|t
operator|.
name|max
condition|)
block|{
name|nextStates
operator|.
name|add
argument_list|(
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|states
operator|=
name|nextStates
expr_stmt|;
if|if
condition|(
name|states
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
for|for
control|(
name|int
name|state
range|:
name|states
control|)
block|{
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Stupid, slow brute-force, yet hopefully bug-free, synonym filter. */
DECL|method|slowSynFilter
specifier|private
name|Automaton
name|slowSynFilter
parameter_list|(
name|String
name|doc
parameter_list|,
name|List
argument_list|<
name|OneSyn
argument_list|>
name|syns
parameter_list|,
name|boolean
name|flatten
parameter_list|)
block|{
name|String
index|[]
name|tokens
init|=
name|doc
operator|.
name|split
argument_list|(
literal|" +"
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  doc has "
operator|+
name|tokens
operator|.
name|length
operator|+
literal|" tokens"
argument_list|)
expr_stmt|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Automaton
operator|.
name|Builder
name|a
init|=
operator|new
name|Automaton
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|int
name|lastState
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|tokens
operator|.
name|length
condition|)
block|{
comment|// Consider all possible syn matches starting at this point:
assert|assert
name|tokens
index|[
name|i
index|]
operator|.
name|length
argument_list|()
operator|==
literal|1
assert|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    i="
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|OneSyn
argument_list|>
name|matches
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|OneSyn
name|syn
range|:
name|syns
control|)
block|{
if|if
condition|(
name|i
operator|+
name|syn
operator|.
name|in
operator|.
name|length
operator|<=
name|tokens
operator|.
name|length
condition|)
block|{
name|boolean
name|match
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|syn
operator|.
name|in
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|tokens
index|[
name|i
operator|+
name|j
index|]
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
name|syn
operator|.
name|in
index|[
name|j
index|]
condition|)
block|{
name|match
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|match
condition|)
block|{
if|if
condition|(
name|matches
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|syn
operator|.
name|in
operator|.
name|length
operator|<
name|matches
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|in
operator|.
name|length
condition|)
block|{
comment|// Greedy matching: we already found longer syns matching here
continue|continue;
block|}
elseif|else
if|if
condition|(
name|syn
operator|.
name|in
operator|.
name|length
operator|>
name|matches
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|in
operator|.
name|length
condition|)
block|{
comment|// Greedy matching: all previous matches were shorter, so we drop them
name|matches
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Keep the current matches: we allow multiple synonyms matching the same input string
block|}
block|}
name|matches
operator|.
name|add
argument_list|(
name|syn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|int
name|nextState
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
if|if
condition|(
name|matches
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// We have match(es) starting at this token
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  matches @ i="
operator|+
name|i
operator|+
literal|": "
operator|+
name|matches
argument_list|)
expr_stmt|;
block|}
comment|// We keepOrig if any of the matches said to:
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
for|for
control|(
name|OneSyn
name|syn
range|:
name|matches
control|)
block|{
name|keepOrig
operator||=
name|syn
operator|.
name|keepOrig
expr_stmt|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|flatStates
decl_stmt|;
if|if
condition|(
name|flatten
condition|)
block|{
name|flatStates
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|flatStates
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|keepOrig
condition|)
block|{
comment|// Add path for the original tokens
name|addSidePath
argument_list|(
name|a
argument_list|,
name|lastState
argument_list|,
name|nextState
argument_list|,
name|matches
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|in
argument_list|,
name|flatStates
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|OneSyn
name|syn
range|:
name|matches
control|)
block|{
name|addSidePath
argument_list|(
name|a
argument_list|,
name|lastState
argument_list|,
name|nextState
argument_list|,
name|syn
operator|.
name|out
argument_list|,
name|flatStates
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
name|matches
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|in
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|a
operator|.
name|addTransition
argument_list|(
name|lastState
argument_list|,
name|nextState
argument_list|,
name|tokens
index|[
name|i
index|]
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|lastState
operator|=
name|nextState
expr_stmt|;
block|}
name|a
operator|.
name|setAccept
argument_list|(
name|lastState
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|topoSort
argument_list|(
name|a
operator|.
name|finish
argument_list|()
argument_list|)
return|;
block|}
comment|/** Just creates a side path from startState to endState with the provided tokens. */
DECL|method|addSidePath
specifier|private
specifier|static
name|void
name|addSidePath
parameter_list|(
name|Automaton
operator|.
name|Builder
name|a
parameter_list|,
name|int
name|startState
parameter_list|,
name|int
name|endState
parameter_list|,
name|char
index|[]
name|tokens
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|flatStates
parameter_list|)
block|{
name|int
name|lastState
init|=
name|startState
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tokens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nextState
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|tokens
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|nextState
operator|=
name|endState
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flatStates
operator|==
literal|null
operator|||
name|i
operator|>=
name|flatStates
operator|.
name|size
argument_list|()
condition|)
block|{
name|nextState
operator|=
name|a
operator|.
name|createState
argument_list|()
expr_stmt|;
if|if
condition|(
name|flatStates
operator|!=
literal|null
condition|)
block|{
assert|assert
name|i
operator|==
name|flatStates
operator|.
name|size
argument_list|()
assert|;
name|flatStates
operator|.
name|add
argument_list|(
name|nextState
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nextState
operator|=
name|flatStates
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|a
operator|.
name|addTransition
argument_list|(
name|lastState
argument_list|,
name|nextState
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lastState
operator|=
name|nextState
expr_stmt|;
block|}
block|}
DECL|method|toAutomaton
specifier|private
name|Automaton
name|toAutomaton
parameter_list|(
name|TokenStream
name|ts
parameter_list|)
throws|throws
name|IOException
block|{
name|PositionIncrementAttribute
name|posIncAtt
init|=
name|ts
operator|.
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|PositionLengthAttribute
name|posLenAtt
init|=
name|ts
operator|.
name|addAttribute
argument_list|(
name|PositionLengthAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|CharTermAttribute
name|termAtt
init|=
name|ts
operator|.
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|ts
operator|.
name|reset
argument_list|()
expr_stmt|;
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|srcNode
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|destNode
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|state
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
while|while
condition|(
name|ts
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
assert|assert
name|termAtt
operator|.
name|length
argument_list|()
operator|==
literal|1
assert|;
name|char
name|c
init|=
name|termAtt
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|posInc
init|=
name|posIncAtt
operator|.
name|getPositionIncrement
argument_list|()
decl_stmt|;
if|if
condition|(
name|posInc
operator|!=
literal|0
condition|)
block|{
name|srcNode
operator|+=
name|posInc
expr_stmt|;
while|while
condition|(
name|state
operator|<
name|srcNode
condition|)
block|{
name|state
operator|=
name|a
operator|.
name|createState
argument_list|()
expr_stmt|;
block|}
block|}
name|destNode
operator|=
name|srcNode
operator|+
name|posLenAtt
operator|.
name|getPositionLength
argument_list|()
expr_stmt|;
while|while
condition|(
name|state
operator|<
name|destNode
condition|)
block|{
name|state
operator|=
name|a
operator|.
name|createState
argument_list|()
expr_stmt|;
block|}
name|a
operator|.
name|addTransition
argument_list|(
name|srcNode
argument_list|,
name|destNode
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|ts
operator|.
name|end
argument_list|()
expr_stmt|;
name|ts
operator|.
name|close
argument_list|()
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|a
operator|.
name|setAccept
argument_list|(
name|destNode
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/*   private String toDot(TokenStream ts) throws IOException {     PositionIncrementAttribute posIncAtt = ts.addAttribute(PositionIncrementAttribute.class);     PositionLengthAttribute posLenAtt = ts.addAttribute(PositionLengthAttribute.class);     CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class);     TypeAttribute typeAtt = ts.addAttribute(TypeAttribute.class);     ts.reset();     int srcNode = -1;     int destNode = -1;      StringBuilder b = new StringBuilder();     b.append("digraph Automaton {\n");     b.append("  rankdir = LR\n");     b.append("  node [width=0.2, height=0.2, fontsize=8]\n");     b.append("  initial [shape=plaintext,label=\"\"]\n");     b.append("  initial -> 0\n");      while (ts.incrementToken()) {       int posInc = posIncAtt.getPositionIncrement();       if (posInc != 0) {         srcNode += posInc;         b.append("  ");         b.append(srcNode);         b.append(" [shape=circle,label=\"" + srcNode + "\"]\n");       }       destNode = srcNode + posLenAtt.getPositionLength();       b.append("  ");       b.append(srcNode);       b.append(" -> ");       b.append(destNode);       b.append(" [label=\"");       b.append(termAtt);       b.append("\"");       if (typeAtt.type().equals("word") == false) {         b.append(" color=red");       }       b.append("]\n");     }     ts.end();     ts.close();      b.append('}');     return b.toString();   }   */
comment|/** Renumbers nodes according to their topo sort */
DECL|method|topoSort
specifier|private
name|Automaton
name|topoSort
parameter_list|(
name|Automaton
name|in
parameter_list|)
block|{
name|int
index|[]
name|newToOld
init|=
name|Operations
operator|.
name|topoSortStates
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|int
index|[]
name|oldToNew
init|=
operator|new
name|int
index|[
name|newToOld
operator|.
name|length
index|]
decl_stmt|;
name|Automaton
operator|.
name|Builder
name|a
init|=
operator|new
name|Automaton
operator|.
name|Builder
argument_list|()
decl_stmt|;
comment|//System.out.println("remap:");
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newToOld
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|createState
argument_list|()
expr_stmt|;
name|oldToNew
index|[
name|newToOld
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
comment|//System.out.println("  " + newToOld[i] + " -> " + i);
if|if
condition|(
name|in
operator|.
name|isAccept
argument_list|(
name|newToOld
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|a
operator|.
name|setAccept
argument_list|(
name|i
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//System.out.println("    **");
block|}
block|}
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newToOld
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|count
init|=
name|in
operator|.
name|initTransition
argument_list|(
name|newToOld
index|[
name|i
index|]
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
block|{
name|in
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|i
argument_list|,
name|oldToNew
index|[
name|t
operator|.
name|dest
index|]
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|a
operator|.
name|finish
argument_list|()
return|;
block|}
comment|/**    * verify type of token and positionLengths on synonyms of different word counts.    */
DECL|method|testPositionLengthAndType
specifier|public
name|void
name|testPositionLengthAndType
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|testFile
init|=
literal|"spider man, spiderman\n"
operator|+
literal|"usa,united states,u s a,united states of america"
decl_stmt|;
name|Analyzer
name|analyzer
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|SolrSynonymParser
name|parser
init|=
operator|new
name|SolrSynonymParser
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
name|analyzer
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|(
operator|new
name|StringReader
argument_list|(
name|testFile
argument_list|)
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
name|SynonymMap
name|map
init|=
name|parser
operator|.
name|build
argument_list|()
decl_stmt|;
name|analyzer
operator|=
name|getFlattenAnalyzer
argument_list|(
name|parser
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|BytesRef
name|value
init|=
name|Util
operator|.
name|get
argument_list|(
name|map
operator|.
name|fst
argument_list|,
name|Util
operator|.
name|toUTF32
argument_list|(
operator|new
name|CharsRef
argument_list|(
literal|"usa"
argument_list|)
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|ByteArrayDataInput
name|bytesReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|(
name|value
operator|.
name|bytes
argument_list|,
name|value
operator|.
name|offset
argument_list|,
name|value
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|int
name|code
init|=
name|bytesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|code
operator|>>>
literal|1
decl_stmt|;
specifier|final
name|int
index|[]
name|synonymsIdxs
init|=
operator|new
name|int
index|[
name|count
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|synonymsIdxs
index|[
name|i
index|]
operator|=
name|bytesReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
name|BytesRef
name|scratchBytes
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|map
operator|.
name|words
operator|.
name|get
argument_list|(
name|synonymsIdxs
index|[
literal|2
index|]
argument_list|,
name|scratchBytes
argument_list|)
expr_stmt|;
name|int
name|synonymLength
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|scratchBytes
operator|.
name|offset
init|;
name|i
operator|<
name|scratchBytes
operator|.
name|offset
operator|+
name|scratchBytes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|scratchBytes
operator|.
name|bytes
index|[
name|i
index|]
operator|==
name|SynonymMap
operator|.
name|WORD_SEPARATOR
condition|)
block|{
name|synonymLength
operator|++
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|count
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|synonymLength
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"spider man"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"spiderman"
block|,
literal|"spider"
block|,
literal|"man"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|7
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|10
block|,
literal|6
block|,
literal|10
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|2
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesToPositions
argument_list|(
name|analyzer
argument_list|,
literal|"amazing spider man"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"amazing"
block|,
literal|"spiderman"
block|,
literal|"spider"
block|,
literal|"man"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
comment|// System.out.println(toDot(getAnalyzer(parser, true).tokenStream("field", new StringReader("the usa is wealthy"))));
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"the united states of america is wealthy"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"the"
block|,
literal|"usa"
block|,
literal|"united"
block|,
literal|"u"
block|,
literal|"united"
block|,
literal|"states"
block|,
literal|"s"
block|,
literal|"states"
block|,
literal|"a"
block|,
literal|"of"
block|,
literal|"america"
block|,
literal|"is"
block|,
literal|"wealthy"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|18
block|,
literal|18
block|,
literal|21
block|,
literal|29
block|,
literal|32
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|3
block|,
literal|28
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|28
block|,
literal|17
block|,
literal|17
block|,
literal|28
block|,
literal|20
block|,
literal|28
block|,
literal|31
block|,
literal|39
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|4
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesToPositions
argument_list|(
name|analyzer
argument_list|,
literal|"spiderman"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"spider"
block|,
literal|"spiderman"
block|,
literal|"man"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"SYNONYM"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"spiderman enemies"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"spider"
block|,
literal|"spiderman"
block|,
literal|"man"
block|,
literal|"enemies"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|17
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"the usa is wealthy"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"the"
block|,
literal|"united"
block|,
literal|"u"
block|,
literal|"united"
block|,
literal|"usa"
block|,
literal|"states"
block|,
literal|"s"
block|,
literal|"states"
block|,
literal|"a"
block|,
literal|"of"
block|,
literal|"america"
block|,
literal|"is"
block|,
literal|"wealthy"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|11
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|3
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|10
block|,
literal|18
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertGraphStrings
argument_list|(
name|analyzer
argument_list|,
literal|"the usa is wealthy"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"the usa is wealthy"
block|,
literal|"the united states is wealthy"
block|,
literal|"the u s a is wealthy"
block|,
literal|"the united states of america is wealthy"
block|,
comment|// Wrong. Here only due to "sausagization" of the multi word synonyms.
literal|"the u states is wealthy"
block|,
literal|"the u states a is wealthy"
block|,
literal|"the u s of america is wealthy"
block|,
literal|"the u states of america is wealthy"
block|,
literal|"the united s a is wealthy"
block|,
literal|"the united states a is wealthy"
block|,
literal|"the united s of america is wealthy"
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"the united states is wealthy"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"the"
block|,
literal|"usa"
block|,
literal|"u"
block|,
literal|"united"
block|,
literal|"united"
block|,
literal|"s"
block|,
literal|"states"
block|,
literal|"states"
block|,
literal|"a"
block|,
literal|"of"
block|,
literal|"america"
block|,
literal|"is"
block|,
literal|"wealthy"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|18
block|,
literal|21
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|3
block|,
literal|17
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|20
block|,
literal|28
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|4
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"the united states of balance"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"the"
block|,
literal|"usa"
block|,
literal|"u"
block|,
literal|"united"
block|,
literal|"united"
block|,
literal|"s"
block|,
literal|"states"
block|,
literal|"states"
block|,
literal|"a"
block|,
literal|"of"
block|,
literal|"america"
block|,
literal|"of"
block|,
literal|"balance"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|18
block|,
literal|21
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|3
block|,
literal|17
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|20
block|,
literal|28
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"SYNONYM"
block|,
literal|"word"
block|,
literal|"word"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|4
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testMultiwordOffsets
specifier|public
name|void
name|testMultiwordOffsets
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|true
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"national hockey league"
argument_list|,
literal|"nhl"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"national hockey league"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"nhl"
block|,
literal|"national"
block|,
literal|"hockey"
block|,
literal|"league"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|9
block|,
literal|16
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|22
block|,
literal|8
block|,
literal|15
block|,
literal|22
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testIncludeOrig
specifier|public
name|void
name|testIncludeOrig
parameter_list|()
throws|throws
name|Exception
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|true
decl_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a c"
argument_list|,
literal|"ac"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"a"
argument_list|,
literal|"aa"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"b"
argument_list|,
literal|"bb"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"z x c v"
argument_list|,
literal|"zxcv"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|b
argument_list|,
literal|"x c"
argument_list|,
literal|"xc"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|Analyzer
name|a
init|=
name|getFlattenAnalyzer
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"$"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aa"
block|,
literal|"a"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aa"
block|,
literal|"a"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"$ a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"$"
block|,
literal|"aa"
block|,
literal|"a"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a $"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aa"
block|,
literal|"a"
block|,
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"$ a !"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"$"
block|,
literal|"aa"
block|,
literal|"a"
block|,
literal|"!"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aa"
block|,
literal|"a"
block|,
literal|"aa"
block|,
literal|"a"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"bb"
block|,
literal|"b"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"z x c v"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"zxcv"
block|,
literal|"z"
block|,
literal|"x"
block|,
literal|"c"
block|,
literal|"v"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"z x c $"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"z"
block|,
literal|"xc"
block|,
literal|"x"
block|,
literal|"c"
block|,
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|a
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testUpperCase
specifier|public
name|void
name|testUpperCase
parameter_list|()
throws|throws
name|IOException
block|{
name|assertMapping
argument_list|(
literal|"word"
argument_list|,
literal|"synonym"
argument_list|)
expr_stmt|;
name|assertMapping
argument_list|(
literal|"word"
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|,
literal|"synonym"
argument_list|)
expr_stmt|;
block|}
DECL|method|assertMapping
specifier|private
name|void
name|assertMapping
parameter_list|(
name|String
name|inputString
parameter_list|,
name|String
name|outputString
parameter_list|)
throws|throws
name|IOException
block|{
name|SynonymMap
operator|.
name|Builder
name|builder
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// the rules must be lowercased up front, but the incoming tokens will be case insensitive:
name|CharsRef
name|input
init|=
name|SynonymMap
operator|.
name|Builder
operator|.
name|join
argument_list|(
name|inputString
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
argument_list|,
operator|new
name|CharsRefBuilder
argument_list|()
argument_list|)
decl_stmt|;
name|CharsRef
name|output
init|=
name|SynonymMap
operator|.
name|Builder
operator|.
name|join
argument_list|(
name|outputString
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
argument_list|,
operator|new
name|CharsRefBuilder
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|input
argument_list|,
name|output
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Analyzer
name|analyzer
init|=
operator|new
name|CustomAnalyzer
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|TokenStream
name|tokenStream
init|=
name|analyzer
operator|.
name|tokenStream
argument_list|(
literal|"field"
argument_list|,
name|inputString
argument_list|)
decl_stmt|;
name|assertTokenStreamContents
argument_list|(
name|tokenStream
argument_list|,
operator|new
name|String
index|[]
block|{
name|outputString
block|,
name|inputString
block|}
argument_list|)
expr_stmt|;
block|}
DECL|class|CustomAnalyzer
specifier|static
class|class
name|CustomAnalyzer
extends|extends
name|Analyzer
block|{
DECL|field|synonymMap
specifier|private
name|SynonymMap
name|synonymMap
decl_stmt|;
DECL|method|CustomAnalyzer
name|CustomAnalyzer
parameter_list|(
name|SynonymMap
name|synonymMap
parameter_list|)
block|{
name|this
operator|.
name|synonymMap
operator|=
name|synonymMap
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createComponents
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|TokenStream
name|tokenStream
init|=
operator|new
name|SynonymGraphFilter
argument_list|(
name|tokenizer
argument_list|,
name|synonymMap
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// Ignore case True
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
name|tokenStream
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

