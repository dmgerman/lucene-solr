begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.search.uhighlight
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|uhighlight
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|highlight
operator|.
name|WeightedSpanTerm
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|highlight
operator|.
name|WeightedSpanTermExtractor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|spans
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_comment
comment|/**  * Helps the {@link FieldOffsetStrategy} with strict position highlighting (e.g. highlight phrases correctly).  * This is a stateful class holding information about the query, but it can (and is) re-used across highlighting  * documents.  Despite this state; it's immutable after construction.  The approach taken in this class is very similar  * to the standard Highlighter's {@link WeightedSpanTermExtractor} which is in fact re-used here.  However, we ought to  * completely rewrite it to use the SpanCollector interface to collect offsets directly. We'll get better  * phrase accuracy.  *  * @lucene.internal  */
end_comment

begin_class
DECL|class|PhraseHelper
specifier|public
class|class
name|PhraseHelper
block|{
DECL|field|NONE
specifier|public
specifier|static
specifier|final
name|PhraseHelper
name|NONE
init|=
operator|new
name|PhraseHelper
argument_list|(
operator|new
name|MatchAllDocsQuery
argument_list|()
argument_list|,
literal|"_ignored_"
argument_list|,
name|spanQuery
lambda|->
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|//TODO it seems this ought to be a general thing on Spans?
DECL|field|SPANS_COMPARATOR
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|Spans
argument_list|>
name|SPANS_COMPARATOR
init|=
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
block|{
name|int
name|cmp
init|=
name|Integer
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|docID
argument_list|()
argument_list|,
name|o2
operator|.
name|docID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
if|if
condition|(
name|o1
operator|.
name|docID
argument_list|()
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
return|return
literal|0
return|;
comment|// don't ask for start/end position; not sure if we can even call those methods
block|}
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|startPosition
argument_list|()
argument_list|,
name|o2
operator|.
name|startPosition
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
else|else
block|{
return|return
name|Integer
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|endPosition
argument_list|()
argument_list|,
name|o2
operator|.
name|endPosition
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|fieldName
specifier|private
specifier|final
name|String
name|fieldName
decl_stmt|;
comment|// if non-null, only look at queries/terms for this field
DECL|field|positionInsensitiveTerms
specifier|private
specifier|final
name|Set
argument_list|<
name|Term
argument_list|>
name|positionInsensitiveTerms
decl_stmt|;
comment|// (TermQuery terms)
DECL|field|spanQueries
specifier|private
specifier|final
name|Set
argument_list|<
name|SpanQuery
argument_list|>
name|spanQueries
decl_stmt|;
DECL|field|willRewrite
specifier|private
specifier|final
name|boolean
name|willRewrite
decl_stmt|;
comment|/**    * Constructor.    * {@code rewriteQueryPred} is an extension hook to override the default choice of    * {@link WeightedSpanTermExtractor#mustRewriteQuery(SpanQuery)}. By default unknown query types are rewritten,    * so use this to return {@link Boolean#FALSE} if you know the query doesn't need to be rewritten.    * {@code ignoreQueriesNeedingRewrite} effectively ignores any query clause that needs to be "rewritten", which is    * usually limited to just a {@link SpanMultiTermQueryWrapper} but could be other custom ones.    */
DECL|method|PhraseHelper
specifier|public
name|PhraseHelper
parameter_list|(
name|Query
name|query
parameter_list|,
name|String
name|field
parameter_list|,
name|Function
argument_list|<
name|SpanQuery
argument_list|,
name|Boolean
argument_list|>
name|rewriteQueryPred
parameter_list|,
name|boolean
name|ignoreQueriesNeedingRewrite
parameter_list|)
block|{
name|this
operator|.
name|fieldName
operator|=
name|field
expr_stmt|;
comment|// if null then don't require field match
comment|// filter terms to those we want
name|positionInsensitiveTerms
operator|=
name|field
operator|!=
literal|null
condition|?
operator|new
name|FieldFilteringTermHashSet
argument_list|(
name|field
argument_list|)
else|:
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
comment|// requireFieldMatch optional
name|spanQueries
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
comment|// TODO Have toSpanQuery(query) Function as an extension point for those with custom Query impls
name|boolean
index|[]
name|mustRewriteHolder
init|=
block|{
literal|false
block|}
decl_stmt|;
comment|// boolean wrapped in 1-ary array so it's mutable from inner class
comment|// For TermQueries or other position insensitive queries, collect the Terms.
comment|// For other Query types, WSTE will convert to an equivalent SpanQuery.  NOT extracting position spans here.
operator|new
name|WeightedSpanTermExtractor
argument_list|(
name|field
argument_list|)
block|{
comment|//anonymous constructor
block|{
name|setExpandMultiTermQuery
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//necessary for mustRewriteQuery(spanQuery) to work.
try|try
block|{
name|extract
argument_list|(
name|query
argument_list|,
literal|1f
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// null because we won't actually extract right now; we're not collecting
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|isQueryUnsupported
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Query
argument_list|>
name|clazz
parameter_list|)
block|{
if|if
condition|(
name|clazz
operator|.
name|isAssignableFrom
argument_list|(
name|MultiTermQuery
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|//We do MTQ processing separately in MultiTermHighlighting.java
block|}
return|return
literal|true
return|;
comment|//TODO set to false and provide a hook to customize certain queries.
block|}
annotation|@
name|Override
specifier|protected
name|void
name|extractWeightedTerms
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|WeightedSpanTerm
argument_list|>
name|terms
parameter_list|,
name|Query
name|query
parameter_list|,
name|float
name|boost
parameter_list|)
throws|throws
name|IOException
block|{
name|query
operator|.
name|createWeight
argument_list|(
name|UnifiedHighlighter
operator|.
name|EMPTY_INDEXSEARCHER
argument_list|,
literal|false
argument_list|,
name|boost
argument_list|)
operator|.
name|extractTerms
argument_list|(
name|positionInsensitiveTerms
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|extractWeightedSpanTerms
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|WeightedSpanTerm
argument_list|>
name|terms
parameter_list|,
name|SpanQuery
name|spanQuery
parameter_list|,
name|float
name|boost
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
comment|// if this span query isn't for this field, skip it.
name|Set
argument_list|<
name|String
argument_list|>
name|fieldNameSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|//TODO reuse.  note: almost always size 1
name|collectSpanQueryFields
argument_list|(
name|spanQuery
argument_list|,
name|fieldNameSet
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fieldNameSet
operator|.
name|contains
argument_list|(
name|field
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
comment|// TODO allow users to override the answer to mustRewriteQuery
name|boolean
name|mustRewriteQuery
init|=
name|mustRewriteQuery
argument_list|(
name|spanQuery
argument_list|)
decl_stmt|;
if|if
condition|(
name|ignoreQueriesNeedingRewrite
operator|&&
name|mustRewriteQuery
condition|)
block|{
return|return;
comment|// ignore this query
block|}
name|mustRewriteHolder
index|[
literal|0
index|]
operator||=
name|mustRewriteQuery
expr_stmt|;
name|spanQueries
operator|.
name|add
argument_list|(
name|spanQuery
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|mustRewriteQuery
parameter_list|(
name|SpanQuery
name|spanQuery
parameter_list|)
block|{
name|Boolean
name|rewriteQ
init|=
name|rewriteQueryPred
operator|.
name|apply
argument_list|(
name|spanQuery
argument_list|)
decl_stmt|;
comment|// allow to override
return|return
name|rewriteQ
operator|!=
literal|null
condition|?
name|rewriteQ
else|:
name|super
operator|.
name|mustRewriteQuery
argument_list|(
name|spanQuery
argument_list|)
return|;
block|}
block|}
expr_stmt|;
comment|// calling the constructor triggered the extraction/visiting we want.  Hacky; yes.
name|willRewrite
operator|=
name|mustRewriteHolder
index|[
literal|0
index|]
expr_stmt|;
block|}
DECL|method|getSpanQueries
name|Set
argument_list|<
name|SpanQuery
argument_list|>
name|getSpanQueries
parameter_list|()
block|{
return|return
name|spanQueries
return|;
block|}
comment|/**    * If there is no position sensitivity then use of the instance of this class can be ignored.    */
DECL|method|hasPositionSensitivity
name|boolean
name|hasPositionSensitivity
parameter_list|()
block|{
return|return
name|spanQueries
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
return|;
block|}
comment|/**    * Rewrite is needed for handling a {@link SpanMultiTermQueryWrapper} (MTQ / wildcards) or some    * custom things.  When true, the resulting term list will probably be different than what it was known    * to be initially.    */
DECL|method|willRewrite
name|boolean
name|willRewrite
parameter_list|()
block|{
return|return
name|willRewrite
return|;
block|}
comment|/**    * Collect a list of pre-positioned {@link Spans} for each term, given a reader that has just one document.    * It returns no mapping for query terms that occurs in a position insensitive way which therefore don't    * need to be filtered.    */
DECL|method|getTermToSpans
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|Spans
argument_list|>
name|getTermToSpans
parameter_list|(
name|LeafReader
name|leafReader
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|spanQueries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
comment|// for each SpanQuery, collect the member spans into a map.
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|Spans
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SpanQuery
name|spanQuery
range|:
name|spanQueries
control|)
block|{
name|getTermToSpans
argument_list|(
name|spanQuery
argument_list|,
name|leafReader
operator|.
name|getContext
argument_list|()
argument_list|,
name|doc
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|// code extracted& refactored from WSTE.extractWeightedSpanTerms()
DECL|method|getTermToSpans
specifier|private
name|void
name|getTermToSpans
parameter_list|(
name|SpanQuery
name|spanQuery
parameter_list|,
name|LeafReaderContext
name|readerContext
parameter_list|,
name|int
name|doc
parameter_list|,
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|Spans
argument_list|>
name|result
parameter_list|)
throws|throws
name|IOException
block|{
comment|// note: in WSTE there was some field specific looping that seemed pointless so that isn't here.
specifier|final
name|IndexSearcher
name|searcher
init|=
operator|new
name|IndexSearcher
argument_list|(
name|readerContext
argument_list|)
decl_stmt|;
name|searcher
operator|.
name|setQueryCache
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|willRewrite
condition|)
block|{
name|spanQuery
operator|=
operator|(
name|SpanQuery
operator|)
name|searcher
operator|.
name|rewrite
argument_list|(
name|spanQuery
argument_list|)
expr_stmt|;
comment|// searcher.rewrite loops till done
block|}
comment|// Get the underlying query terms
name|TreeSet
argument_list|<
name|Term
argument_list|>
name|termSet
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// sorted so we can loop over results in order shortly...
name|searcher
operator|.
name|createWeight
argument_list|(
name|spanQuery
argument_list|,
literal|false
argument_list|,
literal|1.0f
argument_list|)
operator|.
name|extractTerms
argument_list|(
name|termSet
argument_list|)
expr_stmt|;
comment|//needsScores==false
comment|// Get Spans by running the query against the reader
comment|// TODO it might make sense to re-use/cache the Spans instance, to advance forward between docs
name|SpanWeight
name|spanWeight
init|=
operator|(
name|SpanWeight
operator|)
name|searcher
operator|.
name|createNormalizedWeight
argument_list|(
name|spanQuery
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Spans
name|spans
init|=
name|spanWeight
operator|.
name|getSpans
argument_list|(
name|readerContext
argument_list|,
name|SpanWeight
operator|.
name|Postings
operator|.
name|POSITIONS
argument_list|)
decl_stmt|;
if|if
condition|(
name|spans
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|TwoPhaseIterator
name|twoPhaseIterator
init|=
name|spans
operator|.
name|asTwoPhaseIterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|twoPhaseIterator
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|twoPhaseIterator
operator|.
name|approximation
argument_list|()
operator|.
name|advance
argument_list|(
name|doc
argument_list|)
operator|!=
name|doc
operator|||
operator|!
name|twoPhaseIterator
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|spans
operator|.
name|advance
argument_list|(
name|doc
argument_list|)
operator|!=
name|doc
condition|)
block|{
comment|// preposition, and return doing nothing if find none
return|return;
block|}
comment|// Consume the Spans into a cache.  This instance is used as a source for multiple cloned copies.
comment|// It's important we do this and not re-use the same original Spans instance since these will be iterated
comment|// independently later on; sometimes in ways that prevents sharing the original Spans.
name|CachedSpans
name|cachedSpansSource
init|=
operator|new
name|CachedSpans
argument_list|(
name|spans
argument_list|)
decl_stmt|;
comment|// consumes spans for this doc only and caches
name|spans
operator|=
literal|null
expr_stmt|;
comment|// we don't use it below
comment|// Map terms to a Spans instance (aggregate if necessary)
for|for
control|(
specifier|final
name|Term
name|queryTerm
range|:
name|termSet
control|)
block|{
comment|// note: we expect that at least one query term will pass these filters. This is because the collected
comment|//   spanQuery list were already filtered by these conditions.
if|if
condition|(
name|fieldName
operator|!=
literal|null
operator|&&
name|fieldName
operator|.
name|equals
argument_list|(
name|queryTerm
operator|.
name|field
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|positionInsensitiveTerms
operator|.
name|contains
argument_list|(
name|queryTerm
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// copy-constructor refers to same data (shallow) but has iteration state from the beginning
name|CachedSpans
name|cachedSpans
init|=
operator|new
name|CachedSpans
argument_list|(
name|cachedSpansSource
argument_list|)
decl_stmt|;
comment|// Add the span to whatever span may or may not exist
name|Spans
name|existingSpans
init|=
name|result
operator|.
name|get
argument_list|(
name|queryTerm
operator|.
name|bytes
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingSpans
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|existingSpans
operator|instanceof
name|MultiSpans
condition|)
block|{
operator|(
operator|(
name|MultiSpans
operator|)
name|existingSpans
operator|)
operator|.
name|addSpans
argument_list|(
name|cachedSpans
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// upgrade to MultiSpans
name|MultiSpans
name|multiSpans
init|=
operator|new
name|MultiSpans
argument_list|()
decl_stmt|;
name|multiSpans
operator|.
name|addSpans
argument_list|(
name|existingSpans
argument_list|)
expr_stmt|;
name|multiSpans
operator|.
name|addSpans
argument_list|(
name|cachedSpans
argument_list|)
expr_stmt|;
name|result
operator|.
name|put
argument_list|(
name|queryTerm
operator|.
name|bytes
argument_list|()
argument_list|,
name|multiSpans
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|.
name|put
argument_list|(
name|queryTerm
operator|.
name|bytes
argument_list|()
argument_list|,
name|cachedSpans
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns terms as a List, but expanded to any terms in strictPhrases' keySet if present.  That can only    * happen if willRewrite() is true.    */
DECL|method|expandTermsIfRewrite
name|List
argument_list|<
name|BytesRef
argument_list|>
name|expandTermsIfRewrite
parameter_list|(
name|BytesRef
index|[]
name|terms
parameter_list|,
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|Spans
argument_list|>
name|strictPhrasesTermToSpans
parameter_list|)
block|{
if|if
condition|(
name|willRewrite
argument_list|()
condition|)
block|{
name|Set
argument_list|<
name|BytesRef
argument_list|>
name|allTermSet
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|terms
operator|.
name|length
operator|+
name|strictPhrasesTermToSpans
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|allTermSet
argument_list|,
name|terms
argument_list|)
expr_stmt|;
comment|//FYI already sorted; will keep order
if|if
condition|(
name|allTermSet
operator|.
name|addAll
argument_list|(
name|strictPhrasesTermToSpans
operator|.
name|keySet
argument_list|()
argument_list|)
condition|)
block|{
comment|// true if any were added
name|List
argument_list|<
name|BytesRef
argument_list|>
name|sourceTerms
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|allTermSet
operator|.
name|toArray
argument_list|(
operator|new
name|BytesRef
index|[
name|allTermSet
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|sourceTerms
operator|.
name|sort
argument_list|(
name|Comparator
operator|.
name|naturalOrder
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sourceTerms
return|;
block|}
block|}
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|terms
argument_list|)
return|;
comment|// no rewrite; use original terms
block|}
comment|/**    * Returns a filtered postings where the position must be in the given Spans.    * The Spans must be in a positioned state (not initial) and should not be shared between other terms.    * {@code postingsEnum} should be positioned at the    * document (the same one as the spans) but it hasn't iterated the positions yet.    * The Spans should be the result of a simple    * lookup from {@link #getTermToSpans(LeafReader, int)}, and so it could be null which could mean    * either it's completely filtered or that there should be no filtering; this class knows what to do.    *<p>    * Due to limitations in filtering, the {@link PostingsEnum#freq()} is un-changed even if some positions    * get filtered.  So when {@link PostingsEnum#nextPosition()} is called or {@code startOffset} or {@code    * endOffset} beyond the "real" positions, these methods returns {@link Integer#MAX_VALUE}.    *<p>    *<b>This will return null if it's completely filtered out (i.e. effectively has no postings).</b>    */
DECL|method|filterPostings
name|PostingsEnum
name|filterPostings
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|PostingsEnum
name|postingsEnum
parameter_list|,
name|Spans
name|spans
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|spans
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|hasPositionSensitivity
argument_list|()
operator|==
literal|false
operator|||
name|positionInsensitiveTerms
operator|.
name|contains
argument_list|(
operator|new
name|Term
argument_list|(
name|fieldName
argument_list|,
name|term
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|postingsEnum
return|;
comment|// no filtering
block|}
else|else
block|{
return|return
literal|null
return|;
comment|// completely filtered out
block|}
block|}
if|if
condition|(
name|postingsEnum
operator|.
name|docID
argument_list|()
operator|!=
name|spans
operator|.
name|docID
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Spans& Postings doc ID misaligned or not positioned"
argument_list|)
throw|;
block|}
return|return
operator|new
name|FilterLeafReader
operator|.
name|FilterPostingsEnum
argument_list|(
name|postingsEnum
argument_list|)
block|{
comment|// freq() is max times nextPosition can be called. We'll set this var to -1 when exhausted.
name|int
name|remainingPositions
init|=
name|postingsEnum
operator|.
name|freq
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|where
decl_stmt|;
try|try
block|{
name|where
operator|=
literal|"["
operator|+
name|startOffset
argument_list|()
operator|+
literal|":"
operator|+
name|endOffset
argument_list|()
operator|+
literal|"]"
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|where
operator|=
literal|"["
operator|+
name|e
operator|+
literal|"]"
expr_stmt|;
block|}
return|return
literal|"'"
operator|+
name|term
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|"'@"
operator|+
name|where
operator|+
literal|" filtered by "
operator|+
name|spans
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"not expected"
argument_list|)
throw|;
comment|// don't need to implement; just used on one doc
block|}
annotation|@
name|Override
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"not expected"
argument_list|)
throw|;
comment|// don't need to implement; just used on one doc
block|}
annotation|@
name|Override
specifier|public
name|int
name|nextPosition
parameter_list|()
throws|throws
name|IOException
block|{
comment|// loop over posting positions...
name|NEXT_POS_LOOP
label|:
while|while
condition|(
name|remainingPositions
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|thisPos
init|=
name|super
operator|.
name|nextPosition
argument_list|()
decl_stmt|;
name|remainingPositions
operator|--
expr_stmt|;
comment|// loop spans forward (if necessary) while the span end is behind thisPos
while|while
condition|(
name|spans
operator|.
name|endPosition
argument_list|()
operator|<=
name|thisPos
condition|)
block|{
if|if
condition|(
name|spans
operator|.
name|nextStartPosition
argument_list|()
operator|==
name|Spans
operator|.
name|NO_MORE_POSITIONS
condition|)
block|{
comment|// advance
break|break
name|NEXT_POS_LOOP
break|;
block|}
assert|assert
name|spans
operator|.
name|docID
argument_list|()
operator|==
name|postingsEnum
operator|.
name|docID
argument_list|()
assert|;
block|}
comment|// is this position within the span?
if|if
condition|(
name|thisPos
operator|>=
name|spans
operator|.
name|startPosition
argument_list|()
condition|)
block|{
assert|assert
name|thisPos
operator|<
name|spans
operator|.
name|endPosition
argument_list|()
assert|;
comment|// guaranteed by previous loop
return|return
name|thisPos
return|;
comment|// yay!
block|}
comment|// else continue and try the next position
block|}
name|remainingPositions
operator|=
operator|-
literal|1
expr_stmt|;
comment|// signify done
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|startOffset
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|remainingPositions
operator|>=
literal|0
condition|?
name|super
operator|.
name|startOffset
argument_list|()
else|:
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|endOffset
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|remainingPositions
operator|>=
literal|0
condition|?
name|super
operator|.
name|endOffset
argument_list|()
else|:
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
block|}
return|;
block|}
comment|/**    * Simple HashSet that filters out Terms not matching a desired field on {@code add()}.    */
DECL|class|FieldFilteringTermHashSet
specifier|private
specifier|static
class|class
name|FieldFilteringTermHashSet
extends|extends
name|HashSet
argument_list|<
name|Term
argument_list|>
block|{
DECL|field|field
specifier|private
specifier|final
name|String
name|field
decl_stmt|;
DECL|method|FieldFilteringTermHashSet
name|FieldFilteringTermHashSet
parameter_list|(
name|String
name|field
parameter_list|)
block|{
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|add
specifier|public
name|boolean
name|add
parameter_list|(
name|Term
name|term
parameter_list|)
block|{
if|if
condition|(
name|term
operator|.
name|field
argument_list|()
operator|.
name|equals
argument_list|(
name|field
argument_list|)
condition|)
block|{
return|return
name|super
operator|.
name|add
argument_list|(
name|term
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
comment|/**    * A single {@link Spans} view over multiple spans.  At least one span is mandatory, but you should probably    * supply more than one.  Furthermore, the given spans are expected to be positioned to a document already    * via a call to next or advance).    */
comment|// TODO move to Lucene core as a Spans utility class?
DECL|class|MultiSpans
specifier|static
class|class
name|MultiSpans
extends|extends
name|Spans
block|{
DECL|field|spansQueue
specifier|final
name|PriorityQueue
argument_list|<
name|Spans
argument_list|>
name|spansQueue
init|=
operator|new
name|PriorityQueue
argument_list|<>
argument_list|(
name|SPANS_COMPARATOR
argument_list|)
decl_stmt|;
DECL|field|cost
name|long
name|cost
decl_stmt|;
DECL|method|addSpans
name|void
name|addSpans
parameter_list|(
name|Spans
name|spans
parameter_list|)
block|{
if|if
condition|(
name|spans
operator|.
name|docID
argument_list|()
operator|<
literal|0
operator|||
name|spans
operator|.
name|docID
argument_list|()
operator|==
name|NO_MORE_DOCS
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting given spans to be in a positioned state."
argument_list|)
throw|;
block|}
name|spansQueue
operator|.
name|add
argument_list|(
name|spans
argument_list|)
expr_stmt|;
name|cost
operator|=
name|Math
operator|.
name|max
argument_list|(
name|cost
argument_list|,
name|spans
operator|.
name|cost
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// DocIdSetIterator methods:
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|spansQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|NO_MORE_DOCS
return|;
block|}
return|return
name|advance
argument_list|(
name|spansQueue
operator|.
name|peek
argument_list|()
operator|.
name|docID
argument_list|()
operator|+
literal|1
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|spansQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|NO_MORE_DOCS
return|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|Spans
name|spans
init|=
name|spansQueue
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|spans
operator|.
name|docID
argument_list|()
operator|>=
name|target
condition|)
block|{
return|return
name|spans
operator|.
name|docID
argument_list|()
return|;
block|}
name|spansQueue
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|// must remove before modify state
if|if
condition|(
name|spans
operator|.
name|advance
argument_list|(
name|target
argument_list|)
operator|!=
name|NO_MORE_DOCS
condition|)
block|{
comment|// ... otherwise it's not re-added
name|spansQueue
operator|.
name|add
argument_list|(
name|spans
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spansQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|NO_MORE_DOCS
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
if|if
condition|(
name|spansQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|NO_MORE_DOCS
return|;
block|}
return|return
name|spansQueue
operator|.
name|peek
argument_list|()
operator|.
name|docID
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|cost
return|;
block|}
comment|// Spans methods:
annotation|@
name|Override
DECL|method|nextStartPosition
specifier|public
name|int
name|nextStartPosition
parameter_list|()
throws|throws
name|IOException
block|{
comment|// advance any spans at the initial position per document
name|boolean
name|atDocStart
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|spansQueue
operator|.
name|peek
argument_list|()
operator|.
name|startPosition
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|atDocStart
operator|=
literal|true
expr_stmt|;
name|Spans
name|headSpans
init|=
name|spansQueue
operator|.
name|remove
argument_list|()
decl_stmt|;
comment|// remove because we will change state
name|headSpans
operator|.
name|nextStartPosition
argument_list|()
expr_stmt|;
name|spansQueue
operator|.
name|add
argument_list|(
name|headSpans
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|atDocStart
condition|)
block|{
name|Spans
name|headSpans
init|=
name|spansQueue
operator|.
name|remove
argument_list|()
decl_stmt|;
comment|// remove because we will change state
name|headSpans
operator|.
name|nextStartPosition
argument_list|()
expr_stmt|;
name|spansQueue
operator|.
name|add
argument_list|(
name|headSpans
argument_list|)
expr_stmt|;
block|}
return|return
name|startPosition
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|startPosition
specifier|public
name|int
name|startPosition
parameter_list|()
block|{
return|return
name|spansQueue
operator|.
name|peek
argument_list|()
operator|.
name|startPosition
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|endPosition
specifier|public
name|int
name|endPosition
parameter_list|()
block|{
return|return
name|spansQueue
operator|.
name|peek
argument_list|()
operator|.
name|endPosition
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|width
specifier|public
name|int
name|width
parameter_list|()
block|{
return|return
name|spansQueue
operator|.
name|peek
argument_list|()
operator|.
name|width
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|SpanCollector
name|collector
parameter_list|)
throws|throws
name|IOException
block|{
name|spansQueue
operator|.
name|peek
argument_list|()
operator|.
name|collect
argument_list|(
name|collector
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|positionsCost
specifier|public
name|float
name|positionsCost
parameter_list|()
block|{
return|return
literal|100f
return|;
comment|// no idea; and we can't delegate due to not allowing to call it dependent on TwoPhaseIterator
block|}
block|}
comment|/**    * A Spans based on a list of cached spans for one doc.  It is pre-positioned to this doc.    */
DECL|class|CachedSpans
specifier|private
specifier|static
class|class
name|CachedSpans
extends|extends
name|Spans
block|{
DECL|class|CachedSpan
specifier|private
specifier|static
class|class
name|CachedSpan
block|{
DECL|field|start
specifier|final
name|int
name|start
decl_stmt|;
DECL|field|end
specifier|final
name|int
name|end
decl_stmt|;
DECL|method|CachedSpan
name|CachedSpan
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|this
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|this
operator|.
name|end
operator|=
name|end
expr_stmt|;
block|}
block|}
DECL|field|docId
specifier|final
name|int
name|docId
decl_stmt|;
DECL|field|cachedSpanList
specifier|final
name|ArrayList
argument_list|<
name|CachedSpan
argument_list|>
name|cachedSpanList
decl_stmt|;
DECL|field|index
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|CachedSpans
name|CachedSpans
parameter_list|(
name|Spans
name|spans
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|docId
operator|=
name|spans
operator|.
name|docID
argument_list|()
expr_stmt|;
assert|assert
name|this
operator|.
name|docId
operator|!=
operator|-
literal|1
assert|;
comment|// Consume the spans for this doc into a list.  There's always at least one; the first/current one.
name|cachedSpanList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
while|while
condition|(
name|spans
operator|.
name|nextStartPosition
argument_list|()
operator|!=
name|NO_MORE_POSITIONS
condition|)
block|{
name|cachedSpanList
operator|.
name|add
argument_list|(
operator|new
name|CachedSpan
argument_list|(
name|spans
operator|.
name|startPosition
argument_list|()
argument_list|,
name|spans
operator|.
name|endPosition
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
assert|assert
operator|!
name|cachedSpanList
operator|.
name|isEmpty
argument_list|()
assert|;
comment|// bad Span impl?
block|}
comment|/**      * Clone; reset iteration state.      */
DECL|method|CachedSpans
name|CachedSpans
parameter_list|(
name|CachedSpans
name|cloneMe
parameter_list|)
block|{
name|docId
operator|=
name|cloneMe
operator|.
name|docId
expr_stmt|;
name|cachedSpanList
operator|=
name|cloneMe
operator|.
name|cachedSpanList
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not expected"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not expected"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docId
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|nextStartPosition
specifier|public
name|int
name|nextStartPosition
parameter_list|()
throws|throws
name|IOException
block|{
name|index
operator|++
expr_stmt|;
return|return
name|startPosition
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|startPosition
specifier|public
name|int
name|startPosition
parameter_list|()
block|{
return|return
name|index
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
name|index
operator|>=
name|cachedSpanList
operator|.
name|size
argument_list|()
condition|?
name|NO_MORE_POSITIONS
else|:
name|cachedSpanList
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|start
return|;
block|}
annotation|@
name|Override
DECL|method|endPosition
specifier|public
name|int
name|endPosition
parameter_list|()
block|{
return|return
name|index
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
name|index
operator|>=
name|cachedSpanList
operator|.
name|size
argument_list|()
condition|?
name|NO_MORE_POSITIONS
else|:
name|cachedSpanList
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|end
return|;
block|}
annotation|@
name|Override
DECL|method|width
specifier|public
name|int
name|width
parameter_list|()
block|{
return|return
name|endPosition
argument_list|()
operator|-
name|startPosition
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|SpanCollector
name|collector
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not expected"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|positionsCost
specifier|public
name|float
name|positionsCost
parameter_list|()
block|{
return|return
literal|1f
return|;
block|}
block|}
comment|// class CachedSpans
block|}
end_class

end_unit

