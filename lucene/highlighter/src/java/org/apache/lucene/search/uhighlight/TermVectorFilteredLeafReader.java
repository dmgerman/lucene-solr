begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.search.uhighlight
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|uhighlight
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Fields
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FilterLeafReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PostingsEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|CompiledAutomaton
import|;
end_import

begin_comment
comment|/**  * A filtered LeafReader that only includes the terms that are also in a provided set of terms.  * Certain methods may be unimplemented or cause large operations on the underlying reader  * and be slow.  *  * @lucene.internal  */
end_comment

begin_class
DECL|class|TermVectorFilteredLeafReader
specifier|final
class|class
name|TermVectorFilteredLeafReader
extends|extends
name|FilterLeafReader
block|{
comment|// NOTE: super ("in") is baseLeafReader
DECL|field|filterTerms
specifier|private
specifier|final
name|Terms
name|filterTerms
decl_stmt|;
comment|/**    *<p>Construct a FilterLeafReader based on the specified base reader.    *<p>Note that base reader is closed if this FilterLeafReader is closed.</p>    *    * @param baseLeafReader full/original reader.    * @param filterTerms set of terms to filter by -- probably from a TermVector or MemoryIndex.    */
DECL|method|TermVectorFilteredLeafReader
name|TermVectorFilteredLeafReader
parameter_list|(
name|LeafReader
name|baseLeafReader
parameter_list|,
name|Terms
name|filterTerms
parameter_list|)
block|{
name|super
argument_list|(
name|baseLeafReader
argument_list|)
expr_stmt|;
name|this
operator|.
name|filterTerms
operator|=
name|filterTerms
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|fields
specifier|public
name|Fields
name|fields
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|TermVectorFilteredFields
argument_list|(
name|in
operator|.
name|fields
argument_list|()
argument_list|,
name|filterTerms
argument_list|)
return|;
block|}
DECL|class|TermVectorFilteredFields
specifier|private
specifier|static
specifier|final
class|class
name|TermVectorFilteredFields
extends|extends
name|FilterLeafReader
operator|.
name|FilterFields
block|{
comment|// NOTE: super ("in") is baseFields
DECL|field|filterTerms
specifier|private
specifier|final
name|Terms
name|filterTerms
decl_stmt|;
DECL|method|TermVectorFilteredFields
name|TermVectorFilteredFields
parameter_list|(
name|Fields
name|baseFields
parameter_list|,
name|Terms
name|filterTerms
parameter_list|)
block|{
name|super
argument_list|(
name|baseFields
argument_list|)
expr_stmt|;
name|this
operator|.
name|filterTerms
operator|=
name|filterTerms
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|terms
specifier|public
name|Terms
name|terms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|TermsFilteredTerms
argument_list|(
name|in
operator|.
name|terms
argument_list|(
name|field
argument_list|)
argument_list|,
name|filterTerms
argument_list|)
return|;
block|}
block|}
DECL|class|TermsFilteredTerms
specifier|private
specifier|static
specifier|final
class|class
name|TermsFilteredTerms
extends|extends
name|FilterLeafReader
operator|.
name|FilterTerms
block|{
comment|// NOTE: super ("in") is the baseTerms
DECL|field|filterTerms
specifier|private
specifier|final
name|Terms
name|filterTerms
decl_stmt|;
DECL|method|TermsFilteredTerms
name|TermsFilteredTerms
parameter_list|(
name|Terms
name|baseTerms
parameter_list|,
name|Terms
name|filterTerms
parameter_list|)
block|{
name|super
argument_list|(
name|baseTerms
argument_list|)
expr_stmt|;
name|this
operator|.
name|filterTerms
operator|=
name|filterTerms
expr_stmt|;
block|}
comment|//TODO delegate size() ?
comment|//TODO delegate getMin, getMax to filterTerms
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|TermsEnum
name|iterator
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|TermVectorFilteredTermsEnum
argument_list|(
name|in
operator|.
name|iterator
argument_list|()
argument_list|,
name|filterTerms
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|intersect
specifier|public
name|TermsEnum
name|intersect
parameter_list|(
name|CompiledAutomaton
name|compiled
parameter_list|,
name|BytesRef
name|startTerm
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|TermVectorFilteredTermsEnum
argument_list|(
name|in
operator|.
name|iterator
argument_list|()
argument_list|,
name|filterTerms
operator|.
name|intersect
argument_list|(
name|compiled
argument_list|,
name|startTerm
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|class|TermVectorFilteredTermsEnum
specifier|private
specifier|static
specifier|final
class|class
name|TermVectorFilteredTermsEnum
extends|extends
name|FilterLeafReader
operator|.
name|FilterTermsEnum
block|{
comment|// NOTE: super ("in") is the filteredTermsEnum. This is different than wrappers above because we
comment|//    navigate the terms using the filter.
comment|//TODO: track the last term state from the term state method and do some potential optimizations
DECL|field|baseTermsEnum
specifier|private
specifier|final
name|TermsEnum
name|baseTermsEnum
decl_stmt|;
DECL|method|TermVectorFilteredTermsEnum
name|TermVectorFilteredTermsEnum
parameter_list|(
name|TermsEnum
name|baseTermsEnum
parameter_list|,
name|TermsEnum
name|filteredTermsEnum
parameter_list|)
block|{
name|super
argument_list|(
name|filteredTermsEnum
argument_list|)
expr_stmt|;
comment|// note this is reversed from constructors above
name|this
operator|.
name|baseTermsEnum
operator|=
name|baseTermsEnum
expr_stmt|;
block|}
comment|//TODO delegate docFreq& ttf (moveToCurrentTerm() then call on full?
annotation|@
name|Override
DECL|method|postings
specifier|public
name|PostingsEnum
name|postings
parameter_list|(
name|PostingsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|moveToCurrentTerm
argument_list|()
expr_stmt|;
return|return
name|baseTermsEnum
operator|.
name|postings
argument_list|(
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
DECL|method|moveToCurrentTerm
name|void
name|moveToCurrentTerm
parameter_list|()
throws|throws
name|IOException
block|{
name|BytesRef
name|currentTerm
init|=
name|in
operator|.
name|term
argument_list|()
decl_stmt|;
comment|// from filteredTermsEnum
name|boolean
name|termInBothTermsEnum
init|=
name|baseTermsEnum
operator|.
name|seekExact
argument_list|(
name|currentTerm
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|termInBothTermsEnum
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Term vector term "
operator|+
name|currentTerm
operator|+
literal|" does not appear in full index."
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|getCoreCacheHelper
specifier|public
name|CacheHelper
name|getCoreCacheHelper
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getReaderCacheHelper
specifier|public
name|CacheHelper
name|getReaderCacheHelper
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

