begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|SolrTestCaseJ4
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|embedded
operator|.
name|JettyConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|embedded
operator|.
name|JettySolrRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|CloudSolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|HttpSolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|ZkClientClusterStateProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|CoreAdminRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|CoreStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|CollectionStatePredicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|SolrZkClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_comment
comment|/**  * Base class for SolrCloud tests  *  * Derived tests should call {@link #configureCluster(int)} in a {@code BeforeClass}  * static method.  This configures and starts a {@link MiniSolrCloudCluster}, available  * via the {@code cluster} variable.  Cluster shutdown is handled automatically.  *  *<pre>  *<code>  *   {@literal @}BeforeClass  *   public static void setupCluster() {  *     configureCluster(NUM_NODES)  *        .addConfig("configname", pathToConfig)  *        .configure();  *   }  *</code>  *</pre>  */
end_comment

begin_class
DECL|class|SolrCloudTestCase
specifier|public
class|class
name|SolrCloudTestCase
extends|extends
name|SolrTestCaseJ4
block|{
DECL|field|DEFAULT_TIMEOUT
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_TIMEOUT
init|=
literal|60
decl_stmt|;
DECL|class|Config
specifier|private
specifier|static
class|class
name|Config
block|{
DECL|field|name
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|path
specifier|final
name|Path
name|path
decl_stmt|;
DECL|method|Config
specifier|private
name|Config
parameter_list|(
name|String
name|name
parameter_list|,
name|Path
name|path
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
block|}
block|}
comment|/**    * Builder class for a MiniSolrCloudCluster    */
DECL|class|Builder
specifier|protected
specifier|static
class|class
name|Builder
block|{
DECL|field|nodeCount
specifier|private
specifier|final
name|int
name|nodeCount
decl_stmt|;
DECL|field|baseDir
specifier|private
specifier|final
name|Path
name|baseDir
decl_stmt|;
DECL|field|solrxml
specifier|private
name|String
name|solrxml
init|=
name|MiniSolrCloudCluster
operator|.
name|DEFAULT_CLOUD_SOLR_XML
decl_stmt|;
DECL|field|jettyConfig
specifier|private
name|JettyConfig
name|jettyConfig
init|=
name|buildJettyConfig
argument_list|(
literal|"/solr"
argument_list|)
decl_stmt|;
DECL|field|securityJson
specifier|private
name|Optional
argument_list|<
name|String
argument_list|>
name|securityJson
init|=
name|Optional
operator|.
name|empty
argument_list|()
decl_stmt|;
DECL|field|configs
specifier|private
name|List
argument_list|<
name|Config
argument_list|>
name|configs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|clusterProperties
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|clusterProperties
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * Create a builder      * @param nodeCount the number of nodes in the cluster      * @param baseDir   a base directory for the cluster      */
DECL|method|Builder
specifier|public
name|Builder
parameter_list|(
name|int
name|nodeCount
parameter_list|,
name|Path
name|baseDir
parameter_list|)
block|{
name|this
operator|.
name|nodeCount
operator|=
name|nodeCount
expr_stmt|;
name|this
operator|.
name|baseDir
operator|=
name|baseDir
expr_stmt|;
block|}
comment|/**      * Use a {@link JettyConfig} to configure the cluster's jetty servers      */
DECL|method|withJettyConfig
specifier|public
name|Builder
name|withJettyConfig
parameter_list|(
name|JettyConfig
name|jettyConfig
parameter_list|)
block|{
name|this
operator|.
name|jettyConfig
operator|=
name|jettyConfig
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Use the provided string as solr.xml content      */
DECL|method|withSolrXml
specifier|public
name|Builder
name|withSolrXml
parameter_list|(
name|String
name|solrXml
parameter_list|)
block|{
name|this
operator|.
name|solrxml
operator|=
name|solrXml
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Read solr.xml from the provided path      */
DECL|method|withSolrXml
specifier|public
name|Builder
name|withSolrXml
parameter_list|(
name|Path
name|solrXml
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|solrxml
operator|=
operator|new
name|String
argument_list|(
name|Files
operator|.
name|readAllBytes
argument_list|(
name|solrXml
argument_list|)
argument_list|,
name|Charset
operator|.
name|defaultCharset
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|this
return|;
block|}
comment|/**      * Configure the specified security.json for the {@linkplain MiniSolrCloudCluster}      *      * @param securityJson The path specifying the security.json file      * @return the instance of {@linkplain Builder}      */
DECL|method|withSecurityJson
specifier|public
name|Builder
name|withSecurityJson
parameter_list|(
name|Path
name|securityJson
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|securityJson
operator|=
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|String
argument_list|(
name|Files
operator|.
name|readAllBytes
argument_list|(
name|securityJson
argument_list|)
argument_list|,
name|Charset
operator|.
name|defaultCharset
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|this
return|;
block|}
comment|/**      * Configure the specified security.json for the {@linkplain MiniSolrCloudCluster}      *      * @param securityJson The string specifying the security.json configuration      * @return the instance of {@linkplain Builder}      */
DECL|method|withSecurityJson
specifier|public
name|Builder
name|withSecurityJson
parameter_list|(
name|String
name|securityJson
parameter_list|)
block|{
name|this
operator|.
name|securityJson
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|securityJson
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Upload a collection config before tests start      * @param configName the config name      * @param configPath the path to the config files      */
DECL|method|addConfig
specifier|public
name|Builder
name|addConfig
parameter_list|(
name|String
name|configName
parameter_list|,
name|Path
name|configPath
parameter_list|)
block|{
name|this
operator|.
name|configs
operator|.
name|add
argument_list|(
operator|new
name|Config
argument_list|(
name|configName
argument_list|,
name|configPath
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Set a cluster property      * @param propertyName the property name      * @param propertyValue the property value      */
DECL|method|withProperty
specifier|public
name|Builder
name|withProperty
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|propertyValue
parameter_list|)
block|{
name|this
operator|.
name|clusterProperties
operator|.
name|put
argument_list|(
name|propertyName
argument_list|,
name|propertyValue
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Configure and run the {@link MiniSolrCloudCluster}      * @throws Exception if an error occurs on startup      */
DECL|method|configure
specifier|public
name|void
name|configure
parameter_list|()
throws|throws
name|Exception
block|{
name|cluster
operator|=
operator|new
name|MiniSolrCloudCluster
argument_list|(
name|nodeCount
argument_list|,
name|baseDir
argument_list|,
name|solrxml
argument_list|,
name|jettyConfig
argument_list|,
literal|null
argument_list|,
name|securityJson
argument_list|)
expr_stmt|;
name|CloudSolrClient
name|client
init|=
name|cluster
operator|.
name|getSolrClient
argument_list|()
decl_stmt|;
for|for
control|(
name|Config
name|config
range|:
name|configs
control|)
block|{
operator|(
operator|(
name|ZkClientClusterStateProvider
operator|)
name|client
operator|.
name|getClusterStateProvider
argument_list|()
operator|)
operator|.
name|uploadConfig
argument_list|(
name|config
operator|.
name|path
argument_list|,
name|config
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clusterProperties
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ClusterProperties
name|props
init|=
operator|new
name|ClusterProperties
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getZkClient
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|clusterProperties
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|props
operator|.
name|setClusterProperty
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** The cluster */
DECL|field|cluster
specifier|protected
specifier|static
name|MiniSolrCloudCluster
name|cluster
decl_stmt|;
DECL|method|zkClient
specifier|protected
specifier|static
name|SolrZkClient
name|zkClient
parameter_list|()
block|{
name|ZkStateReader
name|reader
init|=
name|cluster
operator|.
name|getSolrClient
argument_list|()
operator|.
name|getZkStateReader
argument_list|()
decl_stmt|;
if|if
condition|(
name|reader
operator|==
literal|null
condition|)
name|cluster
operator|.
name|getSolrClient
argument_list|()
operator|.
name|connect
argument_list|()
expr_stmt|;
return|return
name|cluster
operator|.
name|getSolrClient
argument_list|()
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getZkClient
argument_list|()
return|;
block|}
comment|/**    * Call this to configure a cluster of n nodes.    *    * NB you must call {@link Builder#configure()} to start the cluster    *    * @param nodeCount the number of nodes    */
DECL|method|configureCluster
specifier|protected
specifier|static
name|Builder
name|configureCluster
parameter_list|(
name|int
name|nodeCount
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|(
name|nodeCount
argument_list|,
name|createTempDir
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|AfterClass
DECL|method|shutdownCluster
specifier|public
specifier|static
name|void
name|shutdownCluster
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|cluster
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Before
DECL|method|checkClusterConfiguration
specifier|public
name|void
name|checkClusterConfiguration
parameter_list|()
block|{
if|if
condition|(
name|cluster
operator|==
literal|null
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"MiniSolrCloudCluster not configured - have you called configureCluster().configure()?"
argument_list|)
throw|;
block|}
comment|/* Cluster helper methods ************************************/
comment|/**    * Get the collection state for a particular collection    */
DECL|method|getCollectionState
specifier|protected
name|DocCollection
name|getCollectionState
parameter_list|(
name|String
name|collectionName
parameter_list|)
block|{
return|return
name|cluster
operator|.
name|getSolrClient
argument_list|()
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
operator|.
name|getCollection
argument_list|(
name|collectionName
argument_list|)
return|;
block|}
comment|/**    * Wait for a particular collection state to appear in the cluster client's state reader    *    * This is a convenience method using the {@link #DEFAULT_TIMEOUT}    *    * @param message     a message to report on failure    * @param collection  the collection to watch    * @param predicate   a predicate to match against the collection state    */
DECL|method|waitForState
specifier|protected
name|void
name|waitForState
parameter_list|(
name|String
name|message
parameter_list|,
name|String
name|collection
parameter_list|,
name|CollectionStatePredicate
name|predicate
parameter_list|)
block|{
name|AtomicReference
argument_list|<
name|DocCollection
argument_list|>
name|state
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|.
name|getSolrClient
argument_list|()
operator|.
name|waitForState
argument_list|(
name|collection
argument_list|,
name|DEFAULT_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
parameter_list|(
name|n
parameter_list|,
name|c
parameter_list|)
lambda|->
block|{
name|state
operator|.
name|set
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|predicate
operator|.
name|matches
argument_list|(
name|n
argument_list|,
name|c
argument_list|)
return|;
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|fail
argument_list|(
name|message
operator|+
literal|"\n"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|"\nLast available state: "
operator|+
name|state
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected    * number of shards and replicas    */
DECL|method|clusterShape
specifier|public
specifier|static
name|CollectionStatePredicate
name|clusterShape
parameter_list|(
name|int
name|expectedShards
parameter_list|,
name|int
name|expectedReplicas
parameter_list|)
block|{
return|return
parameter_list|(
name|liveNodes
parameter_list|,
name|collectionState
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|collectionState
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|collectionState
operator|.
name|getSlices
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|expectedShards
condition|)
return|return
literal|false
return|;
for|for
control|(
name|Slice
name|slice
range|:
name|collectionState
control|)
block|{
name|int
name|activeReplicas
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Replica
name|replica
range|:
name|slice
control|)
block|{
if|if
condition|(
name|replica
operator|.
name|isActive
argument_list|(
name|liveNodes
argument_list|)
condition|)
name|activeReplicas
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|activeReplicas
operator|!=
name|expectedReplicas
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
return|;
block|}
comment|/**    * Get a (reproducibly) random shard from a {@link DocCollection}    */
DECL|method|getRandomShard
specifier|protected
specifier|static
name|Slice
name|getRandomShard
parameter_list|(
name|DocCollection
name|collection
parameter_list|)
block|{
name|List
argument_list|<
name|Slice
argument_list|>
name|shards
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|collection
operator|.
name|getActiveSlices
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shards
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
name|fail
argument_list|(
literal|"Couldn't get random shard for collection as it has no shards!\n"
operator|+
name|collection
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|shards
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|shards
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * Get a (reproducibly) random replica from a {@link Slice}    */
DECL|method|getRandomReplica
specifier|protected
specifier|static
name|Replica
name|getRandomReplica
parameter_list|(
name|Slice
name|slice
parameter_list|)
block|{
name|List
argument_list|<
name|Replica
argument_list|>
name|replicas
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|slice
operator|.
name|getReplicas
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicas
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
name|fail
argument_list|(
literal|"Couldn't get random replica from shard as it has no replicas!\n"
operator|+
name|slice
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|replicas
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|replicas
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * Get a (reproducibly) random replica from a {@link Slice} matching a predicate    */
DECL|method|getRandomReplica
specifier|protected
specifier|static
name|Replica
name|getRandomReplica
parameter_list|(
name|Slice
name|slice
parameter_list|,
name|Predicate
argument_list|<
name|Replica
argument_list|>
name|matchPredicate
parameter_list|)
block|{
name|List
argument_list|<
name|Replica
argument_list|>
name|replicas
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|slice
operator|.
name|getReplicas
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicas
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
name|fail
argument_list|(
literal|"Couldn't get random replica from shard as it has no replicas!\n"
operator|+
name|slice
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|replicas
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Replica
name|replica
range|:
name|replicas
control|)
block|{
if|if
condition|(
name|matchPredicate
operator|.
name|test
argument_list|(
name|replica
argument_list|)
condition|)
return|return
name|replica
return|;
block|}
name|fail
argument_list|(
literal|"Couldn't get random replica that matched conditions\n"
operator|+
name|slice
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// just to keep the compiler happy - fail will always throw an Exception
block|}
comment|/**    * Get the {@link CoreStatus} data for a {@link Replica}    *    * This assumes that the replica is hosted on a live node.    */
DECL|method|getCoreStatus
specifier|protected
specifier|static
name|CoreStatus
name|getCoreStatus
parameter_list|(
name|Replica
name|replica
parameter_list|)
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
name|JettySolrRunner
name|jetty
init|=
name|cluster
operator|.
name|getReplicaJetty
argument_list|(
name|replica
argument_list|)
decl_stmt|;
try|try
init|(
name|HttpSolrClient
name|client
init|=
name|getHttpSolrClient
argument_list|(
name|jetty
operator|.
name|getBaseUrl
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|cluster
operator|.
name|getSolrClient
argument_list|()
operator|.
name|getHttpClient
argument_list|()
argument_list|)
init|)
block|{
return|return
name|CoreAdminRequest
operator|.
name|getCoreStatus
argument_list|(
name|replica
operator|.
name|getCoreName
argument_list|()
argument_list|,
name|client
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

