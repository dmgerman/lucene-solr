begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jsoup
operator|.
name|Jsoup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jsoup
operator|.
name|nodes
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jsoup
operator|.
name|nodes
operator|.
name|Element
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jsoup
operator|.
name|nodes
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jsoup
operator|.
name|nodes
operator|.
name|TextNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jsoup
operator|.
name|parser
operator|.
name|Parser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jsoup
operator|.
name|parser
operator|.
name|Tag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jsoup
operator|.
name|select
operator|.
name|Elements
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jsoup
operator|.
name|select
operator|.
name|NodeVisitor
import|;
end_import

begin_comment
comment|/**    * Check various things regarding links in the generated HTML site.  *<p>  * Asciidoctor doesn't do a good job of rectifying situations where multiple documents are included in one  * massive (PDF) document may have identical anchors (either explicitly defined, or implicitly defined because of   * section headings).  Asciidoctor also doesn't support linking directly to another (included) document by name,   * unless there is an explicit '#fragement' used inthe link.  *</p>  *<p>  * This tool parses the generated HTML site, looking for these situations in order to fail the build -- since the   * equivilent PDF will be broken.  It also does sme general check of the relative URLs to ensure the destination   * files/anchors actaully exist.  *</p>  *   * TODO: build a list of all known external links so that some other tool could (optionally) ping them all for 200 status?  *  * @see https://github.com/asciidoctor/asciidoctor/issues/1865  * @see https://github.com/asciidoctor/asciidoctor/issues/1866  */
end_comment

begin_class
DECL|class|CheckLinksAndAnchors
specifier|public
class|class
name|CheckLinksAndAnchors
block|{
DECL|class|HtmlFileFilter
specifier|public
specifier|static
specifier|final
class|class
name|HtmlFileFilter
implements|implements
name|FileFilter
block|{
DECL|method|accept
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|pathname
parameter_list|)
block|{
return|return
name|pathname
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"html"
argument_list|)
return|;
block|}
block|}
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|problems
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"usage: CheckLinksAndAnchors<htmldir>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|final
name|File
name|htmlDir
init|=
operator|new
name|File
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|final
name|File
index|[]
name|pages
init|=
name|htmlDir
operator|.
name|listFiles
argument_list|(
operator|new
name|HtmlFileFilter
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|pages
operator|.
name|length
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"No HTML Files found, wrong htmlDir? forgot to built the site?"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
name|idsToFiles
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|File
argument_list|,
name|List
argument_list|<
name|URI
argument_list|>
argument_list|>
name|filesToRelativeLinks
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|idsInMultiFiles
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|file
range|:
name|pages
control|)
block|{
comment|//System.out.println("input File URI: " + file.toURI().toString());
assert|assert
operator|!
name|filesToRelativeLinks
operator|.
name|containsKey
argument_list|(
name|file
argument_list|)
assert|;
specifier|final
name|List
argument_list|<
name|URI
argument_list|>
name|linksInThisFile
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|(
literal|17
argument_list|)
decl_stmt|;
name|filesToRelativeLinks
operator|.
name|put
argument_list|(
name|file
argument_list|,
name|linksInThisFile
argument_list|)
expr_stmt|;
specifier|final
name|String
name|fileContents
init|=
name|readFile
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Document
name|doc
init|=
name|Jsoup
operator|.
name|parse
argument_list|(
name|fileContents
argument_list|)
decl_stmt|;
comment|// we only care about class='main-content' -- we don't want to worry
comment|// about ids/links duplicated in the header/footer of every page,
specifier|final
name|Element
name|mainContent
init|=
name|doc
operator|.
name|select
argument_list|(
literal|".main-content"
argument_list|)
operator|.
name|first
argument_list|()
decl_stmt|;
if|if
condition|(
name|mainContent
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|file
operator|.
name|getName
argument_list|()
operator|+
literal|" has no main-content div"
argument_list|)
throw|;
block|}
comment|// Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)
specifier|final
name|Elements
name|nodesWithIds
init|=
name|mainContent
operator|.
name|select
argument_list|(
literal|"[id]"
argument_list|)
decl_stmt|;
comment|// NOTE: add<body> to the nodesWithIds so we check the main section anchor as well
name|nodesWithIds
operator|.
name|addAll
argument_list|(
name|doc
operator|.
name|select
argument_list|(
literal|"body[id]"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Element
name|node
range|:
name|nodesWithIds
control|)
block|{
specifier|final
name|String
name|id
init|=
name|node
operator|.
name|id
argument_list|()
decl_stmt|;
assert|assert
literal|null
operator|!=
name|id
assert|;
assert|assert
literal|0
operator|!=
name|id
operator|.
name|length
argument_list|()
assert|;
comment|// special case ids that we ignore
if|if
condition|(
name|id
operator|.
name|equals
argument_list|(
literal|"preamble"
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|idsToFiles
operator|.
name|containsKey
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|idsInMultiFiles
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idsToFiles
operator|.
name|put
argument_list|(
name|id
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|idsToFiles
operator|.
name|get
argument_list|(
name|id
argument_list|)
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|// check for (relative) links that don't include a fragment
specifier|final
name|Elements
name|links
init|=
name|mainContent
operator|.
name|select
argument_list|(
literal|"a[href]"
argument_list|)
decl_stmt|;
for|for
control|(
name|Element
name|link
range|:
name|links
control|)
block|{
specifier|final
name|String
name|href
init|=
name|link
operator|.
name|attr
argument_list|(
literal|"href"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|href
operator|.
name|length
argument_list|()
condition|)
block|{
name|problems
operator|++
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|file
operator|.
name|toURI
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" contains link with empty href"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|URI
name|uri
init|=
operator|new
name|URI
argument_list|(
name|href
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|uri
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
specifier|final
name|String
name|frag
init|=
name|uri
operator|.
name|getFragment
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|frag
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|frag
argument_list|)
condition|)
block|{
comment|// we must have a fragment for intra-page links to work correctly
name|problems
operator|++
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|file
operator|.
name|toURI
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" contains relative link w/o an '#anchor': "
operator|+
name|href
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// track the link to validate it exists in the target doc
name|linksInThisFile
operator|.
name|add
argument_list|(
name|uri
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|uri_ex
parameter_list|)
block|{
comment|// before reporting a problem, see if it can be parsed as a valid (absolute) URL
comment|// some solr examples URLs have characters that aren't legal URI characters
comment|// Example: "ipod^3.0", "foo:[*+TO+*]", etc...
name|boolean
name|href_is_valid_absolute_url
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// if this isn't absolute, it will fail
specifier|final
name|URL
name|ignored
init|=
operator|new
name|URL
argument_list|(
name|href
argument_list|)
decl_stmt|;
name|href_is_valid_absolute_url
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|url_ex
parameter_list|)
block|{
name|problems
operator|++
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|file
operator|.
name|toURI
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" contains link w/ invalid syntax: "
operator|+
name|href
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" ... as URI: "
operator|+
name|uri_ex
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" ... as URL: "
operator|+
name|url_ex
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// if there are problematic ids, report them
for|for
control|(
name|String
name|id
range|:
name|idsInMultiFiles
control|)
block|{
name|problems
operator|++
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"ID occurs multiple times: "
operator|+
name|id
argument_list|)
expr_stmt|;
for|for
control|(
name|File
name|file
range|:
name|idsToFiles
operator|.
name|get
argument_list|(
name|id
argument_list|)
control|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" ... "
operator|+
name|file
operator|.
name|toURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check every (realtive) link in every file to ensure the frag exists in the target page
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|File
argument_list|,
name|List
argument_list|<
name|URI
argument_list|>
argument_list|>
name|entry
range|:
name|filesToRelativeLinks
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|File
name|source
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
for|for
control|(
name|URI
name|link
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
specifier|final
name|String
name|path
init|=
operator|(
literal|null
operator|==
name|link
operator|.
name|getPath
argument_list|()
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|link
operator|.
name|getPath
argument_list|()
argument_list|)
operator|)
condition|?
name|source
operator|.
name|getName
argument_list|()
else|:
name|link
operator|.
name|getPath
argument_list|()
decl_stmt|;
specifier|final
name|String
name|frag
init|=
name|link
operator|.
name|getFragment
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|idsInMultiFiles
operator|.
name|contains
argument_list|(
name|frag
argument_list|)
condition|)
block|{
comment|// skip problematic dups already reported
specifier|final
name|File
name|dest
init|=
operator|new
name|File
argument_list|(
name|htmlDir
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dest
operator|.
name|exists
argument_list|()
condition|)
block|{
name|problems
operator|++
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Relative link points at dest file that doesn't exist: "
operator|+
name|link
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" ... source: "
operator|+
name|source
operator|.
name|toURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|idsToFiles
operator|.
name|containsKey
argument_list|(
name|frag
argument_list|)
operator|)
operator|||
comment|// no file contains this id, or...
comment|// id exists, but not in linked file
operator|(
operator|!
name|idsToFiles
operator|.
name|get
argument_list|(
name|frag
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|path
argument_list|)
operator|)
condition|)
block|{
name|problems
operator|++
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Relative link points at id that doesn't exist in dest: "
operator|+
name|link
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" ... source: "
operator|+
name|source
operator|.
name|toURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
literal|0
operator|<
name|problems
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Total of "
operator|+
name|problems
operator|+
literal|" problems found"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|readFile
specifier|static
name|String
name|readFile
parameter_list|(
name|String
name|fileName
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|in
init|=
operator|new
name|FileInputStream
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|Reader
name|reader
init|=
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
name|BufferedReader
name|br
init|=
operator|new
name|BufferedReader
argument_list|(
name|reader
argument_list|)
decl_stmt|;
try|try
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|line
init|=
name|br
operator|.
name|readLine
argument_list|()
decl_stmt|;
while|while
condition|(
name|line
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|line
operator|=
name|br
operator|.
name|readLine
argument_list|()
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
finally|finally
block|{
name|br
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

