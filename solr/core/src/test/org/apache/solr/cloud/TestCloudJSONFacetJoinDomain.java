begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|SolrTestCaseJ4
operator|.
name|SuppressPointFields
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|embedded
operator|.
name|JettySolrRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|CloudSolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|HttpSolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|CollectionAdminRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|QueryRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**   *<p>  * Tests randomized JSON Facets, sometimes using query 'join' domain transfers and/or domain 'filter' options  *</p>  *<p>  * The results of each facet constraint count will be compared with a verification query using an equivilent filter  *</p>  *   * @see TestCloudPivotFacet  */
end_comment

begin_class
annotation|@
name|SuppressPointFields
argument_list|(
name|bugUrl
operator|=
literal|"https://issues.apache.org/jira/browse/SOLR-9989"
argument_list|)
DECL|class|TestCloudJSONFacetJoinDomain
specifier|public
class|class
name|TestCloudJSONFacetJoinDomain
extends|extends
name|SolrCloudTestCase
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|DEBUG_LABEL
specifier|private
specifier|static
specifier|final
name|String
name|DEBUG_LABEL
init|=
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
DECL|field|COLLECTION_NAME
specifier|private
specifier|static
specifier|final
name|String
name|COLLECTION_NAME
init|=
name|DEBUG_LABEL
operator|+
literal|"_collection"
decl_stmt|;
DECL|field|MAX_FIELD_NUM
specifier|private
specifier|static
specifier|final
name|int
name|MAX_FIELD_NUM
init|=
literal|15
decl_stmt|;
DECL|field|UNIQUE_FIELD_VALS
specifier|private
specifier|static
specifier|final
name|int
name|UNIQUE_FIELD_VALS
init|=
literal|20
decl_stmt|;
DECL|field|FACET_LIMIT
specifier|private
specifier|static
specifier|final
name|int
name|FACET_LIMIT
init|=
name|UNIQUE_FIELD_VALS
operator|+
literal|1
decl_stmt|;
comment|/** Multivalued string field suffixes that can be randomized for testing diff facet/join code paths */
DECL|field|STR_FIELD_SUFFIXES
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|STR_FIELD_SUFFIXES
init|=
operator|new
name|String
index|[]
block|{
literal|"_ss"
block|,
literal|"_sds"
block|,
literal|"_sdsS"
block|}
decl_stmt|;
comment|/** Multivalued int field suffixes that can be randomized for testing diff facet/join code paths */
DECL|field|INT_FIELD_SUFFIXES
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|INT_FIELD_SUFFIXES
init|=
operator|new
name|String
index|[]
block|{
literal|"_is"
block|,
literal|"_ids"
block|,
literal|"_idsS"
block|}
decl_stmt|;
comment|/** A basic client for operations at the cloud level, default collection will be set */
DECL|field|CLOUD_CLIENT
specifier|private
specifier|static
name|CloudSolrClient
name|CLOUD_CLIENT
decl_stmt|;
comment|/** One client per node */
DECL|field|CLIENTS
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|HttpSolrClient
argument_list|>
name|CLIENTS
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|5
argument_list|)
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|createMiniSolrCloudCluster
specifier|private
specifier|static
name|void
name|createMiniSolrCloudCluster
parameter_list|()
throws|throws
name|Exception
block|{
comment|// sanity check constants
name|assertTrue
argument_list|(
literal|"bad test constants: must have UNIQUE_FIELD_VALS< FACET_LIMIT since refinement not currently supported"
argument_list|,
name|UNIQUE_FIELD_VALS
operator|<
name|FACET_LIMIT
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"bad test constants: some suffixes will never be tested"
argument_list|,
operator|(
name|STR_FIELD_SUFFIXES
operator|.
name|length
operator|<
name|MAX_FIELD_NUM
operator|)
operator|&&
operator|(
name|INT_FIELD_SUFFIXES
operator|.
name|length
operator|<
name|MAX_FIELD_NUM
operator|)
argument_list|)
expr_stmt|;
comment|// multi replicas should not matter...
specifier|final
name|int
name|repFactor
init|=
name|usually
argument_list|()
condition|?
literal|1
else|:
literal|2
decl_stmt|;
comment|// ... but we definitely want to test multiple shards
specifier|final
name|int
name|numShards
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
operator|(
name|usually
argument_list|()
condition|?
literal|2
else|:
literal|3
operator|)
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numNodes
init|=
operator|(
name|numShards
operator|*
name|repFactor
operator|)
decl_stmt|;
specifier|final
name|String
name|configName
init|=
name|DEBUG_LABEL
operator|+
literal|"_config-set"
decl_stmt|;
specifier|final
name|Path
name|configDir
init|=
name|Paths
operator|.
name|get
argument_list|(
name|TEST_HOME
argument_list|()
argument_list|,
literal|"collection1"
argument_list|,
literal|"conf"
argument_list|)
decl_stmt|;
name|configureCluster
argument_list|(
name|numNodes
argument_list|)
operator|.
name|addConfig
argument_list|(
name|configName
argument_list|,
name|configDir
argument_list|)
operator|.
name|configure
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|collectionProperties
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|collectionProperties
operator|.
name|put
argument_list|(
literal|"config"
argument_list|,
literal|"solrconfig-tlog.xml"
argument_list|)
expr_stmt|;
name|collectionProperties
operator|.
name|put
argument_list|(
literal|"schema"
argument_list|,
literal|"schema_latest.xml"
argument_list|)
expr_stmt|;
name|CollectionAdminRequest
operator|.
name|createCollection
argument_list|(
name|COLLECTION_NAME
argument_list|,
name|configName
argument_list|,
name|numShards
argument_list|,
name|repFactor
argument_list|)
operator|.
name|setProperties
argument_list|(
name|collectionProperties
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
name|CLOUD_CLIENT
operator|=
name|cluster
operator|.
name|getSolrClient
argument_list|()
expr_stmt|;
name|CLOUD_CLIENT
operator|.
name|setDefaultCollection
argument_list|(
name|COLLECTION_NAME
argument_list|)
expr_stmt|;
name|waitForRecoveriesToFinish
argument_list|(
name|CLOUD_CLIENT
argument_list|)
expr_stmt|;
for|for
control|(
name|JettySolrRunner
name|jetty
range|:
name|cluster
operator|.
name|getJettySolrRunners
argument_list|()
control|)
block|{
name|CLIENTS
operator|.
name|add
argument_list|(
name|getHttpSolrClient
argument_list|(
name|jetty
operator|.
name|getBaseUrl
argument_list|()
operator|+
literal|"/"
operator|+
name|COLLECTION_NAME
operator|+
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|numDocs
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|id
init|=
literal|0
init|;
name|id
operator|<
name|numDocs
condition|;
name|id
operator|++
control|)
block|{
name|SolrInputDocument
name|doc
init|=
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|id
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|fieldNum
init|=
literal|0
init|;
name|fieldNum
operator|<
name|MAX_FIELD_NUM
condition|;
name|fieldNum
operator|++
control|)
block|{
comment|// NOTE: some docs may have no value in a field
specifier|final
name|int
name|numValsThisDoc
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
operator|(
name|usually
argument_list|()
condition|?
literal|3
else|:
literal|6
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|v
init|=
literal|0
init|;
name|v
operator|<
name|numValsThisDoc
condition|;
name|v
operator|++
control|)
block|{
specifier|final
name|String
name|fieldValue
init|=
name|randFieldValue
argument_list|(
name|fieldNum
argument_list|)
decl_stmt|;
comment|// for each fieldNum, there are actaully two fields: one string, and one integer
name|doc
operator|.
name|addField
argument_list|(
name|field
argument_list|(
name|STR_FIELD_SUFFIXES
argument_list|,
name|fieldNum
argument_list|)
argument_list|,
name|fieldValue
argument_list|)
expr_stmt|;
name|doc
operator|.
name|addField
argument_list|(
name|field
argument_list|(
name|INT_FIELD_SUFFIXES
argument_list|,
name|fieldNum
argument_list|)
argument_list|,
name|fieldValue
argument_list|)
expr_stmt|;
block|}
block|}
name|CLOUD_CLIENT
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|CLOUD_CLIENT
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
comment|/**    * Given a (random) number, and a (static) array of possible suffixes returns a consistent field name that     * uses that number and one of hte specified suffixes in it's name.    *    * @see #STR_FIELD_SUFFIXES    * @see #INT_FIELD_SUFFIXES    * @see #MAX_FIELD_NUM    * @see #randFieldValue    */
DECL|method|field
specifier|private
specifier|static
name|String
name|field
parameter_list|(
specifier|final
name|String
index|[]
name|suffixes
parameter_list|,
specifier|final
name|int
name|fieldNum
parameter_list|)
block|{
assert|assert
name|fieldNum
operator|<
name|MAX_FIELD_NUM
assert|;
specifier|final
name|String
name|suffix
init|=
name|suffixes
index|[
name|fieldNum
operator|%
name|suffixes
operator|.
name|length
index|]
decl_stmt|;
return|return
literal|"field_"
operator|+
name|fieldNum
operator|+
name|suffix
return|;
block|}
DECL|method|strfield
specifier|private
specifier|static
name|String
name|strfield
parameter_list|(
specifier|final
name|int
name|fieldNum
parameter_list|)
block|{
return|return
name|field
argument_list|(
name|STR_FIELD_SUFFIXES
argument_list|,
name|fieldNum
argument_list|)
return|;
block|}
DECL|method|intfield
specifier|private
specifier|static
name|String
name|intfield
parameter_list|(
specifier|final
name|int
name|fieldNum
parameter_list|)
block|{
return|return
name|field
argument_list|(
name|INT_FIELD_SUFFIXES
argument_list|,
name|fieldNum
argument_list|)
return|;
block|}
comment|/**    * Given a (random) field number, returns a random (integer based) value for that field.    * NOTE: The number of unique values in each field is constant acording to {@link #UNIQUE_FIELD_VALS}    * but the cise pr<em>range</em> of values will vary for each unique field number, such that cross field joins     * will match fewer documents based on how far apart the field numbers are.    *    * @see #UNIQUE_FIELD_VALS    * @see #field    */
DECL|method|randFieldValue
specifier|private
specifier|static
name|String
name|randFieldValue
parameter_list|(
specifier|final
name|int
name|fieldNum
parameter_list|)
block|{
return|return
literal|""
operator|+
operator|(
name|fieldNum
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|UNIQUE_FIELD_VALS
argument_list|)
operator|)
return|;
block|}
annotation|@
name|AfterClass
DECL|method|afterClass
specifier|private
specifier|static
name|void
name|afterClass
parameter_list|()
throws|throws
name|Exception
block|{
name|CLOUD_CLIENT
operator|.
name|close
argument_list|()
expr_stmt|;
name|CLOUD_CLIENT
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|HttpSolrClient
name|client
range|:
name|CLIENTS
control|)
block|{
name|client
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|CLIENTS
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Sanity check that malformed requests produce errors */
DECL|method|testMalformedGivesError
specifier|public
name|void
name|testMalformedGivesError
parameter_list|()
throws|throws
name|Exception
block|{
name|ignoreException
argument_list|(
literal|".*'join' domain change.*"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|join
range|:
name|Arrays
operator|.
name|asList
argument_list|(
literal|"bogus"
argument_list|,
literal|"{ }"
argument_list|,
literal|"{ from:null, to:foo_s }"
argument_list|,
literal|"{ from:foo_s }"
argument_list|,
literal|"{ from:foo_s, to:foo_s, bogus:'what what?' }"
argument_list|,
literal|"{ to:foo_s, bogus:'what what?' }"
argument_list|)
control|)
block|{
name|SolrException
name|e
init|=
name|expectThrows
argument_list|(
name|SolrException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
specifier|final
name|SolrParams
name|req
init|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"json.facet"
argument_list|,
literal|"{ x : { type:terms, field:x_s, domain: { join:"
operator|+
name|join
operator|+
literal|" } } }"
argument_list|)
decl_stmt|;
specifier|final
name|NamedList
name|trash
init|=
name|getRandClient
argument_list|(
name|random
argument_list|()
argument_list|)
operator|.
name|request
argument_list|(
operator|new
name|QueryRequest
argument_list|(
name|req
argument_list|)
argument_list|)
decl_stmt|;
block|}
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|join
operator|+
literal|" -> "
operator|+
name|e
argument_list|,
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
operator|.
name|code
argument_list|,
name|e
operator|.
name|code
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|join
operator|+
literal|" -> "
operator|+
name|e
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"'join' domain change"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testSanityCheckDomainMethods
specifier|public
name|void
name|testSanityCheckDomainMethods
parameter_list|()
throws|throws
name|Exception
block|{
block|{
specifier|final
name|JoinDomain
name|empty
init|=
operator|new
name|JoinDomain
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|null
argument_list|,
name|empty
operator|.
name|toJSONFacetParamValue
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SolrParams
name|out
init|=
name|empty
operator|.
name|applyDomainToQuery
argument_list|(
literal|"safe_key"
argument_list|,
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"qqq"
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|null
argument_list|,
name|out
operator|.
name|get
argument_list|(
literal|"safe_key"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"qqq"
argument_list|,
name|out
operator|.
name|get
argument_list|(
literal|"q"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
specifier|final
name|JoinDomain
name|join
init|=
operator|new
name|JoinDomain
argument_list|(
literal|"xxx"
argument_list|,
literal|"yyy"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"domain:{join:{from:xxx,to:yyy}}"
argument_list|,
name|join
operator|.
name|toJSONFacetParamValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SolrParams
name|out
init|=
name|join
operator|.
name|applyDomainToQuery
argument_list|(
literal|"safe_key"
argument_list|,
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"qqq"
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"qqq"
argument_list|,
name|out
operator|.
name|get
argument_list|(
literal|"safe_key"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"{!join from=xxx to=yyy v=$safe_key}"
argument_list|,
name|out
operator|.
name|get
argument_list|(
literal|"q"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
specifier|final
name|JoinDomain
name|filter
init|=
operator|new
name|JoinDomain
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"zzz"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"domain:{filter:'zzz'}"
argument_list|,
name|filter
operator|.
name|toJSONFacetParamValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SolrParams
name|out
init|=
name|filter
operator|.
name|applyDomainToQuery
argument_list|(
literal|"safe_key"
argument_list|,
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"qqq"
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|null
argument_list|,
name|out
operator|.
name|get
argument_list|(
literal|"safe_key"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"zzz AND qqq"
argument_list|,
name|out
operator|.
name|get
argument_list|(
literal|"q"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
specifier|final
name|JoinDomain
name|both
init|=
operator|new
name|JoinDomain
argument_list|(
literal|"xxx"
argument_list|,
literal|"yyy"
argument_list|,
literal|"zzz"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"domain:{join:{from:xxx,to:yyy},filter:'zzz'}"
argument_list|,
name|both
operator|.
name|toJSONFacetParamValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SolrParams
name|out
init|=
name|both
operator|.
name|applyDomainToQuery
argument_list|(
literal|"safe_key"
argument_list|,
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"qqq"
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"qqq"
argument_list|,
name|out
operator|.
name|get
argument_list|(
literal|"safe_key"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"zzz AND {!join from=xxx to=yyy v=$safe_key}"
argument_list|,
name|out
operator|.
name|get
argument_list|(
literal|"q"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Test some small, hand crafted, but non-trivial queries that are    * easier to trace/debug then a pure random monstrosity.    * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)    */
DECL|method|testBespoke
specifier|public
name|void
name|testBespoke
parameter_list|()
throws|throws
name|Exception
block|{
block|{
comment|// strings
name|Map
argument_list|<
name|String
argument_list|,
name|TermFacet
argument_list|>
name|facets
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|TermFacet
name|top
init|=
operator|new
name|TermFacet
argument_list|(
name|strfield
argument_list|(
literal|9
argument_list|)
argument_list|,
operator|new
name|JoinDomain
argument_list|(
name|strfield
argument_list|(
literal|5
argument_list|)
argument_list|,
name|strfield
argument_list|(
literal|9
argument_list|)
argument_list|,
name|strfield
argument_list|(
literal|9
argument_list|)
operator|+
literal|":[* TO *]"
argument_list|)
argument_list|)
decl_stmt|;
name|top
operator|.
name|subFacets
operator|.
name|put
argument_list|(
literal|"facet_5"
argument_list|,
operator|new
name|TermFacet
argument_list|(
name|strfield
argument_list|(
literal|11
argument_list|)
argument_list|,
operator|new
name|JoinDomain
argument_list|(
name|strfield
argument_list|(
literal|8
argument_list|)
argument_list|,
name|strfield
argument_list|(
literal|8
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|facets
operator|.
name|put
argument_list|(
literal|"facet_4"
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|assertFacetCountsAreCorrect
argument_list|(
name|facets
argument_list|,
literal|"("
operator|+
name|strfield
argument_list|(
literal|7
argument_list|)
operator|+
literal|":6 OR "
operator|+
name|strfield
argument_list|(
literal|9
argument_list|)
operator|+
literal|":6 OR "
operator|+
name|strfield
argument_list|(
literal|6
argument_list|)
operator|+
literal|":19 OR "
operator|+
name|strfield
argument_list|(
literal|0
argument_list|)
operator|+
literal|":11)"
argument_list|)
expr_stmt|;
block|}
block|{
comment|// ints
name|Map
argument_list|<
name|String
argument_list|,
name|TermFacet
argument_list|>
name|facets
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|TermFacet
name|top
init|=
operator|new
name|TermFacet
argument_list|(
name|intfield
argument_list|(
literal|9
argument_list|)
argument_list|,
operator|new
name|JoinDomain
argument_list|(
name|intfield
argument_list|(
literal|5
argument_list|)
argument_list|,
name|intfield
argument_list|(
literal|9
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|facets
operator|.
name|put
argument_list|(
literal|"top"
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|assertFacetCountsAreCorrect
argument_list|(
name|facets
argument_list|,
literal|"("
operator|+
name|intfield
argument_list|(
literal|7
argument_list|)
operator|+
literal|":6 OR "
operator|+
name|intfield
argument_list|(
literal|3
argument_list|)
operator|+
literal|":3)"
argument_list|)
expr_stmt|;
block|}
block|{
comment|// some domains with filter only, no actual join
name|Map
argument_list|<
name|String
argument_list|,
name|TermFacet
argument_list|>
name|facets
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|TermFacet
name|top
init|=
operator|new
name|TermFacet
argument_list|(
name|strfield
argument_list|(
literal|9
argument_list|)
argument_list|,
operator|new
name|JoinDomain
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|strfield
argument_list|(
literal|9
argument_list|)
operator|+
literal|":[* TO *]"
argument_list|)
argument_list|)
decl_stmt|;
name|top
operator|.
name|subFacets
operator|.
name|put
argument_list|(
literal|"facet_5"
argument_list|,
operator|new
name|TermFacet
argument_list|(
name|strfield
argument_list|(
literal|11
argument_list|)
argument_list|,
operator|new
name|JoinDomain
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|strfield
argument_list|(
literal|3
argument_list|)
operator|+
literal|":[* TO 5]"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|facets
operator|.
name|put
argument_list|(
literal|"top"
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|assertFacetCountsAreCorrect
argument_list|(
name|facets
argument_list|,
literal|"("
operator|+
name|strfield
argument_list|(
literal|7
argument_list|)
operator|+
literal|":6 OR "
operator|+
name|strfield
argument_list|(
literal|9
argument_list|)
operator|+
literal|":6 OR "
operator|+
name|strfield
argument_list|(
literal|6
argument_list|)
operator|+
literal|":19 OR "
operator|+
name|strfield
argument_list|(
literal|0
argument_list|)
operator|+
literal|":11)"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testRandom
specifier|public
name|void
name|testRandom
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|numIters
init|=
name|atLeast
argument_list|(
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|numIters
condition|;
name|iter
operator|++
control|)
block|{
name|assertFacetCountsAreCorrect
argument_list|(
name|TermFacet
operator|.
name|buildRandomFacets
argument_list|()
argument_list|,
name|buildRandomQuery
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Generates a random query string across the randomized fields/values in the index    *    * @see #randFieldValue    * @see #field    */
DECL|method|buildRandomQuery
specifier|private
specifier|static
name|String
name|buildRandomQuery
parameter_list|()
block|{
if|if
condition|(
literal|0
operator|==
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
condition|)
block|{
return|return
literal|"*:*"
return|;
block|}
specifier|final
name|int
name|numClauses
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|3
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|clauses
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|numClauses
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|numClauses
condition|;
name|c
operator|++
control|)
block|{
specifier|final
name|int
name|fieldNum
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|MAX_FIELD_NUM
argument_list|)
decl_stmt|;
comment|// keep queries simple, just use str fields - not point of test
name|clauses
operator|.
name|add
argument_list|(
name|strfield
argument_list|(
name|fieldNum
argument_list|)
operator|+
literal|":"
operator|+
name|randFieldValue
argument_list|(
name|fieldNum
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|"("
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
name|clauses
argument_list|,
literal|" OR "
argument_list|)
operator|+
literal|")"
return|;
block|}
comment|/**    * Given a set of (potentially nested) term facets, and a base query string, asserts that     * the actual counts returned when executing that query with those facets match the expected results    * of filtering on the equivilent facet terms+domain    */
DECL|method|assertFacetCountsAreCorrect
specifier|private
name|void
name|assertFacetCountsAreCorrect
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|TermFacet
argument_list|>
name|expected
parameter_list|,
specifier|final
name|String
name|query
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
specifier|final
name|SolrParams
name|baseParams
init|=
name|params
argument_list|(
literal|"q"
argument_list|,
name|query
argument_list|,
literal|"rows"
argument_list|,
literal|"0"
argument_list|)
decl_stmt|;
specifier|final
name|SolrParams
name|facetParams
init|=
name|params
argument_list|(
literal|"json.facet"
argument_list|,
literal|""
operator|+
name|TermFacet
operator|.
name|toJSONFacetParamValue
argument_list|(
name|expected
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SolrParams
name|initParams
init|=
name|SolrParams
operator|.
name|wrapAppended
argument_list|(
name|facetParams
argument_list|,
name|baseParams
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Doing full run: {}"
argument_list|,
name|initParams
argument_list|)
expr_stmt|;
name|NamedList
name|topResponse
init|=
literal|null
decl_stmt|;
try|try
block|{
name|topResponse
operator|=
name|getRandClient
argument_list|(
name|random
argument_list|()
argument_list|)
operator|.
name|request
argument_list|(
operator|new
name|QueryRequest
argument_list|(
name|initParams
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|initParams
operator|+
literal|" is null response?"
argument_list|,
name|topResponse
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"init query failed: "
operator|+
name|initParams
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
specifier|final
name|NamedList
name|facetResponse
init|=
operator|(
name|NamedList
operator|)
name|topResponse
operator|.
name|get
argument_list|(
literal|"facets"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"null facet results?"
argument_list|,
name|facetResponse
argument_list|)
expr_stmt|;
name|assertFacetCountsAreCorrect
argument_list|(
name|expected
argument_list|,
name|baseParams
argument_list|,
name|facetResponse
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|initParams
operator|+
literal|" ===> "
operator|+
name|topResponse
operator|+
literal|" --> "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Ending full run"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Recursive Helper method that walks the actual facet response, comparing the counts to the expected output     * based on the equivilent filters generated from the original TermFacet.    */
DECL|method|assertFacetCountsAreCorrect
specifier|private
name|void
name|assertFacetCountsAreCorrect
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|TermFacet
argument_list|>
name|expected
parameter_list|,
name|SolrParams
name|baseParams
parameter_list|,
name|NamedList
name|actualFacetResponse
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|TermFacet
argument_list|>
name|entry
range|:
name|expected
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|facetKey
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|TermFacet
name|facet
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|NamedList
name|results
init|=
operator|(
name|NamedList
operator|)
name|actualFacetResponse
operator|.
name|get
argument_list|(
name|facetKey
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|facetKey
operator|+
literal|" key missing from: "
operator|+
name|actualFacetResponse
argument_list|,
name|results
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|NamedList
argument_list|>
name|buckets
init|=
operator|(
name|List
argument_list|<
name|NamedList
argument_list|>
operator|)
name|results
operator|.
name|get
argument_list|(
literal|"buckets"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|facetKey
operator|+
literal|" has null buckets: "
operator|+
name|actualFacetResponse
argument_list|,
name|buckets
argument_list|)
expr_stmt|;
for|for
control|(
name|NamedList
name|bucket
range|:
name|buckets
control|)
block|{
specifier|final
name|long
name|count
init|=
operator|(
operator|(
name|Number
operator|)
name|bucket
operator|.
name|get
argument_list|(
literal|"count"
argument_list|)
operator|)
operator|.
name|longValue
argument_list|()
decl_stmt|;
specifier|final
name|String
name|fieldVal
init|=
name|bucket
operator|.
name|get
argument_list|(
literal|"val"
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// int or stringified int
comment|// change our query to filter on the fieldVal, and wrap in the facet domain (if any)
specifier|final
name|SolrParams
name|verifyParams
init|=
name|facet
operator|.
name|applyValueConstraintAndDomain
argument_list|(
name|baseParams
argument_list|,
name|facetKey
argument_list|,
name|fieldVal
argument_list|)
decl_stmt|;
comment|// check the count for this bucket
name|assertEquals
argument_list|(
name|facetKey
operator|+
literal|": "
operator|+
name|verifyParams
argument_list|,
name|count
argument_list|,
name|getRandClient
argument_list|(
name|random
argument_list|()
argument_list|)
operator|.
name|query
argument_list|(
name|verifyParams
argument_list|)
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
comment|// recursively check subFacets
if|if
condition|(
operator|!
name|facet
operator|.
name|subFacets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|assertFacetCountsAreCorrect
argument_list|(
name|facet
operator|.
name|subFacets
argument_list|,
name|verifyParams
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|assertTrue
argument_list|(
literal|"facets have unexpeted keys left over: "
operator|+
name|actualFacetResponse
argument_list|,
comment|// should alwasy be a count, maybe a 'val' if we're a subfacet
operator|(
name|actualFacetResponse
operator|.
name|size
argument_list|()
operator|==
name|expected
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|)
operator|||
operator|(
name|actualFacetResponse
operator|.
name|size
argument_list|()
operator|==
name|expected
operator|.
name|size
argument_list|()
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Trivial data structure for modeling a simple terms facet that can be written out as a json.facet param.    *    * Doesn't do any string escaping or quoting, so don't use whitespace or reserved json characters    */
DECL|class|TermFacet
specifier|private
specifier|static
specifier|final
class|class
name|TermFacet
block|{
DECL|field|field
specifier|public
specifier|final
name|String
name|field
decl_stmt|;
DECL|field|subFacets
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|TermFacet
argument_list|>
name|subFacets
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|domain
specifier|public
specifier|final
name|JoinDomain
name|domain
decl_stmt|;
comment|// may be null
DECL|method|TermFacet
specifier|public
name|TermFacet
parameter_list|(
name|String
name|field
parameter_list|,
name|JoinDomain
name|domain
parameter_list|)
block|{
assert|assert
literal|null
operator|!=
name|field
assert|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|domain
operator|=
name|domain
expr_stmt|;
block|}
comment|/**       * Returns new SolrParams that:      *<ul>      *<li>copy the original SolrParams</li>      *<li>modify/wrap the original "q" param to capture the domain change for this facet (if any)</li>      *<li>add a filter query against this field with the specified value</li>      *</ul>      *       * @see JoinDomain#applyDomainToQuery      */
DECL|method|applyValueConstraintAndDomain
specifier|public
name|SolrParams
name|applyValueConstraintAndDomain
parameter_list|(
name|SolrParams
name|orig
parameter_list|,
name|String
name|facetKey
parameter_list|,
name|String
name|facetVal
parameter_list|)
block|{
comment|// first wrap our original query in the domain if there is one...
if|if
condition|(
literal|null
operator|!=
name|domain
condition|)
block|{
name|orig
operator|=
name|domain
operator|.
name|applyDomainToQuery
argument_list|(
name|facetKey
operator|+
literal|"_q"
argument_list|,
name|orig
argument_list|)
expr_stmt|;
block|}
comment|// then filter by the facet value we need to test...
specifier|final
name|ModifiableSolrParams
name|out
init|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|orig
argument_list|)
decl_stmt|;
name|out
operator|.
name|set
argument_list|(
literal|"q"
argument_list|,
name|field
operator|+
literal|":"
operator|+
name|facetVal
operator|+
literal|" AND "
operator|+
name|orig
operator|.
name|get
argument_list|(
literal|"q"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
comment|/**      * recursively generates the<code>json.facet</code> param value to use for testing this facet      */
DECL|method|toJSONFacetParamValue
specifier|private
name|CharSequence
name|toJSONFacetParamValue
parameter_list|()
block|{
comment|// NOTE: since refinement isn't supported, we have to use the max cardinality of the field as limit
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"{ type:terms, field:"
operator|+
name|field
operator|+
literal|", limit: "
operator|+
name|FACET_LIMIT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|subFacets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", facet:"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|toJSONFacetParamValue
argument_list|(
name|subFacets
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|domain
condition|)
block|{
name|CharSequence
name|ds
init|=
name|domain
operator|.
name|toJSONFacetParamValue
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|ds
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|sb
return|;
block|}
comment|/**      * Given a set of (possibly nested) facets, generates a suitable<code>json.facet</code> param value to       * use for testing them against in a solr request.      */
DECL|method|toJSONFacetParamValue
specifier|public
specifier|static
name|CharSequence
name|toJSONFacetParamValue
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|TermFacet
argument_list|>
name|facets
parameter_list|)
block|{
assert|assert
literal|null
operator|!=
name|facets
assert|;
assert|assert
literal|0
operator|<
name|facets
operator|.
name|size
argument_list|()
assert|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"{"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|facets
operator|.
name|keySet
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|key
argument_list|)
operator|.
name|append
argument_list|(
literal|" : "
argument_list|)
operator|.
name|append
argument_list|(
name|facets
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|.
name|toJSONFacetParamValue
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" ,"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|sb
return|;
block|}
comment|/**      * Factory method for generating some random (nested) facets.        *      * For simplicity, each facet will have a unique key name, regardless of it's depth under other facets       *      * @see JoinDomain      */
DECL|method|buildRandomFacets
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|TermFacet
argument_list|>
name|buildRandomFacets
parameter_list|()
block|{
comment|// for simplicity, use a unique facet key regardless of depth - simplifies verification
name|AtomicInteger
name|keyCounter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|int
name|maxDepth
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
operator|(
name|usually
argument_list|()
condition|?
literal|2
else|:
literal|3
operator|)
argument_list|)
decl_stmt|;
return|return
name|buildRandomFacets
argument_list|(
name|keyCounter
argument_list|,
name|maxDepth
argument_list|)
return|;
block|}
comment|/**       * recursive helper method for building random facets      *      * @param keyCounter used to ensure every generated facet has a unique key name      * @param maxDepth max possible depth allowed for the recusion, a lower value may be used depending on how many facets are returned at the current level.       */
DECL|method|buildRandomFacets
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|TermFacet
argument_list|>
name|buildRandomFacets
parameter_list|(
name|AtomicInteger
name|keyCounter
parameter_list|,
name|int
name|maxDepth
parameter_list|)
block|{
specifier|final
name|int
name|numFacets
init|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
literal|3
argument_list|)
argument_list|)
decl_stmt|;
comment|// 3/5th chance of being '1'
name|Map
argument_list|<
name|String
argument_list|,
name|TermFacet
argument_list|>
name|results
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFacets
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|JoinDomain
name|domain
init|=
name|JoinDomain
operator|.
name|buildRandomDomain
argument_list|()
decl_stmt|;
assert|assert
literal|null
operator|!=
name|domain
assert|;
specifier|final
name|TermFacet
name|facet
init|=
operator|new
name|TermFacet
argument_list|(
name|field
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
name|STR_FIELD_SUFFIXES
else|:
name|INT_FIELD_SUFFIXES
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|MAX_FIELD_NUM
argument_list|)
argument_list|)
argument_list|,
name|domain
argument_list|)
decl_stmt|;
name|results
operator|.
name|put
argument_list|(
literal|"facet_"
operator|+
name|keyCounter
operator|.
name|incrementAndGet
argument_list|()
argument_list|,
name|facet
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|maxDepth
condition|)
block|{
comment|// if we're going wide, don't go deep
specifier|final
name|int
name|nextMaxDepth
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|maxDepth
operator|-
name|numFacets
argument_list|)
decl_stmt|;
name|facet
operator|.
name|subFacets
operator|.
name|putAll
argument_list|(
name|buildRandomFacets
argument_list|(
name|keyCounter
argument_list|,
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|nextMaxDepth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
return|;
block|}
block|}
comment|/**    * Models a Domain Change which includes either a 'join' or a 'filter' or both    */
DECL|class|JoinDomain
specifier|private
specifier|static
specifier|final
class|class
name|JoinDomain
block|{
DECL|field|from
specifier|public
specifier|final
name|String
name|from
decl_stmt|;
DECL|field|to
specifier|public
specifier|final
name|String
name|to
decl_stmt|;
DECL|field|filter
specifier|public
specifier|final
name|String
name|filter
decl_stmt|;
comment|// not bothering with more then 1 filter, not the point of the test
comment|/**       * @param from left side of join field name, null if domain involves no joining      * @param to right side of join field name, null if domain involves no joining      * @param filter filter to apply to domain, null if domain involves no filtering      */
DECL|method|JoinDomain
specifier|public
name|JoinDomain
parameter_list|(
name|String
name|from
parameter_list|,
name|String
name|to
parameter_list|,
name|String
name|filter
parameter_list|)
block|{
assert|assert
operator|!
operator|(
operator|(
literal|null
operator|==
name|from
operator|)
operator|^
operator|(
literal|null
operator|==
name|to
operator|)
operator|)
operator|:
literal|"if from is null, to must be null"
assert|;
name|this
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|this
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
block|}
comment|/**       * @return the JSON string representing this domain for use in a facet param, or null if no domain should be used      * */
DECL|method|toJSONFacetParamValue
specifier|public
name|CharSequence
name|toJSONFacetParamValue
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|==
name|from
operator|&&
literal|null
operator|==
name|filter
condition|)
block|{
return|return
literal|null
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"domain:{"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|from
condition|)
block|{
assert|assert
literal|null
operator|!=
name|to
assert|;
name|sb
operator|.
name|append
argument_list|(
literal|"join:{from:"
argument_list|)
operator|.
name|append
argument_list|(
name|from
argument_list|)
operator|.
name|append
argument_list|(
literal|",to:"
argument_list|)
operator|.
name|append
argument_list|(
name|to
argument_list|)
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|filter
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|null
operator|!=
name|filter
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"filter:'"
argument_list|)
operator|.
name|append
argument_list|(
name|filter
argument_list|)
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|sb
return|;
block|}
comment|/**       * Given some original SolrParams, returns new SolrParams where the original "q" param is wrapped      * as needed to apply the equivilent transformation to a query as this domain would to a facet      */
DECL|method|applyDomainToQuery
specifier|public
name|SolrParams
name|applyDomainToQuery
parameter_list|(
name|String
name|safeKey
parameter_list|,
name|SolrParams
name|in
parameter_list|)
block|{
assert|assert
literal|null
operator|==
name|in
operator|.
name|get
argument_list|(
name|safeKey
argument_list|)
assert|;
comment|// shouldn't be possible if every facet uses a unique key string
name|String
name|q
init|=
name|in
operator|.
name|get
argument_list|(
literal|"q"
argument_list|)
decl_stmt|;
specifier|final
name|ModifiableSolrParams
name|out
init|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|from
condition|)
block|{
name|out
operator|.
name|set
argument_list|(
name|safeKey
argument_list|,
name|in
operator|.
name|get
argument_list|(
literal|"q"
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
literal|"{!join from="
operator|+
name|from
operator|+
literal|" to="
operator|+
name|to
operator|+
literal|" v=$"
operator|+
name|safeKey
operator|+
literal|"}"
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|filter
condition|)
block|{
name|q
operator|=
name|filter
operator|+
literal|" AND "
operator|+
name|q
expr_stmt|;
block|}
name|out
operator|.
name|set
argument_list|(
literal|"q"
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
comment|/**      * Factory method for creating a random domain change to use with a facet - may return an 'noop' JoinDomain,      * but will never return null.      */
DECL|method|buildRandomDomain
specifier|public
specifier|static
name|JoinDomain
name|buildRandomDomain
parameter_list|()
block|{
comment|// use consistent type on both sides of join
specifier|final
name|String
index|[]
name|suffixes
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
name|STR_FIELD_SUFFIXES
else|:
name|INT_FIELD_SUFFIXES
decl_stmt|;
specifier|final
name|boolean
name|noJoin
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|String
name|from
init|=
name|noJoin
condition|?
literal|null
else|:
name|field
argument_list|(
name|suffixes
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|MAX_FIELD_NUM
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|String
name|to
init|=
name|noJoin
condition|?
literal|null
else|:
name|field
argument_list|(
name|suffixes
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|MAX_FIELD_NUM
argument_list|)
argument_list|)
decl_stmt|;
comment|// keep it simple, only filter on string fields - not point of test
specifier|final
name|String
name|filterField
init|=
name|strfield
argument_list|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|MAX_FIELD_NUM
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|String
name|filter
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|null
else|:
name|filterField
operator|+
literal|":[* TO *]"
decl_stmt|;
return|return
operator|new
name|JoinDomain
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|filter
argument_list|)
return|;
block|}
block|}
comment|/**     * returns a random SolrClient -- either a CloudSolrClient, or an HttpSolrClient pointed     * at a node in our cluster     */
DECL|method|getRandClient
specifier|public
specifier|static
name|SolrClient
name|getRandClient
parameter_list|(
name|Random
name|rand
parameter_list|)
block|{
name|int
name|numClients
init|=
name|CLIENTS
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|0
argument_list|,
name|numClients
argument_list|)
decl_stmt|;
return|return
operator|(
name|idx
operator|==
name|numClients
operator|)
condition|?
name|CLOUD_CLIENT
else|:
name|CLIENTS
operator|.
name|get
argument_list|(
name|idx
argument_list|)
return|;
block|}
DECL|method|waitForRecoveriesToFinish
specifier|public
specifier|static
name|void
name|waitForRecoveriesToFinish
parameter_list|(
name|CloudSolrClient
name|client
parameter_list|)
throws|throws
name|Exception
block|{
assert|assert
literal|null
operator|!=
name|client
operator|.
name|getDefaultCollection
argument_list|()
assert|;
name|AbstractDistribZkTestBase
operator|.
name|waitForRecoveriesToFinish
argument_list|(
name|client
operator|.
name|getDefaultCollection
argument_list|()
argument_list|,
name|client
operator|.
name|getZkStateReader
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|330
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

