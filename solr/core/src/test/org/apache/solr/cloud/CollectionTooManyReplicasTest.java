begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|Slow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|embedded
operator|.
name|JettySolrRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|CollectionAdminRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_class
annotation|@
name|Slow
DECL|class|CollectionTooManyReplicasTest
specifier|public
class|class
name|CollectionTooManyReplicasTest
extends|extends
name|SolrCloudTestCase
block|{
annotation|@
name|BeforeClass
DECL|method|setupCluster
specifier|public
specifier|static
name|void
name|setupCluster
parameter_list|()
throws|throws
name|Exception
block|{
name|configureCluster
argument_list|(
literal|3
argument_list|)
operator|.
name|addConfig
argument_list|(
literal|"conf"
argument_list|,
name|configset
argument_list|(
literal|"cloud-minimal"
argument_list|)
argument_list|)
operator|.
name|configure
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Before
DECL|method|deleteCollections
specifier|public
name|void
name|deleteCollections
parameter_list|()
throws|throws
name|Exception
block|{
name|cluster
operator|.
name|deleteAllCollections
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAddTooManyReplicas
specifier|public
name|void
name|testAddTooManyReplicas
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|collectionName
init|=
literal|"TooManyReplicasInSeveralFlavors"
decl_stmt|;
name|CollectionAdminRequest
operator|.
name|createCollection
argument_list|(
name|collectionName
argument_list|,
literal|"conf"
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
operator|.
name|setMaxShardsPerNode
argument_list|(
literal|1
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
comment|// I have two replicas, one for each shard
comment|// Curiously, I should be able to add a bunch of replicas if I specify the node, even more than maxShardsPerNode
comment|// Just get the first node any way we can.
comment|// Get a node to use for the "node" parameter.
name|String
name|nodeName
init|=
name|getAllNodeNames
argument_list|(
name|collectionName
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Add a replica using the "node" parameter (no "too many replicas check")
comment|// this node should have 2 replicas on it
name|CollectionAdminRequest
operator|.
name|addReplicaToShard
argument_list|(
name|collectionName
argument_list|,
literal|"shard1"
argument_list|)
operator|.
name|setNode
argument_list|(
name|nodeName
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
comment|// Three replicas so far, should be able to create another one "normally"
name|CollectionAdminRequest
operator|.
name|addReplicaToShard
argument_list|(
name|collectionName
argument_list|,
literal|"shard1"
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
comment|// This one should fail though, no "node" parameter specified
name|Exception
name|e
init|=
name|expectThrows
argument_list|(
name|Exception
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|CollectionAdminRequest
operator|.
name|addReplicaToShard
argument_list|(
name|collectionName
argument_list|,
literal|"shard1"
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Should have gotten the right error message back"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"given the current number of live nodes and a maxShardsPerNode of"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Oddly, we should succeed next just because setting property.name will not check for nodes being "full up"
comment|// TODO: Isn't this a bug?
name|CollectionAdminRequest
operator|.
name|addReplicaToShard
argument_list|(
name|collectionName
argument_list|,
literal|"shard1"
argument_list|)
operator|.
name|withProperty
argument_list|(
literal|"name"
argument_list|,
literal|"bogus2"
argument_list|)
operator|.
name|setNode
argument_list|(
name|nodeName
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
name|DocCollection
name|collectionState
init|=
name|getCollectionState
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
name|Slice
name|slice
init|=
name|collectionState
operator|.
name|getSlice
argument_list|(
literal|"shard1"
argument_list|)
decl_stmt|;
name|Replica
name|replica
init|=
name|getRandomReplica
argument_list|(
name|slice
argument_list|,
name|r
lambda|->
name|r
operator|.
name|getCoreName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"bogus2"
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Should have found a replica named 'bogus2'"
argument_list|,
name|replica
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Replica should have been put on correct core"
argument_list|,
name|nodeName
argument_list|,
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Shard1 should have 4 replicas
name|assertEquals
argument_list|(
literal|"There should be 4 replicas for shard 1"
argument_list|,
literal|4
argument_list|,
name|slice
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// And let's fail one more time because to ensure that the math doesn't do weird stuff it we have more replicas
comment|// than simple calcs would indicate.
name|Exception
name|e2
init|=
name|expectThrows
argument_list|(
name|Exception
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|CollectionAdminRequest
operator|.
name|addReplicaToShard
argument_list|(
name|collectionName
argument_list|,
literal|"shard1"
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Should have gotten the right error message back"
argument_list|,
name|e2
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"given the current number of live nodes and a maxShardsPerNode of"
argument_list|)
argument_list|)
expr_stmt|;
comment|// wait for recoveries to finish, for a clean shutdown - see SOLR-9645
name|waitForState
argument_list|(
literal|"Expected to see all replicas active"
argument_list|,
name|collectionName
argument_list|,
parameter_list|(
name|n
parameter_list|,
name|c
parameter_list|)
lambda|->
block|{
for|for
control|(
name|Replica
name|r
range|:
name|c
operator|.
name|getReplicas
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|.
name|getState
argument_list|()
operator|!=
name|Replica
operator|.
name|State
operator|.
name|ACTIVE
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAddShard
specifier|public
name|void
name|testAddShard
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|collectionName
init|=
literal|"TooManyReplicasWhenAddingShards"
decl_stmt|;
name|CollectionAdminRequest
operator|.
name|createCollectionWithImplicitRouter
argument_list|(
name|collectionName
argument_list|,
literal|"conf"
argument_list|,
literal|"shardstart"
argument_list|,
literal|2
argument_list|)
operator|.
name|setMaxShardsPerNode
argument_list|(
literal|2
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
comment|// We have two nodes, maxShardsPerNode is set to 2. Therefore, we should be able to add 2 shards each with
comment|// two replicas, but fail on the third.
name|CollectionAdminRequest
operator|.
name|createShard
argument_list|(
name|collectionName
argument_list|,
literal|"shard1"
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now we should have one replica on each Jetty, add another to reach maxShardsPerNode
name|CollectionAdminRequest
operator|.
name|createShard
argument_list|(
name|collectionName
argument_list|,
literal|"shard2"
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now fail to add the third as it should exceed maxShardsPerNode
name|Exception
name|e
init|=
name|expectThrows
argument_list|(
name|Exception
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|CollectionAdminRequest
operator|.
name|createShard
argument_list|(
name|collectionName
argument_list|,
literal|"shard3"
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Should have gotten the right error message back"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"given the current number of live nodes and a maxShardsPerNode of"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Hmmm, providing a nodeset also overrides the checks for max replicas, so prove it.
name|List
argument_list|<
name|String
argument_list|>
name|nodes
init|=
name|getAllNodeNames
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
name|CollectionAdminRequest
operator|.
name|createShard
argument_list|(
name|collectionName
argument_list|,
literal|"shard4"
argument_list|)
operator|.
name|setNodeSet
argument_list|(
name|StringUtils
operator|.
name|join
argument_list|(
name|nodes
argument_list|,
literal|","
argument_list|)
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
comment|// And just for yucks, insure we fail the "regular" one again.
name|Exception
name|e2
init|=
name|expectThrows
argument_list|(
name|Exception
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|CollectionAdminRequest
operator|.
name|createShard
argument_list|(
name|collectionName
argument_list|,
literal|"shard5"
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Should have gotten the right error message back"
argument_list|,
name|e2
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"given the current number of live nodes and a maxShardsPerNode of"
argument_list|)
argument_list|)
expr_stmt|;
comment|// And finally, insure that there are all the replcias we expect. We should have shards 1, 2 and 4 and each
comment|// should have exactly two replicas
name|waitForState
argument_list|(
literal|"Expected shards shardstart, 1, 2 and 4, each with two active replicas"
argument_list|,
name|collectionName
argument_list|,
parameter_list|(
name|n
parameter_list|,
name|c
parameter_list|)
lambda|->
block|{
return|return
name|DocCollection
operator|.
name|isFullyActive
argument_list|(
name|n
argument_list|,
name|c
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|)
return|;
block|}
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|slices
init|=
name|getCollectionState
argument_list|(
name|collectionName
argument_list|)
operator|.
name|getSlicesMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"There should be exaclty four slices"
argument_list|,
name|slices
operator|.
name|size
argument_list|()
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"shardstart should exist"
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shardstart"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"shard1 should exist"
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shard1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"shard2 should exist"
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shard2"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"shard4 should exist"
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shard4"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Shardstart should have exactly 2 replicas"
argument_list|,
literal|2
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shardstart"
argument_list|)
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Shard1 should have exactly 2 replicas"
argument_list|,
literal|2
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shard1"
argument_list|)
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Shard2 should have exactly 2 replicas"
argument_list|,
literal|2
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shard2"
argument_list|)
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Shard4 should have exactly 2 replicas"
argument_list|,
literal|2
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shard4"
argument_list|)
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDownedShards
specifier|public
name|void
name|testDownedShards
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|collectionName
init|=
literal|"TooManyReplicasWhenAddingDownedNode"
decl_stmt|;
name|CollectionAdminRequest
operator|.
name|createCollectionWithImplicitRouter
argument_list|(
name|collectionName
argument_list|,
literal|"conf"
argument_list|,
literal|"shardstart"
argument_list|,
literal|1
argument_list|)
operator|.
name|setMaxShardsPerNode
argument_list|(
literal|2
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
comment|// Shut down a Jetty, I really don't care which
name|JettySolrRunner
name|jetty
init|=
name|cluster
operator|.
name|getRandomJetty
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|deadNode
init|=
name|jetty
operator|.
name|getBaseUrl
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|stopJettySolrRunner
argument_list|(
name|jetty
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Adding a replica on a dead node should fail
name|Exception
name|e1
init|=
name|expectThrows
argument_list|(
name|Exception
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|CollectionAdminRequest
operator|.
name|addReplicaToShard
argument_list|(
name|collectionName
argument_list|,
literal|"shardstart"
argument_list|)
operator|.
name|setNode
argument_list|(
name|deadNode
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Should have gotten a message about shard not "
argument_list|,
name|e1
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"At least one of the node(s) specified are not currently active, no action taken."
argument_list|)
argument_list|)
expr_stmt|;
comment|// Should also die if we just add a shard
name|Exception
name|e2
init|=
name|expectThrows
argument_list|(
name|Exception
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|CollectionAdminRequest
operator|.
name|createShard
argument_list|(
name|collectionName
argument_list|,
literal|"shard1"
argument_list|)
operator|.
name|setNodeSet
argument_list|(
name|deadNode
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Should have gotten a message about shard not "
argument_list|,
name|e2
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"At least one of the node(s) specified are not currently active, no action taken."
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|startJettySolrRunner
argument_list|(
name|jetty
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getAllNodeNames
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getAllNodeNames
parameter_list|(
name|String
name|collectionName
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|DocCollection
name|state
init|=
name|getCollectionState
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
return|return
name|state
operator|.
name|getReplicas
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|Replica
operator|::
name|getNodeName
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

