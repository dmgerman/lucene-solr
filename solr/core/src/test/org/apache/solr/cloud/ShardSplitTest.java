begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|Slow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|embedded
operator|.
name|JettySolrRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|CloudSolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|HttpSolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|CollectionAdminRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|CoreAdminRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|QueryRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|CollectionAdminResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|CoreAdminResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|QueryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|RequestStatusState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|CollectionStateWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|CompositeIdRouter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocRouter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|HashBasedRouter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkCoreNodeProps
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CollectionParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|TestInjection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|OverseerCollectionMessageHandler
operator|.
name|NUM_SLICES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
operator|.
name|BASE_URL_PROP
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
operator|.
name|MAX_SHARDS_PER_NODE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
operator|.
name|REPLICATION_FACTOR
import|;
end_import

begin_class
annotation|@
name|Slow
DECL|class|ShardSplitTest
specifier|public
class|class
name|ShardSplitTest
extends|extends
name|BasicDistributedZkTest
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|SHARD1_0
specifier|public
specifier|static
specifier|final
name|String
name|SHARD1_0
init|=
name|SHARD1
operator|+
literal|"_0"
decl_stmt|;
DECL|field|SHARD1_1
specifier|public
specifier|static
specifier|final
name|String
name|SHARD1_1
init|=
name|SHARD1
operator|+
literal|"_1"
decl_stmt|;
DECL|method|ShardSplitTest
specifier|public
name|ShardSplitTest
parameter_list|()
block|{
name|schemaString
operator|=
literal|"schema15.xml"
expr_stmt|;
comment|// we need a string id
block|}
annotation|@
name|Override
DECL|method|distribSetUp
specifier|public
name|void
name|distribSetUp
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|distribSetUp
argument_list|()
expr_stmt|;
name|useFactory
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|test
specifier|public
name|void
name|test
parameter_list|()
throws|throws
name|Exception
block|{
name|waitForThingsToLevelOut
argument_list|(
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|usually
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Using legacyCloud=false for cluster"
argument_list|)
expr_stmt|;
name|CollectionAdminRequest
operator|.
name|setClusterProperty
argument_list|(
name|ZkStateReader
operator|.
name|LEGACY_CLOUD
argument_list|,
literal|"false"
argument_list|)
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
block|}
name|incompleteOrOverlappingCustomRangeTest
argument_list|()
expr_stmt|;
name|splitByUniqueKeyTest
argument_list|()
expr_stmt|;
name|splitByRouteFieldTest
argument_list|()
expr_stmt|;
name|splitByRouteKeyTest
argument_list|()
expr_stmt|;
comment|// todo can't call waitForThingsToLevelOut because it looks for jettys of all shards
comment|// and the new sub-shards don't have any.
name|waitForRecoveriesToFinish
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//waitForThingsToLevelOut(15);
block|}
comment|/*   Creates a collection with replicationFactor=1, splits a shard. Restarts the sub-shard leader node.   Add a replica. Ensure count matches in leader and replica.    */
DECL|method|testSplitStaticIndexReplication
specifier|public
name|void
name|testSplitStaticIndexReplication
parameter_list|()
throws|throws
name|Exception
block|{
name|waitForThingsToLevelOut
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|DocCollection
name|defCol
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
operator|.
name|getCollection
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
decl_stmt|;
name|Replica
name|replica
init|=
name|defCol
operator|.
name|getReplicas
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|nodeName
init|=
name|replica
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
name|String
name|collectionName
init|=
literal|"testSplitStaticIndexReplication"
decl_stmt|;
name|CollectionAdminRequest
operator|.
name|Create
name|create
init|=
name|CollectionAdminRequest
operator|.
name|createCollection
argument_list|(
name|collectionName
argument_list|,
literal|"conf1"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|create
operator|.
name|setMaxShardsPerNode
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|// some high number so we can create replicas without hindrance
name|create
operator|.
name|setCreateNodeSet
argument_list|(
name|nodeName
argument_list|)
expr_stmt|;
comment|// we want to create the leader on a fixed node so that we know which one to restart later
name|create
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
try|try
init|(
name|CloudSolrClient
name|client
init|=
name|getCloudSolrClient
argument_list|(
name|zkServer
operator|.
name|getZkAddress
argument_list|()
argument_list|,
literal|true
argument_list|,
name|cloudClient
operator|.
name|getLbClient
argument_list|()
operator|.
name|getHttpClient
argument_list|()
argument_list|)
init|)
block|{
name|client
operator|.
name|setDefaultCollection
argument_list|(
name|collectionName
argument_list|)
expr_stmt|;
name|StoppableIndexingThread
name|thread
init|=
operator|new
name|StoppableIndexingThread
argument_list|(
name|controlClient
argument_list|,
name|client
argument_list|,
literal|"i1"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
try|try
block|{
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|// give the indexer sometime to do its work
name|thread
operator|.
name|safeStop
argument_list|()
expr_stmt|;
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
name|client
operator|.
name|commit
argument_list|()
expr_stmt|;
name|controlClient
operator|.
name|commit
argument_list|()
expr_stmt|;
name|CollectionAdminRequest
operator|.
name|SplitShard
name|splitShard
init|=
name|CollectionAdminRequest
operator|.
name|splitShard
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
name|splitShard
operator|.
name|setShardName
argument_list|(
name|SHARD1
argument_list|)
expr_stmt|;
name|String
name|asyncId
init|=
name|splitShard
operator|.
name|processAsync
argument_list|(
name|client
argument_list|)
decl_stmt|;
name|RequestStatusState
name|state
init|=
name|CollectionAdminRequest
operator|.
name|requestStatus
argument_list|(
name|asyncId
argument_list|)
operator|.
name|waitFor
argument_list|(
name|client
argument_list|,
literal|120
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|RequestStatusState
operator|.
name|COMPLETED
condition|)
block|{
name|waitForRecoveriesToFinish
argument_list|(
name|collectionName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// let's wait to see parent shard become inactive
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|client
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|registerCollectionStateWatcher
argument_list|(
name|collectionName
argument_list|,
operator|new
name|CollectionStateWatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|onStateChanged
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
parameter_list|,
name|DocCollection
name|collectionState
parameter_list|)
block|{
name|Slice
name|parent
init|=
name|collectionState
operator|.
name|getSlice
argument_list|(
name|SHARD1
argument_list|)
decl_stmt|;
name|Slice
name|slice10
init|=
name|collectionState
operator|.
name|getSlice
argument_list|(
name|SHARD1_0
argument_list|)
decl_stmt|;
name|Slice
name|slice11
init|=
name|collectionState
operator|.
name|getSlice
argument_list|(
name|SHARD1_1
argument_list|)
decl_stmt|;
if|if
condition|(
name|slice10
operator|!=
literal|null
operator|&&
name|slice11
operator|!=
literal|null
operator|&&
name|parent
operator|.
name|getState
argument_list|()
operator|==
name|Slice
operator|.
name|State
operator|.
name|INACTIVE
operator|&&
name|slice10
operator|.
name|getState
argument_list|()
operator|==
name|Slice
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
name|slice11
operator|.
name|getState
argument_list|()
operator|==
name|Slice
operator|.
name|State
operator|.
name|ACTIVE
condition|)
block|{
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
comment|// removes the watch
block|}
return|return
literal|false
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|latch
operator|.
name|getCount
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// sanity check
name|fail
argument_list|(
literal|"Sub-shards did not become active even after waiting for 1 minute"
argument_list|)
expr_stmt|;
block|}
name|int
name|liveNodeCount
init|=
name|client
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
operator|.
name|getLiveNodes
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// restart the sub-shard leader node
name|boolean
name|restarted
init|=
literal|false
decl_stmt|;
for|for
control|(
name|JettySolrRunner
name|jetty
range|:
name|jettys
control|)
block|{
name|int
name|port
init|=
name|jetty
operator|.
name|getBaseUrl
argument_list|()
operator|.
name|getPort
argument_list|()
decl_stmt|;
if|if
condition|(
name|replica
operator|.
name|getStr
argument_list|(
name|BASE_URL_PROP
argument_list|)
operator|.
name|contains
argument_list|(
literal|":"
operator|+
name|port
argument_list|)
condition|)
block|{
name|ChaosMonkey
operator|.
name|kill
argument_list|(
name|jetty
argument_list|)
expr_stmt|;
name|ChaosMonkey
operator|.
name|start
argument_list|(
name|jetty
argument_list|)
expr_stmt|;
name|restarted
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|restarted
condition|)
block|{
comment|// sanity check
name|fail
argument_list|(
literal|"We could not find a jetty to kill for replica: "
operator|+
name|replica
operator|.
name|getCoreUrl
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// add a new replica for the sub-shard
name|CollectionAdminRequest
operator|.
name|AddReplica
name|addReplica
init|=
name|CollectionAdminRequest
operator|.
name|addReplicaToShard
argument_list|(
name|collectionName
argument_list|,
name|SHARD1_0
argument_list|)
decl_stmt|;
comment|// use control client because less chances of it being the node being restarted
comment|// this is to avoid flakiness of test because of NoHttpResponseExceptions
name|String
name|control_collection
init|=
name|client
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
operator|.
name|getCollection
argument_list|(
literal|"control_collection"
argument_list|)
operator|.
name|getReplicas
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getStr
argument_list|(
name|BASE_URL_PROP
argument_list|)
decl_stmt|;
try|try
init|(
name|HttpSolrClient
name|control
init|=
operator|new
name|HttpSolrClient
operator|.
name|Builder
argument_list|(
name|control_collection
argument_list|)
operator|.
name|withHttpClient
argument_list|(
name|client
operator|.
name|getLbClient
argument_list|()
operator|.
name|getHttpClient
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
init|)
block|{
name|state
operator|=
name|addReplica
operator|.
name|processAndWait
argument_list|(
name|control
argument_list|,
literal|30
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|RequestStatusState
operator|.
name|COMPLETED
condition|)
block|{
name|CountDownLatch
name|newReplicaLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|client
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|registerCollectionStateWatcher
argument_list|(
name|collectionName
argument_list|,
operator|new
name|CollectionStateWatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|onStateChanged
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
parameter_list|,
name|DocCollection
name|collectionState
parameter_list|)
block|{
if|if
condition|(
name|liveNodes
operator|.
name|size
argument_list|()
operator|!=
name|liveNodeCount
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Slice
name|slice
init|=
name|collectionState
operator|.
name|getSlice
argument_list|(
name|SHARD1_0
argument_list|)
decl_stmt|;
if|if
condition|(
name|slice
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|slice
operator|.
name|getReplicas
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|r
lambda|->
name|r
operator|.
name|getState
argument_list|()
operator|==
name|Replica
operator|.
name|State
operator|.
name|RECOVERING
argument_list|)
argument_list|)
block|{
comment|// we see replicas and none of them are recovering
name|newReplicaLatch
operator|.
name|countDown
argument_list|()
block|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
block|)
function|;
name|newReplicaLatch
operator|.
name|await
argument_list|(
literal|30
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
comment|// check consistency of sub-shard replica explicitly because checkShardConsistency methods doesn't
comment|// handle new shards/replica so well.
name|ClusterState
name|clusterState
init|=
name|client
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|DocCollection
name|collection
init|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
name|int
name|numReplicasChecked
init|=
name|assertConsistentReplicas
argument_list|(
name|collection
operator|.
name|getSlice
argument_list|(
name|SHARD1_0
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"We should have checked consistency for exactly 2 replicas of shard1_0"
argument_list|,
literal|2
argument_list|,
name|numReplicasChecked
argument_list|)
expr_stmt|;
block|}
end_class

begin_else
else|else
block|{
name|fail
argument_list|(
literal|"Adding a replica to sub-shard did not complete even after waiting for 30 seconds!. Saw state = "
operator|+
name|state
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_else

begin_block
unit|} else
block|{
name|fail
argument_list|(
literal|"We expected shard split to succeed on a static index but it didn't. Found state = "
operator|+
name|state
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_block
unit|} finally
block|{
name|thread
operator|.
name|safeStop
argument_list|()
expr_stmt|;
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
unit|}   }
DECL|method|assertConsistentReplicas
specifier|private
name|int
name|assertConsistentReplicas
parameter_list|(
name|Slice
name|shard
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|long
name|numFound
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Replica
name|replica
range|:
name|shard
operator|.
name|getReplicas
argument_list|()
control|)
block|{
name|HttpSolrClient
name|client
init|=
operator|new
name|HttpSolrClient
operator|.
name|Builder
argument_list|(
name|replica
operator|.
name|getCoreUrl
argument_list|()
argument_list|)
operator|.
name|withHttpClient
argument_list|(
name|cloudClient
operator|.
name|getLbClient
argument_list|()
operator|.
name|getHttpClient
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|QueryResponse
name|response
init|=
name|client
operator|.
name|query
argument_list|(
operator|new
name|SolrQuery
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"distrib"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Found numFound={} on replica: {}"
argument_list|,
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|,
name|replica
operator|.
name|getCoreUrl
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|numFound
operator|==
name|Long
operator|.
name|MIN_VALUE
condition|)
block|{
name|numFound
operator|=
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
literal|"Shard "
operator|+
name|shard
operator|.
name|getName
argument_list|()
operator|+
literal|" replicas do not have same number of documents"
argument_list|,
name|numFound
argument_list|,
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/**    * Used to test that we can split a shard when a previous split event    * left sub-shards in construction or recovery state.    *    * See SOLR-9439    */
end_comment

begin_function
annotation|@
name|Test
DECL|method|testSplitAfterFailedSplit
specifier|public
name|void
name|testSplitAfterFailedSplit
parameter_list|()
throws|throws
name|Exception
block|{
name|waitForThingsToLevelOut
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|TestInjection
operator|.
name|splitFailureBeforeReplicaCreation
operator|=
literal|"true:100"
expr_stmt|;
comment|// we definitely want split to fail
try|try
block|{
try|try
block|{
name|CollectionAdminRequest
operator|.
name|SplitShard
name|splitShard
init|=
name|CollectionAdminRequest
operator|.
name|splitShard
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
decl_stmt|;
name|splitShard
operator|.
name|setShardName
argument_list|(
name|SHARD1
argument_list|)
expr_stmt|;
name|splitShard
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Shard split was not supposed to succeed after failure injection!"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// expected
block|}
comment|// assert that sub-shards cores exist and sub-shard is in construction state
name|ZkStateReader
name|zkStateReader
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
decl_stmt|;
name|zkStateReader
operator|.
name|forceUpdateCollection
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
expr_stmt|;
name|ClusterState
name|state
init|=
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|DocCollection
name|collection
init|=
name|state
operator|.
name|getCollection
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
decl_stmt|;
name|Slice
name|shard10
init|=
name|collection
operator|.
name|getSlice
argument_list|(
name|SHARD1_0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Slice
operator|.
name|State
operator|.
name|CONSTRUCTION
argument_list|,
name|shard10
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|shard10
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Slice
name|shard11
init|=
name|collection
operator|.
name|getSlice
argument_list|(
name|SHARD1_1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Slice
operator|.
name|State
operator|.
name|CONSTRUCTION
argument_list|,
name|shard11
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|shard11
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// lets retry the split
name|TestInjection
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// let the split succeed
try|try
block|{
name|CollectionAdminRequest
operator|.
name|SplitShard
name|splitShard
init|=
name|CollectionAdminRequest
operator|.
name|splitShard
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
decl_stmt|;
name|splitShard
operator|.
name|setShardName
argument_list|(
name|SHARD1
argument_list|)
expr_stmt|;
name|splitShard
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
comment|// Yay!
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Shard split failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|TestInjection
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Test
DECL|method|testSplitWithChaosMonkey
specifier|public
name|void
name|testSplitWithChaosMonkey
parameter_list|()
throws|throws
name|Exception
block|{
name|waitForThingsToLevelOut
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|StoppableIndexingThread
argument_list|>
name|indexers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|StoppableIndexingThread
name|thread
init|=
operator|new
name|StoppableIndexingThread
argument_list|(
name|controlClient
argument_list|,
name|cloudClient
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|indexers
operator|.
name|add
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|// give the indexers some time to do their work
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error in test"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
for|for
control|(
name|StoppableIndexingThread
name|indexer
range|:
name|indexers
control|)
block|{
name|indexer
operator|.
name|safeStop
argument_list|()
expr_stmt|;
name|indexer
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
name|cloudClient
operator|.
name|commit
argument_list|()
expr_stmt|;
name|controlClient
operator|.
name|commit
argument_list|()
expr_stmt|;
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|AtomicBoolean
name|killed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|Runnable
name|monkey
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|ZkStateReader
name|zkStateReader
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
decl_stmt|;
name|zkStateReader
operator|.
name|registerCollectionStateWatcher
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
operator|new
name|CollectionStateWatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|onStateChanged
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
parameter_list|,
name|DocCollection
name|collectionState
parameter_list|)
block|{
if|if
condition|(
name|stop
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
comment|// abort and remove the watch
block|}
name|Slice
name|slice
init|=
name|collectionState
operator|.
name|getSlice
argument_list|(
name|SHARD1_0
argument_list|)
decl_stmt|;
if|if
condition|(
name|slice
operator|!=
literal|null
operator|&&
name|slice
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// ensure that only one watcher invocation thread can kill!
if|if
condition|(
name|killed
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Monkey thread found 2 replicas for {} {}"
argument_list|,
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|CloudJettyRunner
name|cjetty
init|=
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
decl_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|500
argument_list|)
argument_list|)
expr_stmt|;
name|ChaosMonkey
operator|.
name|kill
argument_list|(
name|cjetty
argument_list|)
expr_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Monkey unable to kill jetty at port "
operator|+
name|cjetty
operator|.
name|jetty
operator|.
name|getLocalPort
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Monkey thread found only one replica for {} {}"
argument_list|,
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|Thread
name|monkeyThread
init|=
literal|null
decl_stmt|;
comment|/*      somehow the cluster state object inside this zk state reader has static copy of the collection which is never updated      so any call to waitForRecoveriesToFinish just keeps looping until timeout.      We workaround by explicitly registering the collection as an interesting one so that it is watched by ZkStateReader      see SOLR-9440. Todo remove this hack after SOLR-9440 is fixed.     */
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|registerCore
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
expr_stmt|;
name|monkeyThread
operator|=
operator|new
name|Thread
argument_list|(
name|monkey
argument_list|)
expr_stmt|;
name|monkeyThread
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
name|CollectionAdminRequest
operator|.
name|SplitShard
name|splitShard
init|=
name|CollectionAdminRequest
operator|.
name|splitShard
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
decl_stmt|;
name|splitShard
operator|.
name|setShardName
argument_list|(
name|SHARD1
argument_list|)
expr_stmt|;
name|String
name|asyncId
init|=
name|splitShard
operator|.
name|processAsync
argument_list|(
name|cloudClient
argument_list|)
decl_stmt|;
name|RequestStatusState
name|splitStatus
init|=
literal|null
decl_stmt|;
try|try
block|{
name|splitStatus
operator|=
name|CollectionAdminRequest
operator|.
name|requestStatus
argument_list|(
name|asyncId
argument_list|)
operator|.
name|waitFor
argument_list|(
name|cloudClient
argument_list|,
literal|120
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to get request status, maybe because the overseer node was shutdown by monkey"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// we don't care if the split failed because we are injecting faults and it is likely
comment|// that the split has failed but in any case we want to assert that all docs that got
comment|// indexed are available in SolrCloud and if the split succeeded then all replicas of the sub-shard
comment|// must be consistent (i.e. have same numdocs)
name|log
operator|.
name|info
argument_list|(
literal|"Shard split request state is COMPLETED"
argument_list|)
expr_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|monkeyThread
operator|.
name|join
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|addFails
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|deleteFails
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|StoppableIndexingThread
name|indexer
range|:
name|indexers
control|)
block|{
name|addFails
operator|.
name|addAll
argument_list|(
name|indexer
operator|.
name|getAddFails
argument_list|()
argument_list|)
expr_stmt|;
name|deleteFails
operator|.
name|addAll
argument_list|(
name|indexer
operator|.
name|getDeleteFails
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|CloudJettyRunner
name|cjetty
init|=
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Starting shard1 leader jetty at port {}"
argument_list|,
name|cjetty
operator|.
name|jetty
operator|.
name|getLocalPort
argument_list|()
argument_list|)
expr_stmt|;
name|ChaosMonkey
operator|.
name|start
argument_list|(
name|cjetty
operator|.
name|jetty
argument_list|)
expr_stmt|;
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|forceUpdateCollection
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Current collection state: {}"
argument_list|,
name|printClusterStateInfo
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|replicaCreationsFailed
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|splitStatus
operator|==
name|RequestStatusState
operator|.
name|FAILED
condition|)
block|{
comment|// either one or more replica creation failed (because it may have been created on the same parent shard leader node)
comment|// or the split may have failed while trying to soft-commit *after* all replicas have been created
comment|// the latter counts as a successful switch even if the API doesn't say so
comment|// so we must find a way to distinguish between the two
comment|// an easy way to do that is to look at the sub-shard replicas and check if the replica core actually exists
comment|// instead of existing solely inside the cluster state
name|DocCollection
name|collectionState
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
operator|.
name|getCollection
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
decl_stmt|;
name|Slice
name|slice10
init|=
name|collectionState
operator|.
name|getSlice
argument_list|(
name|SHARD1_0
argument_list|)
decl_stmt|;
name|Slice
name|slice11
init|=
name|collectionState
operator|.
name|getSlice
argument_list|(
name|SHARD1_1
argument_list|)
decl_stmt|;
if|if
condition|(
name|slice10
operator|!=
literal|null
operator|&&
name|slice11
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Replica
name|replica
range|:
name|slice10
control|)
block|{
if|if
condition|(
operator|!
name|doesReplicaCoreExist
argument_list|(
name|replica
argument_list|)
condition|)
block|{
name|replicaCreationsFailed
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|Replica
name|replica
range|:
name|slice11
control|)
block|{
if|if
condition|(
operator|!
name|doesReplicaCoreExist
argument_list|(
name|replica
argument_list|)
condition|)
block|{
name|replicaCreationsFailed
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|// true if sub-shard states switch to 'active' eventually
name|AtomicBoolean
name|areSubShardsActive
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|replicaCreationsFailed
condition|)
block|{
comment|// all sub-shard replicas were created successfully so all cores must recover eventually
name|waitForRecoveriesToFinish
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// let's wait for the overseer to switch shard states
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|registerCollectionStateWatcher
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
operator|new
name|CollectionStateWatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|onStateChanged
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
parameter_list|,
name|DocCollection
name|collectionState
parameter_list|)
block|{
name|Slice
name|parent
init|=
name|collectionState
operator|.
name|getSlice
argument_list|(
name|SHARD1
argument_list|)
decl_stmt|;
name|Slice
name|slice10
init|=
name|collectionState
operator|.
name|getSlice
argument_list|(
name|SHARD1_0
argument_list|)
decl_stmt|;
name|Slice
name|slice11
init|=
name|collectionState
operator|.
name|getSlice
argument_list|(
name|SHARD1_1
argument_list|)
decl_stmt|;
if|if
condition|(
name|slice10
operator|!=
literal|null
operator|&&
name|slice11
operator|!=
literal|null
operator|&&
name|parent
operator|.
name|getState
argument_list|()
operator|==
name|Slice
operator|.
name|State
operator|.
name|INACTIVE
operator|&&
name|slice10
operator|.
name|getState
argument_list|()
operator|==
name|Slice
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
name|slice11
operator|.
name|getState
argument_list|()
operator|==
name|Slice
operator|.
name|State
operator|.
name|ACTIVE
condition|)
block|{
name|areSubShardsActive
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
comment|// removes the watch
block|}
elseif|else
if|if
condition|(
name|slice10
operator|!=
literal|null
operator|&&
name|slice11
operator|!=
literal|null
operator|&&
name|parent
operator|.
name|getState
argument_list|()
operator|==
name|Slice
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
name|slice10
operator|.
name|getState
argument_list|()
operator|==
name|Slice
operator|.
name|State
operator|.
name|RECOVERY_FAILED
operator|&&
name|slice11
operator|.
name|getState
argument_list|()
operator|==
name|Slice
operator|.
name|State
operator|.
name|RECOVERY_FAILED
condition|)
block|{
name|areSubShardsActive
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|(
literal|2
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|latch
operator|.
name|getCount
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// sanity check
name|fail
argument_list|(
literal|"We think that split was successful but sub-shard states were not updated even after 2 minutes."
argument_list|)
expr_stmt|;
block|}
block|}
name|cloudClient
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|// for visibility of results on sub-shards
name|checkShardConsistency
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
name|addFails
argument_list|,
name|deleteFails
argument_list|)
expr_stmt|;
name|long
name|ctrlDocs
init|=
name|controlClient
operator|.
name|query
argument_list|(
operator|new
name|SolrQuery
argument_list|(
literal|"*:*"
argument_list|)
argument_list|)
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
decl_stmt|;
comment|// ensure we have added more than 0 docs
name|long
name|cloudClientDocs
init|=
name|cloudClient
operator|.
name|query
argument_list|(
operator|new
name|SolrQuery
argument_list|(
literal|"*:*"
argument_list|)
argument_list|)
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Found "
operator|+
name|ctrlDocs
operator|+
literal|" control docs"
argument_list|,
name|cloudClientDocs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Found "
operator|+
name|ctrlDocs
operator|+
literal|" control docs and "
operator|+
name|cloudClientDocs
operator|+
literal|" cloud docs"
argument_list|,
name|ctrlDocs
argument_list|,
name|cloudClientDocs
argument_list|)
expr_stmt|;
comment|// check consistency of sub-shard replica explicitly because checkShardConsistency methods doesn't
comment|// handle new shards/replica so well.
if|if
condition|(
name|areSubShardsActive
operator|.
name|get
argument_list|()
condition|)
block|{
name|ClusterState
name|clusterState
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|DocCollection
name|collection
init|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
decl_stmt|;
name|int
name|numReplicasChecked
init|=
name|assertConsistentReplicas
argument_list|(
name|collection
operator|.
name|getSlice
argument_list|(
name|SHARD1_0
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"We should have checked consistency for exactly 2 replicas of shard1_0"
argument_list|,
literal|2
argument_list|,
name|numReplicasChecked
argument_list|)
expr_stmt|;
name|numReplicasChecked
operator|=
name|assertConsistentReplicas
argument_list|(
name|collection
operator|.
name|getSlice
argument_list|(
name|SHARD1_1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"We should have checked consistency for exactly 2 replicas of shard1_1"
argument_list|,
literal|2
argument_list|,
name|numReplicasChecked
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|monkeyThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|doesReplicaCoreExist
specifier|private
name|boolean
name|doesReplicaCoreExist
parameter_list|(
name|Replica
name|replica
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|HttpSolrClient
name|client
init|=
operator|new
name|HttpSolrClient
operator|.
name|Builder
argument_list|(
name|replica
operator|.
name|getStr
argument_list|(
name|BASE_URL_PROP
argument_list|)
argument_list|)
operator|.
name|withHttpClient
argument_list|(
name|cloudClient
operator|.
name|getLbClient
argument_list|()
operator|.
name|getHttpClient
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
init|)
block|{
name|String
name|coreName
init|=
name|replica
operator|.
name|getCoreName
argument_list|()
decl_stmt|;
try|try
block|{
name|CoreAdminResponse
name|status
init|=
name|CoreAdminRequest
operator|.
name|getStatus
argument_list|(
name|coreName
argument_list|,
name|client
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|getCoreStatus
argument_list|(
name|coreName
argument_list|)
operator|==
literal|null
operator|||
name|status
operator|.
name|getCoreStatus
argument_list|(
name|coreName
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Error gettting core status of replica "
operator|+
name|replica
operator|+
literal|". Perhaps it does not exist!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function

begin_function
annotation|@
name|Test
DECL|method|testSplitShardWithRule
specifier|public
name|void
name|testSplitShardWithRule
parameter_list|()
throws|throws
name|Exception
block|{
name|waitForThingsToLevelOut
argument_list|(
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|usually
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Using legacyCloud=false for cluster"
argument_list|)
expr_stmt|;
name|CollectionAdminRequest
operator|.
name|setClusterProperty
argument_list|(
name|ZkStateReader
operator|.
name|LEGACY_CLOUD
argument_list|,
literal|"false"
argument_list|)
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Starting testSplitShardWithRule"
argument_list|)
expr_stmt|;
name|String
name|collectionName
init|=
literal|"shardSplitWithRule"
decl_stmt|;
name|CollectionAdminRequest
operator|.
name|Create
name|createRequest
init|=
operator|new
name|CollectionAdminRequest
operator|.
name|Create
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setNumShards
argument_list|(
literal|1
argument_list|)
operator|.
name|setReplicationFactor
argument_list|(
literal|2
argument_list|)
operator|.
name|setRule
argument_list|(
literal|"shard:*,replica:<2,node:*"
argument_list|)
decl_stmt|;
name|CollectionAdminResponse
name|response
init|=
name|createRequest
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|response
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|CollectionAdminRequest
operator|.
name|SplitShard
name|splitShardRequest
init|=
operator|new
name|CollectionAdminRequest
operator|.
name|SplitShard
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setShardName
argument_list|(
literal|"shard1"
argument_list|)
decl_stmt|;
name|response
operator|=
name|splitShardRequest
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|response
operator|.
name|getErrorMessages
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
name|response
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|incompleteOrOverlappingCustomRangeTest
specifier|private
name|void
name|incompleteOrOverlappingCustomRangeTest
parameter_list|()
throws|throws
name|Exception
block|{
name|ClusterState
name|clusterState
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
specifier|final
name|DocRouter
name|router
init|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
operator|.
name|getRouter
argument_list|()
decl_stmt|;
name|Slice
name|shard1
init|=
name|clusterState
operator|.
name|getSlice
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
decl_stmt|;
name|DocRouter
operator|.
name|Range
name|shard1Range
init|=
name|shard1
operator|.
name|getRange
argument_list|()
operator|!=
literal|null
condition|?
name|shard1
operator|.
name|getRange
argument_list|()
else|:
name|router
operator|.
name|fullRange
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DocRouter
operator|.
name|Range
argument_list|>
name|subRanges
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DocRouter
operator|.
name|Range
argument_list|>
name|ranges
init|=
name|router
operator|.
name|partitionRange
argument_list|(
literal|4
argument_list|,
name|shard1Range
argument_list|)
decl_stmt|;
comment|// test with only one range
name|subRanges
operator|.
name|add
argument_list|(
name|ranges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|splitShard
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
name|SHARD1
argument_list|,
name|subRanges
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Shard splitting with just one custom hash range should not succeed"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HttpSolrClient
operator|.
name|RemoteSolrException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Expected exception:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|subRanges
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// test with ranges with a hole in between them
name|subRanges
operator|.
name|add
argument_list|(
name|ranges
operator|.
name|get
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|// order shouldn't matter
name|subRanges
operator|.
name|add
argument_list|(
name|ranges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|splitShard
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
name|SHARD1
argument_list|,
name|subRanges
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Shard splitting with missing hashes in between given ranges should not succeed"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HttpSolrClient
operator|.
name|RemoteSolrException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Expected exception:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|subRanges
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// test with overlapping ranges
name|subRanges
operator|.
name|add
argument_list|(
name|ranges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|subRanges
operator|.
name|add
argument_list|(
name|ranges
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|subRanges
operator|.
name|add
argument_list|(
name|ranges
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|subRanges
operator|.
name|add
argument_list|(
operator|new
name|DocRouter
operator|.
name|Range
argument_list|(
name|ranges
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|min
operator|-
literal|15
argument_list|,
name|ranges
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|max
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|splitShard
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
name|SHARD1
argument_list|,
name|subRanges
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Shard splitting with overlapping ranges should not succeed"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HttpSolrClient
operator|.
name|RemoteSolrException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Expected exception:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|subRanges
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
DECL|method|splitByUniqueKeyTest
specifier|private
name|void
name|splitByUniqueKeyTest
parameter_list|()
throws|throws
name|Exception
block|{
name|ClusterState
name|clusterState
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
specifier|final
name|DocRouter
name|router
init|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|)
operator|.
name|getRouter
argument_list|()
decl_stmt|;
name|Slice
name|shard1
init|=
name|clusterState
operator|.
name|getSlice
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
decl_stmt|;
name|DocRouter
operator|.
name|Range
name|shard1Range
init|=
name|shard1
operator|.
name|getRange
argument_list|()
operator|!=
literal|null
condition|?
name|shard1
operator|.
name|getRange
argument_list|()
else|:
name|router
operator|.
name|fullRange
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DocRouter
operator|.
name|Range
argument_list|>
name|subRanges
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|usually
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|DocRouter
operator|.
name|Range
argument_list|>
name|ranges
init|=
name|router
operator|.
name|partitionRange
argument_list|(
literal|4
argument_list|,
name|shard1Range
argument_list|)
decl_stmt|;
comment|// 75% of range goes to shard1_0 and the rest to shard1_1
name|subRanges
operator|.
name|add
argument_list|(
operator|new
name|DocRouter
operator|.
name|Range
argument_list|(
name|ranges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|min
argument_list|,
name|ranges
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|max
argument_list|)
argument_list|)
expr_stmt|;
name|subRanges
operator|.
name|add
argument_list|(
name|ranges
operator|.
name|get
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subRanges
operator|=
name|router
operator|.
name|partitionRange
argument_list|(
literal|2
argument_list|,
name|shard1Range
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|DocRouter
operator|.
name|Range
argument_list|>
name|ranges
init|=
name|subRanges
decl_stmt|;
specifier|final
name|int
index|[]
name|docCounts
init|=
operator|new
name|int
index|[
name|ranges
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|numReplicas
init|=
name|shard1
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|del
argument_list|(
literal|"*:*"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|id
init|=
literal|0
init|;
name|id
operator|<=
literal|100
condition|;
name|id
operator|++
control|)
block|{
name|String
name|shardKey
init|=
literal|""
operator|+
call|(
name|char
call|)
argument_list|(
literal|'a'
operator|+
operator|(
name|id
operator|%
literal|26
operator|)
argument_list|)
decl_stmt|;
comment|// See comment in ShardRoutingTest for hash distribution
name|indexAndUpdateCount
argument_list|(
name|router
argument_list|,
name|ranges
argument_list|,
name|docCounts
argument_list|,
name|shardKey
operator|+
literal|"!"
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|id
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|commit
argument_list|()
expr_stmt|;
name|Thread
name|indexThread
init|=
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
name|int
name|max
init|=
name|atLeast
argument_list|(
name|random
argument_list|,
literal|401
argument_list|)
decl_stmt|;
name|int
name|sleep
init|=
name|atLeast
argument_list|(
name|random
argument_list|,
literal|25
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"SHARDSPLITTEST: Going to add "
operator|+
name|max
operator|+
literal|" number of docs at 1 doc per "
operator|+
name|sleep
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|deleted
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|id
init|=
literal|101
init|;
name|id
operator|<
name|max
condition|;
name|id
operator|++
control|)
block|{
try|try
block|{
name|indexAndUpdateCount
argument_list|(
name|router
argument_list|,
name|ranges
argument_list|,
name|docCounts
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|id
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
if|if
condition|(
name|usually
argument_list|(
name|random
argument_list|)
condition|)
block|{
name|String
name|delId
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|id
operator|-
literal|101
operator|+
literal|1
argument_list|)
operator|+
literal|101
argument_list|)
decl_stmt|;
if|if
condition|(
name|deleted
operator|.
name|contains
argument_list|(
name|delId
argument_list|)
condition|)
continue|continue;
try|try
block|{
name|deleteAndUpdateCount
argument_list|(
name|router
argument_list|,
name|ranges
argument_list|,
name|docCounts
argument_list|,
name|delId
argument_list|)
expr_stmt|;
name|deleted
operator|.
name|add
argument_list|(
name|delId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception while deleting docs"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception while adding doc id = "
operator|+
name|id
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// do not select this id for deletion ever
name|deleted
operator|.
name|add
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
decl_stmt|;
name|indexThread
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|splitShard
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
name|SHARD1
argument_list|,
name|subRanges
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Layout after split: \n"
argument_list|)
expr_stmt|;
name|printLayout
argument_list|()
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|HttpSolrClient
operator|.
name|RemoteSolrException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|!=
literal|500
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|log
operator|.
name|error
argument_list|(
literal|"SPLITSHARD failed. "
operator|+
operator|(
name|i
operator|<
literal|2
condition|?
literal|" Retring split"
else|:
literal|""
operator|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|fail
argument_list|(
literal|"SPLITSHARD was not successful even after three tries"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
try|try
block|{
name|indexThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Indexing thread interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|waitForRecoveriesToFinish
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|checkDocCountsAndShardStates
argument_list|(
name|docCounts
argument_list|,
name|numReplicas
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|splitByRouteFieldTest
specifier|public
name|void
name|splitByRouteFieldTest
parameter_list|()
throws|throws
name|Exception
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Starting testSplitWithRouteField"
argument_list|)
expr_stmt|;
name|String
name|collectionName
init|=
literal|"routeFieldColl"
decl_stmt|;
name|int
name|numShards
init|=
literal|4
decl_stmt|;
name|int
name|replicationFactor
init|=
literal|2
decl_stmt|;
name|int
name|maxShardsPerNode
init|=
operator|(
operator|(
operator|(
name|numShards
operator|*
name|replicationFactor
operator|)
operator|/
name|getCommonCloudSolrClient
argument_list|()
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
operator|.
name|getLiveNodes
argument_list|()
operator|.
name|size
argument_list|()
operator|)
operator|)
operator|+
literal|1
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|collectionInfos
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|shard_fld
init|=
literal|"shard_s"
decl_stmt|;
try|try
init|(
name|CloudSolrClient
name|client
init|=
name|createCloudClient
argument_list|(
literal|null
argument_list|)
init|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|props
init|=
name|Utils
operator|.
name|makeMap
argument_list|(
name|REPLICATION_FACTOR
argument_list|,
name|replicationFactor
argument_list|,
name|MAX_SHARDS_PER_NODE
argument_list|,
name|maxShardsPerNode
argument_list|,
name|NUM_SLICES
argument_list|,
name|numShards
argument_list|,
literal|"router.field"
argument_list|,
name|shard_fld
argument_list|)
decl_stmt|;
name|createCollection
argument_list|(
name|collectionInfos
argument_list|,
name|collectionName
argument_list|,
name|props
argument_list|,
name|client
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|collectionInfos
operator|.
name|get
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
name|checkForCollection
argument_list|(
name|collectionName
argument_list|,
name|list
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|waitForRecoveriesToFinish
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|String
name|url
init|=
name|getUrlFromZk
argument_list|(
name|getCommonCloudSolrClient
argument_list|()
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
argument_list|,
name|collectionName
argument_list|)
decl_stmt|;
try|try
init|(
name|HttpSolrClient
name|collectionClient
init|=
name|getHttpSolrClient
argument_list|(
name|url
argument_list|)
init|)
block|{
name|ClusterState
name|clusterState
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
specifier|final
name|DocRouter
name|router
init|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|collectionName
argument_list|)
operator|.
name|getRouter
argument_list|()
decl_stmt|;
name|Slice
name|shard1
init|=
name|clusterState
operator|.
name|getSlice
argument_list|(
name|collectionName
argument_list|,
name|SHARD1
argument_list|)
decl_stmt|;
name|DocRouter
operator|.
name|Range
name|shard1Range
init|=
name|shard1
operator|.
name|getRange
argument_list|()
operator|!=
literal|null
condition|?
name|shard1
operator|.
name|getRange
argument_list|()
else|:
name|router
operator|.
name|fullRange
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DocRouter
operator|.
name|Range
argument_list|>
name|ranges
init|=
name|router
operator|.
name|partitionRange
argument_list|(
literal|2
argument_list|,
name|shard1Range
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|docCounts
init|=
operator|new
name|int
index|[
name|ranges
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|100
init|;
name|i
operator|<=
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|String
name|shardKey
init|=
literal|""
operator|+
call|(
name|char
call|)
argument_list|(
literal|'a'
operator|+
operator|(
name|i
operator|%
literal|26
operator|)
argument_list|)
decl_stmt|;
comment|// See comment in ShardRoutingTest for hash distribution
name|collectionClient
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|i
argument_list|,
literal|"n_ti"
argument_list|,
name|i
argument_list|,
name|shard_fld
argument_list|,
name|shardKey
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|idx
init|=
name|getHashRangeIdx
argument_list|(
name|router
argument_list|,
name|ranges
argument_list|,
name|shardKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|docCounts
index|[
name|idx
index|]
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docCounts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|docCount
init|=
name|docCounts
index|[
name|i
index|]
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Shard {} docCount = {}"
argument_list|,
literal|"shard1_"
operator|+
name|i
argument_list|,
name|docCount
argument_list|)
expr_stmt|;
block|}
name|collectionClient
operator|.
name|commit
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|splitShard
argument_list|(
name|collectionName
argument_list|,
name|SHARD1
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|HttpSolrClient
operator|.
name|RemoteSolrException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|!=
literal|500
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|log
operator|.
name|error
argument_list|(
literal|"SPLITSHARD failed. "
operator|+
operator|(
name|i
operator|<
literal|2
condition|?
literal|" Retring split"
else|:
literal|""
operator|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|fail
argument_list|(
literal|"SPLITSHARD was not successful even after three tries"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|waitForRecoveriesToFinish
argument_list|(
name|collectionName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|docCounts
index|[
literal|0
index|]
argument_list|,
name|collectionClient
operator|.
name|query
argument_list|(
operator|new
name|SolrQuery
argument_list|(
literal|"*:*"
argument_list|)
operator|.
name|setParam
argument_list|(
literal|"shards"
argument_list|,
literal|"shard1_0"
argument_list|)
argument_list|)
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|docCounts
index|[
literal|1
index|]
argument_list|,
name|collectionClient
operator|.
name|query
argument_list|(
operator|new
name|SolrQuery
argument_list|(
literal|"*:*"
argument_list|)
operator|.
name|setParam
argument_list|(
literal|"shards"
argument_list|,
literal|"shard1_1"
argument_list|)
argument_list|)
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|splitByRouteKeyTest
specifier|private
name|void
name|splitByRouteKeyTest
parameter_list|()
throws|throws
name|Exception
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Starting splitByRouteKeyTest"
argument_list|)
expr_stmt|;
name|String
name|collectionName
init|=
literal|"splitByRouteKeyTest"
decl_stmt|;
name|int
name|numShards
init|=
literal|4
decl_stmt|;
name|int
name|replicationFactor
init|=
literal|2
decl_stmt|;
name|int
name|maxShardsPerNode
init|=
operator|(
operator|(
operator|(
name|numShards
operator|*
name|replicationFactor
operator|)
operator|/
name|getCommonCloudSolrClient
argument_list|()
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
operator|.
name|getLiveNodes
argument_list|()
operator|.
name|size
argument_list|()
operator|)
operator|)
operator|+
literal|1
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|collectionInfos
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|CloudSolrClient
name|client
init|=
name|createCloudClient
argument_list|(
literal|null
argument_list|)
init|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|props
init|=
name|Utils
operator|.
name|makeMap
argument_list|(
name|REPLICATION_FACTOR
argument_list|,
name|replicationFactor
argument_list|,
name|MAX_SHARDS_PER_NODE
argument_list|,
name|maxShardsPerNode
argument_list|,
name|NUM_SLICES
argument_list|,
name|numShards
argument_list|)
decl_stmt|;
name|createCollection
argument_list|(
name|collectionInfos
argument_list|,
name|collectionName
argument_list|,
name|props
argument_list|,
name|client
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|collectionInfos
operator|.
name|get
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
name|checkForCollection
argument_list|(
name|collectionName
argument_list|,
name|list
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|waitForRecoveriesToFinish
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|String
name|url
init|=
name|getUrlFromZk
argument_list|(
name|getCommonCloudSolrClient
argument_list|()
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
argument_list|,
name|collectionName
argument_list|)
decl_stmt|;
try|try
init|(
name|HttpSolrClient
name|collectionClient
init|=
name|getHttpSolrClient
argument_list|(
name|url
argument_list|)
init|)
block|{
name|String
name|splitKey
init|=
literal|"b!"
decl_stmt|;
name|ClusterState
name|clusterState
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
specifier|final
name|DocRouter
name|router
init|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|collectionName
argument_list|)
operator|.
name|getRouter
argument_list|()
decl_stmt|;
name|Slice
name|shard1
init|=
name|clusterState
operator|.
name|getSlice
argument_list|(
name|collectionName
argument_list|,
name|SHARD1
argument_list|)
decl_stmt|;
name|DocRouter
operator|.
name|Range
name|shard1Range
init|=
name|shard1
operator|.
name|getRange
argument_list|()
operator|!=
literal|null
condition|?
name|shard1
operator|.
name|getRange
argument_list|()
else|:
name|router
operator|.
name|fullRange
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DocRouter
operator|.
name|Range
argument_list|>
name|ranges
init|=
operator|(
operator|(
name|CompositeIdRouter
operator|)
name|router
operator|)
operator|.
name|partitionRangeByKey
argument_list|(
name|splitKey
argument_list|,
name|shard1Range
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|docCounts
init|=
operator|new
name|int
index|[
name|ranges
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|uniqIdentifier
init|=
operator|(
literal|1
operator|<<
literal|12
operator|)
decl_stmt|;
name|int
name|splitKeyDocCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|100
init|;
name|i
operator|<=
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|String
name|shardKey
init|=
literal|""
operator|+
call|(
name|char
call|)
argument_list|(
literal|'a'
operator|+
operator|(
name|i
operator|%
literal|26
operator|)
argument_list|)
decl_stmt|;
comment|// See comment in ShardRoutingTest for hash distribution
name|String
name|idStr
init|=
name|shardKey
operator|+
literal|"!"
operator|+
name|i
decl_stmt|;
name|collectionClient
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|idStr
argument_list|,
literal|"n_ti"
argument_list|,
operator|(
name|shardKey
operator|+
literal|"!"
operator|)
operator|.
name|equals
argument_list|(
name|splitKey
argument_list|)
condition|?
name|uniqIdentifier
else|:
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|idx
init|=
name|getHashRangeIdx
argument_list|(
name|router
argument_list|,
name|ranges
argument_list|,
name|idStr
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|docCounts
index|[
name|idx
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|splitKey
operator|.
name|equals
argument_list|(
name|shardKey
operator|+
literal|"!"
argument_list|)
condition|)
name|splitKeyDocCount
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docCounts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|docCount
init|=
name|docCounts
index|[
name|i
index|]
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Shard {} docCount = {}"
argument_list|,
literal|"shard1_"
operator|+
name|i
argument_list|,
name|docCount
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Route key doc count = {}"
argument_list|,
name|splitKeyDocCount
argument_list|)
expr_stmt|;
name|collectionClient
operator|.
name|commit
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|splitShard
argument_list|(
name|collectionName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|splitKey
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|HttpSolrClient
operator|.
name|RemoteSolrException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|!=
literal|500
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|log
operator|.
name|error
argument_list|(
literal|"SPLITSHARD failed. "
operator|+
operator|(
name|i
operator|<
literal|2
condition|?
literal|" Retring split"
else|:
literal|""
operator|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|fail
argument_list|(
literal|"SPLITSHARD was not successful even after three tries"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|waitForRecoveriesToFinish
argument_list|(
name|collectionName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|(
literal|"*:*"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"DocCount on shard1_0 does not match"
argument_list|,
name|docCounts
index|[
literal|0
index|]
argument_list|,
name|collectionClient
operator|.
name|query
argument_list|(
name|solrQuery
operator|.
name|setParam
argument_list|(
literal|"shards"
argument_list|,
literal|"shard1_0"
argument_list|)
argument_list|)
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"DocCount on shard1_1 does not match"
argument_list|,
name|docCounts
index|[
literal|1
index|]
argument_list|,
name|collectionClient
operator|.
name|query
argument_list|(
name|solrQuery
operator|.
name|setParam
argument_list|(
literal|"shards"
argument_list|,
literal|"shard1_1"
argument_list|)
argument_list|)
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"DocCount on shard1_2 does not match"
argument_list|,
name|docCounts
index|[
literal|2
index|]
argument_list|,
name|collectionClient
operator|.
name|query
argument_list|(
name|solrQuery
operator|.
name|setParam
argument_list|(
literal|"shards"
argument_list|,
literal|"shard1_2"
argument_list|)
argument_list|)
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
name|solrQuery
operator|=
operator|new
name|SolrQuery
argument_list|(
literal|"n_ti:"
operator|+
name|uniqIdentifier
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"shard1_0 must have 0 docs for route key: "
operator|+
name|splitKey
argument_list|,
literal|0
argument_list|,
name|collectionClient
operator|.
name|query
argument_list|(
name|solrQuery
operator|.
name|setParam
argument_list|(
literal|"shards"
argument_list|,
literal|"shard1_0"
argument_list|)
argument_list|)
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong number of docs on shard1_1 for route key: "
operator|+
name|splitKey
argument_list|,
name|splitKeyDocCount
argument_list|,
name|collectionClient
operator|.
name|query
argument_list|(
name|solrQuery
operator|.
name|setParam
argument_list|(
literal|"shards"
argument_list|,
literal|"shard1_1"
argument_list|)
argument_list|)
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"shard1_2 must have 0 docs for route key: "
operator|+
name|splitKey
argument_list|,
literal|0
argument_list|,
name|collectionClient
operator|.
name|query
argument_list|(
name|solrQuery
operator|.
name|setParam
argument_list|(
literal|"shards"
argument_list|,
literal|"shard1_2"
argument_list|)
argument_list|)
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|checkDocCountsAndShardStates
specifier|protected
name|void
name|checkDocCountsAndShardStates
parameter_list|(
name|int
index|[]
name|docCounts
parameter_list|,
name|int
name|numReplicas
parameter_list|)
throws|throws
name|Exception
block|{
name|ClusterState
name|clusterState
init|=
literal|null
decl_stmt|;
name|Slice
name|slice1_0
init|=
literal|null
decl_stmt|,
name|slice1_1
init|=
literal|null
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|ZkStateReader
name|zkStateReader
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
decl_stmt|;
name|clusterState
operator|=
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
expr_stmt|;
name|slice1_0
operator|=
name|clusterState
operator|.
name|getSlice
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
literal|"shard1_0"
argument_list|)
expr_stmt|;
name|slice1_1
operator|=
name|clusterState
operator|.
name|getSlice
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
literal|"shard1_1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|slice1_0
operator|.
name|getState
argument_list|()
operator|==
name|Slice
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
name|slice1_1
operator|.
name|getState
argument_list|()
operator|==
name|Slice
operator|.
name|State
operator|.
name|ACTIVE
condition|)
block|{
break|break;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"ShardSplitTest waited for {} ms for shard state to be set to active"
argument_list|,
name|i
operator|*
literal|500
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"Cluster state does not contain shard1_0"
argument_list|,
name|slice1_0
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"Cluster state does not contain shard1_0"
argument_list|,
name|slice1_1
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
literal|"shard1_0 is not active"
argument_list|,
name|Slice
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|slice1_0
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
literal|"shard1_1 is not active"
argument_list|,
name|Slice
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|slice1_1
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong number of replicas created for shard1_0"
argument_list|,
name|numReplicas
argument_list|,
name|slice1_0
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong number of replicas created for shard1_1"
argument_list|,
name|numReplicas
argument_list|,
name|slice1_1
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
comment|// can't use checkShardConsistency because it insists on jettys and clients for each shard
name|checkSubShardConsistency
argument_list|(
name|SHARD1_0
argument_list|)
expr_stmt|;
name|checkSubShardConsistency
argument_list|(
name|SHARD1_1
argument_list|)
expr_stmt|;
name|SolrQuery
name|query
init|=
operator|new
name|SolrQuery
argument_list|(
literal|"*:*"
argument_list|)
operator|.
name|setRows
argument_list|(
literal|1000
argument_list|)
operator|.
name|setFields
argument_list|(
literal|"id"
argument_list|,
literal|"_version_"
argument_list|)
decl_stmt|;
name|query
operator|.
name|set
argument_list|(
literal|"distrib"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|ZkCoreNodeProps
name|shard1_0
init|=
name|getLeaderUrlFromZk
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
name|SHARD1_0
argument_list|)
decl_stmt|;
name|QueryResponse
name|response
decl_stmt|;
try|try
init|(
name|HttpSolrClient
name|shard1_0Client
init|=
name|getHttpSolrClient
argument_list|(
name|shard1_0
operator|.
name|getCoreUrl
argument_list|()
argument_list|)
init|)
block|{
name|response
operator|=
name|shard1_0Client
operator|.
name|query
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
name|long
name|shard10Count
init|=
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
decl_stmt|;
name|ZkCoreNodeProps
name|shard1_1
init|=
name|getLeaderUrlFromZk
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
name|SHARD1_1
argument_list|)
decl_stmt|;
name|QueryResponse
name|response2
decl_stmt|;
try|try
init|(
name|HttpSolrClient
name|shard1_1Client
init|=
name|getHttpSolrClient
argument_list|(
name|shard1_1
operator|.
name|getCoreUrl
argument_list|()
argument_list|)
init|)
block|{
name|response2
operator|=
name|shard1_1Client
operator|.
name|query
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
name|long
name|shard11Count
init|=
name|response2
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
decl_stmt|;
name|logDebugHelp
argument_list|(
name|docCounts
argument_list|,
name|response
argument_list|,
name|shard10Count
argument_list|,
name|response2
argument_list|,
name|shard11Count
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong doc count on shard1_0. See SOLR-5309"
argument_list|,
name|docCounts
index|[
literal|0
index|]
argument_list|,
name|shard10Count
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong doc count on shard1_1. See SOLR-5309"
argument_list|,
name|docCounts
index|[
literal|1
index|]
argument_list|,
name|shard11Count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|checkSubShardConsistency
specifier|protected
name|void
name|checkSubShardConsistency
parameter_list|(
name|String
name|shard
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|SolrQuery
name|query
init|=
operator|new
name|SolrQuery
argument_list|(
literal|"*:*"
argument_list|)
operator|.
name|setRows
argument_list|(
literal|1000
argument_list|)
operator|.
name|setFields
argument_list|(
literal|"id"
argument_list|,
literal|"_version_"
argument_list|)
decl_stmt|;
name|query
operator|.
name|set
argument_list|(
literal|"distrib"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|ClusterState
name|clusterState
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|Slice
name|slice
init|=
name|clusterState
operator|.
name|getSlice
argument_list|(
name|AbstractDistribZkTestBase
operator|.
name|DEFAULT_COLLECTION
argument_list|,
name|shard
argument_list|)
decl_stmt|;
name|long
index|[]
name|numFound
init|=
operator|new
name|long
index|[
name|slice
operator|.
name|getReplicasMap
argument_list|()
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Replica
name|replica
range|:
name|slice
operator|.
name|getReplicas
argument_list|()
control|)
block|{
name|String
name|coreUrl
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|replica
argument_list|)
operator|.
name|getCoreUrl
argument_list|()
decl_stmt|;
name|QueryResponse
name|response
decl_stmt|;
try|try
init|(
name|HttpSolrClient
name|client
init|=
name|getHttpSolrClient
argument_list|(
name|coreUrl
argument_list|)
init|)
block|{
name|response
operator|=
name|client
operator|.
name|query
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
name|numFound
index|[
name|c
operator|++
index|]
operator|=
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Shard: "
operator|+
name|shard
operator|+
literal|" Replica: {} has {} docs"
argument_list|,
name|coreUrl
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Shard: "
operator|+
name|shard
operator|+
literal|" Replica: "
operator|+
name|coreUrl
operator|+
literal|" has 0 docs"
argument_list|,
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|slice
operator|.
name|getReplicasMap
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|shard
operator|+
literal|" is not consistent"
argument_list|,
name|numFound
index|[
literal|0
index|]
argument_list|,
name|numFound
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|splitShard
specifier|protected
name|void
name|splitShard
parameter_list|(
name|String
name|collection
parameter_list|,
name|String
name|shardId
parameter_list|,
name|List
argument_list|<
name|DocRouter
operator|.
name|Range
argument_list|>
name|subRanges
parameter_list|,
name|String
name|splitKey
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|()
decl_stmt|;
name|params
operator|.
name|set
argument_list|(
literal|"action"
argument_list|,
name|CollectionParams
operator|.
name|CollectionAction
operator|.
name|SPLITSHARD
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
literal|"collection"
argument_list|,
name|collection
argument_list|)
expr_stmt|;
if|if
condition|(
name|shardId
operator|!=
literal|null
condition|)
block|{
name|params
operator|.
name|set
argument_list|(
literal|"shard"
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subRanges
operator|!=
literal|null
condition|)
block|{
name|StringBuilder
name|ranges
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subRanges
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|DocRouter
operator|.
name|Range
name|subRange
init|=
name|subRanges
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ranges
operator|.
name|append
argument_list|(
name|subRange
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|subRanges
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|ranges
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|params
operator|.
name|set
argument_list|(
literal|"ranges"
argument_list|,
name|ranges
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|splitKey
operator|!=
literal|null
condition|)
block|{
name|params
operator|.
name|set
argument_list|(
literal|"split.key"
argument_list|,
name|splitKey
argument_list|)
expr_stmt|;
block|}
name|SolrRequest
name|request
init|=
operator|new
name|QueryRequest
argument_list|(
name|params
argument_list|)
decl_stmt|;
name|request
operator|.
name|setPath
argument_list|(
literal|"/admin/collections"
argument_list|)
expr_stmt|;
name|String
name|baseUrl
init|=
operator|(
operator|(
name|HttpSolrClient
operator|)
name|shardToJetty
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|client
operator|.
name|solrClient
operator|)
operator|.
name|getBaseURL
argument_list|()
decl_stmt|;
name|baseUrl
operator|=
name|baseUrl
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|baseUrl
operator|.
name|length
argument_list|()
operator|-
literal|"collection1"
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
try|try
init|(
name|HttpSolrClient
name|baseServer
init|=
name|getHttpSolrClient
argument_list|(
name|baseUrl
argument_list|)
init|)
block|{
name|baseServer
operator|.
name|setConnectionTimeout
argument_list|(
literal|30000
argument_list|)
expr_stmt|;
name|baseServer
operator|.
name|setSoTimeout
argument_list|(
literal|60000
operator|*
literal|5
argument_list|)
expr_stmt|;
name|baseServer
operator|.
name|request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|indexAndUpdateCount
specifier|protected
name|void
name|indexAndUpdateCount
parameter_list|(
name|DocRouter
name|router
parameter_list|,
name|List
argument_list|<
name|DocRouter
operator|.
name|Range
argument_list|>
name|ranges
parameter_list|,
name|int
index|[]
name|docCounts
parameter_list|,
name|String
name|id
parameter_list|,
name|int
name|n
parameter_list|)
throws|throws
name|Exception
block|{
name|index
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
literal|"n_ti"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|int
name|idx
init|=
name|getHashRangeIdx
argument_list|(
name|router
argument_list|,
name|ranges
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|docCounts
index|[
name|idx
index|]
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|deleteAndUpdateCount
specifier|protected
name|void
name|deleteAndUpdateCount
parameter_list|(
name|DocRouter
name|router
parameter_list|,
name|List
argument_list|<
name|DocRouter
operator|.
name|Range
argument_list|>
name|ranges
parameter_list|,
name|int
index|[]
name|docCounts
parameter_list|,
name|String
name|id
parameter_list|)
throws|throws
name|Exception
block|{
name|controlClient
operator|.
name|deleteById
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|cloudClient
operator|.
name|deleteById
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|int
name|idx
init|=
name|getHashRangeIdx
argument_list|(
name|router
argument_list|,
name|ranges
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|docCounts
index|[
name|idx
index|]
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|getHashRangeIdx
specifier|public
specifier|static
name|int
name|getHashRangeIdx
parameter_list|(
name|DocRouter
name|router
parameter_list|,
name|List
argument_list|<
name|DocRouter
operator|.
name|Range
argument_list|>
name|ranges
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|int
name|hash
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|router
operator|instanceof
name|HashBasedRouter
condition|)
block|{
name|HashBasedRouter
name|hashBasedRouter
init|=
operator|(
name|HashBasedRouter
operator|)
name|router
decl_stmt|;
name|hash
operator|=
name|hashBasedRouter
operator|.
name|sliceHash
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ranges
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|DocRouter
operator|.
name|Range
name|range
init|=
name|ranges
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|includes
argument_list|(
name|hash
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
DECL|method|logDebugHelp
specifier|protected
name|void
name|logDebugHelp
parameter_list|(
name|int
index|[]
name|docCounts
parameter_list|,
name|QueryResponse
name|response
parameter_list|,
name|long
name|shard10Count
parameter_list|,
name|QueryResponse
name|response2
parameter_list|,
name|long
name|shard11Count
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docCounts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|docCount
init|=
name|docCounts
index|[
name|i
index|]
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Expected docCount for shard1_{} = {}"
argument_list|,
name|i
argument_list|,
name|docCount
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Actual docCount for shard1_0 = {}"
argument_list|,
name|shard10Count
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Actual docCount for shard1_1 = {}"
argument_list|,
name|shard11Count
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|idVsVersion
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|SolrDocument
argument_list|>
name|shard10Docs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|SolrDocument
argument_list|>
name|shard11Docs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SolrDocument
name|document
init|=
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|idVsVersion
operator|.
name|put
argument_list|(
name|document
operator|.
name|getFieldValue
argument_list|(
literal|"id"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|document
operator|.
name|getFieldValue
argument_list|(
literal|"_version_"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|SolrDocument
name|old
init|=
name|shard10Docs
operator|.
name|put
argument_list|(
name|document
operator|.
name|getFieldValue
argument_list|(
literal|"id"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|document
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"EXTRA: ID: "
operator|+
name|document
operator|.
name|getFieldValue
argument_list|(
literal|"id"
argument_list|)
operator|+
literal|" on shard1_0. Old version: "
operator|+
name|old
operator|.
name|getFieldValue
argument_list|(
literal|"_version_"
argument_list|)
operator|+
literal|" new version: "
operator|+
name|document
operator|.
name|getFieldValue
argument_list|(
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|response2
operator|.
name|getResults
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SolrDocument
name|document
init|=
name|response2
operator|.
name|getResults
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|document
operator|.
name|getFieldValue
argument_list|(
literal|"id"
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|version
init|=
name|idVsVersion
operator|.
name|get
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|version
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"DUPLICATE: ID: "
operator|+
name|value
operator|+
literal|" , shard1_0Version: "
operator|+
name|version
operator|+
literal|" shard1_1Version:"
operator|+
name|document
operator|.
name|getFieldValue
argument_list|(
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SolrDocument
name|old
init|=
name|shard11Docs
operator|.
name|put
argument_list|(
name|document
operator|.
name|getFieldValue
argument_list|(
literal|"id"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|document
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"EXTRA: ID: "
operator|+
name|document
operator|.
name|getFieldValue
argument_list|(
literal|"id"
argument_list|)
operator|+
literal|" on shard1_1. Old version: "
operator|+
name|old
operator|.
name|getFieldValue
argument_list|(
literal|"_version_"
argument_list|)
operator|+
literal|" new version: "
operator|+
name|document
operator|.
name|getFieldValue
argument_list|(
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createNewSolrClient
specifier|protected
name|SolrClient
name|createNewSolrClient
parameter_list|(
name|String
name|collection
parameter_list|,
name|String
name|baseUrl
parameter_list|)
block|{
name|HttpSolrClient
name|client
init|=
operator|(
name|HttpSolrClient
operator|)
name|super
operator|.
name|createNewSolrClient
argument_list|(
name|collection
argument_list|,
name|baseUrl
argument_list|)
decl_stmt|;
name|client
operator|.
name|setSoTimeout
argument_list|(
literal|5
operator|*
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
return|return
name|client
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createNewSolrClient
specifier|protected
name|SolrClient
name|createNewSolrClient
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|HttpSolrClient
name|client
init|=
operator|(
name|HttpSolrClient
operator|)
name|super
operator|.
name|createNewSolrClient
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|client
operator|.
name|setSoTimeout
argument_list|(
literal|5
operator|*
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
return|return
name|client
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createCloudClient
specifier|protected
name|CloudSolrClient
name|createCloudClient
parameter_list|(
name|String
name|defaultCollection
parameter_list|)
block|{
name|CloudSolrClient
name|client
init|=
name|super
operator|.
name|createCloudClient
argument_list|(
name|defaultCollection
argument_list|)
decl_stmt|;
return|return
name|client
return|;
block|}
end_function

unit|}
end_unit

