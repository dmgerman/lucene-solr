begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|embedded
operator|.
name|JettySolrRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|HttpSolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|CloudSolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|QueryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|SolrCloudTestCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocumentList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|transform
operator|.
name|DocTransformer
import|;
end_import

begin_comment
comment|// jdoc
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|transform
operator|.
name|RawValueTransformerFactory
import|;
end_import

begin_comment
comment|// jdoc
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|transform
operator|.
name|TransformerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RandomizeSSL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FilenameUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_comment
comment|/** @see TestCloudPseudoReturnFields */
end_comment

begin_class
annotation|@
name|RandomizeSSL
argument_list|(
name|clientAuth
operator|=
literal|0.0
argument_list|,
name|reason
operator|=
literal|"client auth uses too much RAM"
argument_list|)
DECL|class|TestRandomFlRTGCloud
specifier|public
class|class
name|TestRandomFlRTGCloud
extends|extends
name|SolrCloudTestCase
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|DEBUG_LABEL
specifier|private
specifier|static
specifier|final
name|String
name|DEBUG_LABEL
init|=
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
DECL|field|COLLECTION_NAME
specifier|private
specifier|static
specifier|final
name|String
name|COLLECTION_NAME
init|=
name|DEBUG_LABEL
operator|+
literal|"_collection"
decl_stmt|;
comment|/** A basic client for operations at the cloud level, default collection will be set */
DECL|field|CLOUD_CLIENT
specifier|private
specifier|static
name|CloudSolrClient
name|CLOUD_CLIENT
decl_stmt|;
comment|/** One client per node */
DECL|field|CLIENTS
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|HttpSolrClient
argument_list|>
name|CLIENTS
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|5
argument_list|)
decl_stmt|;
comment|/** Always included in fl so we can vet what doc we're looking at */
DECL|field|ID_VALIDATOR
specifier|private
specifier|static
specifier|final
name|FlValidator
name|ID_VALIDATOR
init|=
operator|new
name|SimpleFieldValueValidator
argument_list|(
literal|"id"
argument_list|)
decl_stmt|;
comment|/**     * Types of things we will randomly ask for in fl param, and validate in response docs.    *    * @see #addRandomFlValidators    */
DECL|field|FL_VALIDATORS
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|FlValidator
argument_list|>
name|FL_VALIDATORS
init|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
expr|<
name|FlValidator
operator|>
name|asList
argument_list|(
operator|new
name|GlobValidator
argument_list|(
literal|"*"
argument_list|)
argument_list|,
operator|new
name|GlobValidator
argument_list|(
literal|"*_i"
argument_list|)
argument_list|,
operator|new
name|GlobValidator
argument_list|(
literal|"*_s"
argument_list|)
argument_list|,
operator|new
name|GlobValidator
argument_list|(
literal|"a*"
argument_list|)
argument_list|,
operator|new
name|DocIdValidator
argument_list|()
argument_list|,
operator|new
name|DocIdValidator
argument_list|(
literal|"my_docid_alias"
argument_list|)
argument_list|,
operator|new
name|ShardValidator
argument_list|()
argument_list|,
operator|new
name|ShardValidator
argument_list|(
literal|"my_shard_alias"
argument_list|)
argument_list|,
operator|new
name|ValueAugmenterValidator
argument_list|(
literal|42
argument_list|)
argument_list|,
operator|new
name|ValueAugmenterValidator
argument_list|(
literal|1976
argument_list|,
literal|"val_alias"
argument_list|)
argument_list|,
comment|//
operator|new
name|RenameFieldValueValidator
argument_list|(
literal|"id"
argument_list|,
literal|"my_id_alias"
argument_list|)
argument_list|,
operator|new
name|SimpleFieldValueValidator
argument_list|(
literal|"aaa_i"
argument_list|)
argument_list|,
operator|new
name|RenameFieldValueValidator
argument_list|(
literal|"bbb_i"
argument_list|,
literal|"my_int_field_alias"
argument_list|)
argument_list|,
operator|new
name|SimpleFieldValueValidator
argument_list|(
literal|"ccc_s"
argument_list|)
argument_list|,
operator|new
name|RenameFieldValueValidator
argument_list|(
literal|"ddd_s"
argument_list|,
literal|"my_str_field_alias"
argument_list|)
argument_list|,
comment|//
comment|// SOLR-9376: RawValueTransformerFactory doesn't work in cloud mode
comment|//
comment|// new RawFieldValueValidator("json", "eee_s", "my_json_field_alias"),
comment|// new RawFieldValueValidator("json", "fff_s"),
comment|// new RawFieldValueValidator("xml", "ggg_s", "my_xml_field_alias"),
comment|// new RawFieldValueValidator("xml", "hhh_s"),
comment|//
operator|new
name|NotIncludedValidator
argument_list|(
literal|"bogus_unused_field_ss"
argument_list|)
argument_list|,
operator|new
name|NotIncludedValidator
argument_list|(
literal|"bogus_alias"
argument_list|,
literal|"bogus_alias:other_bogus_field_i"
argument_list|)
argument_list|,
operator|new
name|NotIncludedValidator
argument_list|(
literal|"bogus_raw_alias"
argument_list|,
literal|"bogus_raw_alias:[xml f=bogus_raw_field_ss]"
argument_list|)
argument_list|,
comment|//
operator|new
name|FunctionValidator
argument_list|(
literal|"aaa_i"
argument_list|)
argument_list|,
comment|// fq field
operator|new
name|FunctionValidator
argument_list|(
literal|"aaa_i"
argument_list|,
literal|"func_aaa_alias"
argument_list|)
argument_list|,
operator|new
name|GeoTransformerValidator
argument_list|(
literal|"geo_1_srpt"
argument_list|)
argument_list|,
operator|new
name|GeoTransformerValidator
argument_list|(
literal|"geo_2_srpt"
argument_list|,
literal|"my_geo_alias"
argument_list|)
argument_list|,
operator|new
name|ExplainValidator
argument_list|()
argument_list|,
operator|new
name|ExplainValidator
argument_list|(
literal|"explain_alias"
argument_list|)
argument_list|,
comment|//
comment|// SOLR-9377: SubQueryValidator fails on uncommited docs because not using RT seacher for sub query
comment|//
comment|// new SubQueryValidator(),
comment|//
operator|new
name|NotIncludedValidator
argument_list|(
literal|"score"
argument_list|)
argument_list|,
operator|new
name|NotIncludedValidator
argument_list|(
literal|"score"
argument_list|,
literal|"score_alias:score"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|createMiniSolrCloudCluster
specifier|private
specifier|static
name|void
name|createMiniSolrCloudCluster
parameter_list|()
throws|throws
name|Exception
block|{
comment|// 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node
comment|// 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud
specifier|final
name|boolean
name|singleCoreMode
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
comment|// (asuming multi core multi replicas shouldn't matter (assuming multi node) ...
specifier|final
name|int
name|repFactor
init|=
name|singleCoreMode
condition|?
literal|1
else|:
operator|(
name|usually
argument_list|()
condition|?
literal|1
else|:
literal|2
operator|)
decl_stmt|;
comment|// ... but we definitely want to ensure forwarded requests to other shards work ...
specifier|final
name|int
name|numShards
init|=
name|singleCoreMode
condition|?
literal|1
else|:
literal|2
decl_stmt|;
comment|// ... including some forwarded requests from nodes not hosting a shard
specifier|final
name|int
name|numNodes
init|=
literal|1
operator|+
operator|(
name|singleCoreMode
condition|?
literal|0
else|:
operator|(
name|numShards
operator|*
name|repFactor
operator|)
operator|)
decl_stmt|;
specifier|final
name|String
name|configName
init|=
name|DEBUG_LABEL
operator|+
literal|"_config-set"
decl_stmt|;
specifier|final
name|Path
name|configDir
init|=
name|Paths
operator|.
name|get
argument_list|(
name|TEST_HOME
argument_list|()
argument_list|,
literal|"collection1"
argument_list|,
literal|"conf"
argument_list|)
decl_stmt|;
name|configureCluster
argument_list|(
name|numNodes
argument_list|)
operator|.
name|addConfig
argument_list|(
name|configName
argument_list|,
name|configDir
argument_list|)
operator|.
name|configure
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|collectionProperties
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|collectionProperties
operator|.
name|put
argument_list|(
literal|"config"
argument_list|,
literal|"solrconfig-tlog.xml"
argument_list|)
expr_stmt|;
name|collectionProperties
operator|.
name|put
argument_list|(
literal|"schema"
argument_list|,
literal|"schema-psuedo-fields.xml"
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|cluster
operator|.
name|createCollection
argument_list|(
name|COLLECTION_NAME
argument_list|,
name|numShards
argument_list|,
name|repFactor
argument_list|,
name|configName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|collectionProperties
argument_list|)
argument_list|)
expr_stmt|;
name|CLOUD_CLIENT
operator|=
name|cluster
operator|.
name|getSolrClient
argument_list|()
expr_stmt|;
name|CLOUD_CLIENT
operator|.
name|setDefaultCollection
argument_list|(
name|COLLECTION_NAME
argument_list|)
expr_stmt|;
name|waitForRecoveriesToFinish
argument_list|(
name|CLOUD_CLIENT
argument_list|)
expr_stmt|;
for|for
control|(
name|JettySolrRunner
name|jetty
range|:
name|cluster
operator|.
name|getJettySolrRunners
argument_list|()
control|)
block|{
name|CLIENTS
operator|.
name|add
argument_list|(
name|getHttpSolrClient
argument_list|(
name|jetty
operator|.
name|getBaseUrl
argument_list|()
operator|+
literal|"/"
operator|+
name|COLLECTION_NAME
operator|+
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|AfterClass
DECL|method|afterClass
specifier|private
specifier|static
name|void
name|afterClass
parameter_list|()
throws|throws
name|Exception
block|{
name|CLOUD_CLIENT
operator|.
name|close
argument_list|()
expr_stmt|;
name|CLOUD_CLIENT
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|HttpSolrClient
name|client
range|:
name|CLIENTS
control|)
block|{
name|client
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|CLIENTS
operator|=
literal|null
expr_stmt|;
block|}
comment|/**     * Tests thta all TransformerFactories that are implicitly provided by Solr are tested in this class    *    * @see FlValidator#getDefaultTransformerFactoryName    * @see #FL_VALIDATORS    * @see TransformerFactory#defaultFactories    */
DECL|method|testCoverage
specifier|public
name|void
name|testCoverage
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|implicit
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|t
range|:
name|TransformerFactory
operator|.
name|defaultFactories
operator|.
name|keySet
argument_list|()
control|)
block|{
name|implicit
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|covered
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FlValidator
name|v
range|:
name|FL_VALIDATORS
control|)
block|{
name|String
name|t
init|=
name|v
operator|.
name|getDefaultTransformerFactoryName
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|t
condition|)
block|{
name|covered
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|// items should only be added to this list if it's known that they do not work with RTG
comment|// and a specific Jira for fixing this is listed as a comment
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|knownBugs
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|SubQueryValidator
operator|.
name|NAME
argument_list|,
comment|// SOLR-9377
literal|"xml"
argument_list|,
literal|"json"
argument_list|,
comment|// SOLR-9376
literal|"child"
comment|// way to complicatd to vet with this test, see SOLR-9379 instead
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|buggy
range|:
name|knownBugs
control|)
block|{
name|assertFalse
argument_list|(
name|buggy
operator|+
literal|" is listed as a being a known bug, "
operator|+
literal|"but it exists in the set of 'covered' TransformerFactories"
argument_list|,
name|covered
operator|.
name|contains
argument_list|(
name|buggy
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|buggy
operator|+
literal|" is listed as a known bug, "
operator|+
literal|"but it does not even exist in the set of 'implicit' TransformerFactories"
argument_list|,
name|implicit
operator|.
name|remove
argument_list|(
name|buggy
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|implicit
operator|.
name|removeAll
argument_list|(
name|covered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Some implicit TransformerFactories are not yet tested by this class: "
operator|+
name|implicit
argument_list|,
literal|0
argument_list|,
name|implicit
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testRandomizedUpdatesAndRTGs
specifier|public
name|void
name|testRandomizedUpdatesAndRTGs
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|maxNumDocs
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numSeedDocs
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|maxNumDocs
operator|/
literal|10
argument_list|)
decl_stmt|;
comment|// at most ~10% of the max possible docs
specifier|final
name|int
name|numIters
init|=
name|atLeast
argument_list|(
name|maxNumDocs
operator|*
literal|10
argument_list|)
decl_stmt|;
specifier|final
name|SolrInputDocument
index|[]
name|knownDocs
init|=
operator|new
name|SolrInputDocument
index|[
name|maxNumDocs
index|]
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Starting {} iters by seeding {} of {} max docs"
argument_list|,
name|numIters
argument_list|,
name|numSeedDocs
argument_list|,
name|maxNumDocs
argument_list|)
expr_stmt|;
name|int
name|itersSinceLastCommit
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIters
condition|;
name|i
operator|++
control|)
block|{
name|itersSinceLastCommit
operator|=
name|maybeCommit
argument_list|(
name|random
argument_list|()
argument_list|,
name|itersSinceLastCommit
argument_list|,
name|numIters
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|numSeedDocs
condition|)
block|{
comment|// first N iters all we worry about is seeding
name|knownDocs
index|[
name|i
index|]
operator|=
name|addRandomDocument
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertOneIter
argument_list|(
name|knownDocs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**     * Randomly chooses to do a commit, where the probability of doing so increases the longer it's been since     * a commit was done.    *    * @returns<code>0</code> if a commit was done, else<code>itersSinceLastCommit + 1</code>    */
DECL|method|maybeCommit
specifier|private
specifier|static
name|int
name|maybeCommit
parameter_list|(
specifier|final
name|Random
name|rand
parameter_list|,
specifier|final
name|int
name|itersSinceLastCommit
parameter_list|,
specifier|final
name|int
name|numIters
parameter_list|)
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
specifier|final
name|float
name|threshold
init|=
name|itersSinceLastCommit
operator|/
name|numIters
decl_stmt|;
if|if
condition|(
name|rand
operator|.
name|nextFloat
argument_list|()
operator|<
name|threshold
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"COMMIT"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|getRandClient
argument_list|(
name|rand
argument_list|)
operator|.
name|commit
argument_list|()
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|itersSinceLastCommit
operator|+
literal|1
return|;
block|}
DECL|method|assertOneIter
specifier|private
name|void
name|assertOneIter
parameter_list|(
specifier|final
name|SolrInputDocument
index|[]
name|knownDocs
parameter_list|)
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
comment|// we want to occasionally test more then one doc per RTG
specifier|final
name|int
name|numDocsThisIter
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
name|atLeast
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|numDocsThisIterThatExist
init|=
literal|0
decl_stmt|;
comment|// pick some random docIds for this iteration and ...
specifier|final
name|int
index|[]
name|docIds
init|=
operator|new
name|int
index|[
name|numDocsThisIter
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDocsThisIter
condition|;
name|i
operator|++
control|)
block|{
name|docIds
index|[
name|i
index|]
operator|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|knownDocs
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|knownDocs
index|[
name|docIds
index|[
name|i
index|]
index|]
condition|)
block|{
comment|// ...check how many already exist
name|numDocsThisIterThatExist
operator|++
expr_stmt|;
block|}
block|}
comment|// we want our RTG requests to occasionally include missing/deleted docs,
comment|// but that's not the primary focus of the test, so weight the odds accordingly
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|numDocsThisIter
operator|+
literal|2
argument_list|)
operator|<=
name|numDocsThisIterThatExist
condition|)
block|{
if|if
condition|(
literal|0
operator|<
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|13
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"RTG: numDocsThisIter={} numDocsThisIterThatExist={}, docIds={}"
argument_list|,
name|numDocsThisIter
argument_list|,
name|numDocsThisIterThatExist
argument_list|,
name|docIds
argument_list|)
expr_stmt|;
name|assertRTG
argument_list|(
name|knownDocs
argument_list|,
name|docIds
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// sporadically delete some docs instead of doing an RTG
name|log
operator|.
name|info
argument_list|(
literal|"DEL: numDocsThisIter={} numDocsThisIterThatExist={}, docIds={}"
argument_list|,
name|numDocsThisIter
argument_list|,
name|numDocsThisIterThatExist
argument_list|,
name|docIds
argument_list|)
expr_stmt|;
name|assertDelete
argument_list|(
name|knownDocs
argument_list|,
name|docIds
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"UPD: numDocsThisIter={} numDocsThisIterThatExist={}, docIds={}"
argument_list|,
name|numDocsThisIter
argument_list|,
name|numDocsThisIterThatExist
argument_list|,
name|docIds
argument_list|)
expr_stmt|;
name|assertUpdate
argument_list|(
name|knownDocs
argument_list|,
name|docIds
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Does some random indexing of the specified docIds and adds them to knownDocs    */
DECL|method|assertUpdate
specifier|private
name|void
name|assertUpdate
parameter_list|(
specifier|final
name|SolrInputDocument
index|[]
name|knownDocs
parameter_list|,
specifier|final
name|int
index|[]
name|docIds
parameter_list|)
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
for|for
control|(
specifier|final
name|int
name|docId
range|:
name|docIds
control|)
block|{
comment|// TODO: this method should also do some atomic update operations (ie: "inc" and "set")
comment|// (but make sure to eval the updates locally as well before modifying knownDocs)
name|knownDocs
index|[
name|docId
index|]
operator|=
name|addRandomDocument
argument_list|(
name|docId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Deletes the docIds specified and asserts the results are valid, updateing knownDocs accordingly    */
DECL|method|assertDelete
specifier|private
name|void
name|assertDelete
parameter_list|(
specifier|final
name|SolrInputDocument
index|[]
name|knownDocs
parameter_list|,
specifier|final
name|int
index|[]
name|docIds
parameter_list|)
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|docIds
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|int
name|docId
range|:
name|docIds
control|)
block|{
name|ids
operator|.
name|add
argument_list|(
literal|""
operator|+
name|docId
argument_list|)
expr_stmt|;
name|knownDocs
index|[
name|docId
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"Failed delete: "
operator|+
name|docIds
argument_list|,
literal|0
argument_list|,
name|getRandClient
argument_list|(
name|random
argument_list|()
argument_list|)
operator|.
name|deleteById
argument_list|(
name|ids
argument_list|)
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds one randomly generated document with the specified docId, asserting success, and returns     * the document added    */
DECL|method|addRandomDocument
specifier|private
name|SolrInputDocument
name|addRandomDocument
parameter_list|(
specifier|final
name|int
name|docId
parameter_list|)
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
specifier|final
name|SolrClient
name|client
init|=
name|getRandClient
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SolrInputDocument
name|doc
init|=
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|docId
argument_list|,
literal|"aaa_i"
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|,
literal|"bbb_i"
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|,
comment|//
literal|"ccc_s"
argument_list|,
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|,
literal|"ddd_s"
argument_list|,
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|,
literal|"eee_s"
argument_list|,
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|,
literal|"fff_s"
argument_list|,
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|,
literal|"ggg_s"
argument_list|,
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|,
literal|"hhh_s"
argument_list|,
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|,
comment|//
literal|"geo_1_srpt"
argument_list|,
name|GeoTransformerValidator
operator|.
name|getValueForIndexing
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|,
literal|"geo_2_srpt"
argument_list|,
name|GeoTransformerValidator
operator|.
name|getValueForIndexing
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|,
comment|// for testing prefix globbing
literal|"axx_i"
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|,
literal|"ayy_i"
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|,
literal|"azz_s"
argument_list|,
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"ADD: {} = {}"
argument_list|,
name|docId
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|client
operator|.
name|add
argument_list|(
name|doc
argument_list|)
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|doc
return|;
block|}
comment|/**    * Does one or more RTG request for the specified docIds with a randomized fl&amp; fq params, asserting    * that the returned document (if any) makes sense given the expected SolrInputDocuments    */
DECL|method|assertRTG
specifier|private
name|void
name|assertRTG
parameter_list|(
specifier|final
name|SolrInputDocument
index|[]
name|knownDocs
parameter_list|,
specifier|final
name|int
index|[]
name|docIds
parameter_list|)
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
specifier|final
name|SolrClient
name|client
init|=
name|getRandClient
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
comment|// NOTE: not using SolrClient.getById or getByIds because we want to force choice of "id" vs "ids" params
specifier|final
name|ModifiableSolrParams
name|params
init|=
name|params
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|)
decl_stmt|;
comment|// random fq -- nothing fancy, secondary concern for our test
specifier|final
name|Integer
name|FQ_MAX
init|=
name|usually
argument_list|()
condition|?
literal|null
else|:
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|FQ_MAX
condition|)
block|{
name|params
operator|.
name|add
argument_list|(
literal|"fq"
argument_list|,
literal|"aaa_i:[* TO "
operator|+
name|FQ_MAX
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Set
argument_list|<
name|FlValidator
argument_list|>
name|validators
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|validators
operator|.
name|add
argument_list|(
name|ID_VALIDATOR
argument_list|)
expr_stmt|;
comment|// always include id so we can be confident which doc we're looking at
name|addRandomFlValidators
argument_list|(
name|random
argument_list|()
argument_list|,
name|validators
argument_list|)
expr_stmt|;
name|FlValidator
operator|.
name|addFlParams
argument_list|(
name|validators
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|// HACK: [subquery] expects this to be top level params
name|params
operator|.
name|add
argument_list|(
name|SubQueryValidator
operator|.
name|SUBQ_KEY
operator|+
literal|".q"
argument_list|,
literal|"{!field f="
operator|+
name|SubQueryValidator
operator|.
name|SUBQ_FIELD
operator|+
literal|" v=$row."
operator|+
name|SubQueryValidator
operator|.
name|SUBQ_FIELD
operator|+
literal|"}"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|idsToRequest
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|docIds
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docsToExpect
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|docIds
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|docId
range|:
name|docIds
control|)
block|{
comment|// every docId will be included in the request
name|idsToRequest
operator|.
name|add
argument_list|(
literal|""
operator|+
name|docId
argument_list|)
expr_stmt|;
comment|// only docs that should actually exist and match our (optional) filter will be expected in response
if|if
condition|(
literal|null
operator|!=
name|knownDocs
index|[
name|docId
index|]
condition|)
block|{
name|Integer
name|filterVal
init|=
operator|(
name|Integer
operator|)
name|knownDocs
index|[
name|docId
index|]
operator|.
name|getFieldValue
argument_list|(
literal|"aaa_i"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|FQ_MAX
operator|||
operator|(
operator|(
literal|null
operator|!=
name|filterVal
operator|)
operator|&&
name|filterVal
operator|.
name|intValue
argument_list|()
operator|<=
name|FQ_MAX
operator|.
name|intValue
argument_list|()
operator|)
condition|)
block|{
name|docsToExpect
operator|.
name|add
argument_list|(
name|knownDocs
index|[
name|docId
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// even w/only 1 docId requested, the response format can vary depending on how we request it
specifier|final
name|boolean
name|askForList
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
operator|||
operator|(
literal|1
operator|!=
name|idsToRequest
operator|.
name|size
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|askForList
condition|)
block|{
if|if
condition|(
literal|1
operator|==
name|idsToRequest
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// have to be careful not to try to use "multi" 'id' params with only 1 docId
comment|// with a single docId, the only way to ask for a list is with the "ids" param
name|params
operator|.
name|add
argument_list|(
literal|"ids"
argument_list|,
name|idsToRequest
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// each id in it's own param
for|for
control|(
name|String
name|id
range|:
name|idsToRequest
control|)
block|{
name|params
operator|.
name|add
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// add one or more comma seperated ids params
name|params
operator|.
name|add
argument_list|(
name|buildCommaSepParams
argument_list|(
name|random
argument_list|()
argument_list|,
literal|"ids"
argument_list|,
name|idsToRequest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
assert|assert
literal|1
operator|==
name|idsToRequest
operator|.
name|size
argument_list|()
assert|;
name|params
operator|.
name|add
argument_list|(
literal|"id"
argument_list|,
name|idsToRequest
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|QueryResponse
name|rsp
init|=
name|client
operator|.
name|query
argument_list|(
name|params
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|params
operator|.
name|toString
argument_list|()
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
specifier|final
name|SolrDocumentList
name|docs
init|=
name|getDocsFromRTGResponse
argument_list|(
name|askForList
argument_list|,
name|rsp
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|params
operator|+
literal|" => "
operator|+
name|rsp
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"num docs mismatch: "
operator|+
name|params
operator|+
literal|" => "
operator|+
name|docsToExpect
operator|+
literal|" vs "
operator|+
name|docs
argument_list|,
name|docsToExpect
operator|.
name|size
argument_list|()
argument_list|,
name|docs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested
for|for
control|(
name|SolrDocument
name|actual
range|:
name|docs
control|)
block|{
try|try
block|{
name|int
name|actualId
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|actual
operator|.
name|getFirstValue
argument_list|(
literal|"id"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SolrInputDocument
name|expected
init|=
name|knownDocs
index|[
name|actualId
index|]
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"expected null doc but RTG returned: "
operator|+
name|actual
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|expectedFieldNames
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FlValidator
name|v
range|:
name|validators
control|)
block|{
name|expectedFieldNames
operator|.
name|addAll
argument_list|(
name|v
operator|.
name|assertRTGResults
argument_list|(
name|validators
argument_list|,
name|expected
argument_list|,
name|actual
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// ensure only expected field names are in the actual document
name|Set
argument_list|<
name|String
argument_list|>
name|actualFieldNames
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|actual
operator|.
name|getFieldNames
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Actual field names returned differs from expected"
argument_list|,
name|expectedFieldNames
argument_list|,
name|actualFieldNames
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|ae
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|params
operator|+
literal|" => "
operator|+
name|actual
operator|+
literal|": "
operator|+
name|ae
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ae
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**     * trivial helper method to deal with diff response structure between using a single 'id' param vs    * 2 or more 'id' params (or 1 or more 'ids' params).    *    * @return List from response, or a synthetic one created from single response doc if     *<code>expectList</code> was false; May be empty; May be null if response included null list.    */
DECL|method|getDocsFromRTGResponse
specifier|private
specifier|static
name|SolrDocumentList
name|getDocsFromRTGResponse
parameter_list|(
specifier|final
name|boolean
name|expectList
parameter_list|,
specifier|final
name|QueryResponse
name|rsp
parameter_list|)
block|{
if|if
condition|(
name|expectList
condition|)
block|{
return|return
name|rsp
operator|.
name|getResults
argument_list|()
return|;
block|}
comment|// else: expect single doc, make our own list...
specifier|final
name|SolrDocumentList
name|result
init|=
operator|new
name|SolrDocumentList
argument_list|()
decl_stmt|;
name|NamedList
argument_list|<
name|Object
argument_list|>
name|raw
init|=
name|rsp
operator|.
name|getResponse
argument_list|()
decl_stmt|;
name|Object
name|doc
init|=
name|raw
operator|.
name|get
argument_list|(
literal|"doc"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|doc
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|(
name|SolrDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
name|result
operator|.
name|setNumFound
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**     * returns a random SolrClient -- either a CloudSolrClient, or an HttpSolrClient pointed     * at a node in our cluster     */
DECL|method|getRandClient
specifier|public
specifier|static
name|SolrClient
name|getRandClient
parameter_list|(
name|Random
name|rand
parameter_list|)
block|{
name|int
name|numClients
init|=
name|CLIENTS
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|0
argument_list|,
name|numClients
argument_list|)
decl_stmt|;
return|return
operator|(
name|idx
operator|==
name|numClients
operator|)
condition|?
name|CLOUD_CLIENT
else|:
name|CLIENTS
operator|.
name|get
argument_list|(
name|idx
argument_list|)
return|;
block|}
DECL|method|waitForRecoveriesToFinish
specifier|public
specifier|static
name|void
name|waitForRecoveriesToFinish
parameter_list|(
name|CloudSolrClient
name|client
parameter_list|)
throws|throws
name|Exception
block|{
assert|assert
literal|null
operator|!=
name|client
operator|.
name|getDefaultCollection
argument_list|()
assert|;
name|AbstractDistribZkTestBase
operator|.
name|waitForRecoveriesToFinish
argument_list|(
name|client
operator|.
name|getDefaultCollection
argument_list|()
argument_list|,
name|client
operator|.
name|getZkStateReader
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|330
argument_list|)
expr_stmt|;
block|}
comment|/**     * Abstraction for diff types of things that can be added to an 'fl' param that can validate    * the results are correct compared to an expected SolrInputDocument    */
DECL|interface|FlValidator
specifier|private
interface|interface
name|FlValidator
block|{
comment|/** Given a list of FlValidators, adds one or more fl params that corrispond to the entire set */
DECL|method|addFlParams
specifier|public
specifier|static
name|void
name|addFlParams
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|FlValidator
argument_list|>
name|validators
parameter_list|,
specifier|final
name|ModifiableSolrParams
name|params
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|validators
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|FlValidator
name|v
range|:
name|validators
control|)
block|{
name|fls
operator|.
name|add
argument_list|(
name|v
operator|.
name|getFlParam
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|params
operator|.
name|add
argument_list|(
name|buildCommaSepParams
argument_list|(
name|random
argument_list|()
argument_list|,
literal|"fl"
argument_list|,
name|fls
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Indicates if this validator is for a transformer that returns true from       * {@link DocTransformer#needsSolrIndexSearcher}.  Other validators for transformers that       * do<em>not</em> require a re-opened searcher (but may have slightly diff behavior depending       * on wether a doc comesfrom the index or from the update log) may use this information to       * decide wether they wish to enforce stricter assertions on the resulting document.      *      * The default implementation always returns<code>false</code>      *      * @see DocIdValidator      */
DECL|method|requiresRealtimeSearcherReOpen
specifier|public
specifier|default
name|boolean
name|requiresRealtimeSearcherReOpen
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**      * the name of a transformer listed in {@link TransformerFactory#defaultFactories} that this validator      * corrisponds to, or null if not applicable.  Used for testing coverage of       * Solr's implicitly supported transformers.      *      * Default behavior is to return null      * @see #testCoverage      */
DECL|method|getDefaultTransformerFactoryName
specifier|public
specifier|default
name|String
name|getDefaultTransformerFactoryName
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**       * Must return a non null String that can be used in an fl param -- either by itself,       * or with other items separated by commas      */
DECL|method|getFlParam
specifier|public
name|String
name|getFlParam
parameter_list|()
function_decl|;
comment|/**       * Given the expected document and the actual document returned from an RTG, this method      * should assert that relative to what {@link #getFlParam} returns, the actual document contained      * what it should relative to the expected document.      *      * @param validators all validators in use for this request, including the current one      * @param expected a document containing the expected fields&amp; values that should be in the index      * @param actual A document that was returned by an RTG request      * @return A set of "field names" in the actual document that this validator expected.      */
DECL|method|assertRTGResults
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|assertRTGResults
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|FlValidator
argument_list|>
name|validators
parameter_list|,
specifier|final
name|SolrInputDocument
name|expected
parameter_list|,
specifier|final
name|SolrDocument
name|actual
parameter_list|)
function_decl|;
block|}
comment|/**     * Some validators behave in a way that "suppresses" real fields even when they would otherwise match a glob    * @see GlobValidator    */
DECL|interface|SuppressRealFields
specifier|private
interface|interface
name|SuppressRealFields
block|{
DECL|method|getSuppressedFields
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getSuppressedFields
parameter_list|()
function_decl|;
block|}
DECL|class|FieldValueValidator
specifier|private
specifier|abstract
specifier|static
class|class
name|FieldValueValidator
implements|implements
name|FlValidator
block|{
DECL|field|expectedFieldName
specifier|protected
specifier|final
name|String
name|expectedFieldName
decl_stmt|;
DECL|field|actualFieldName
specifier|protected
specifier|final
name|String
name|actualFieldName
decl_stmt|;
DECL|method|FieldValueValidator
specifier|public
name|FieldValueValidator
parameter_list|(
specifier|final
name|String
name|expectedFieldName
parameter_list|,
specifier|final
name|String
name|actualFieldName
parameter_list|)
block|{
name|this
operator|.
name|expectedFieldName
operator|=
name|expectedFieldName
expr_stmt|;
name|this
operator|.
name|actualFieldName
operator|=
name|actualFieldName
expr_stmt|;
block|}
DECL|method|getFlParam
specifier|public
specifier|abstract
name|String
name|getFlParam
parameter_list|()
function_decl|;
DECL|method|assertRTGResults
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|assertRTGResults
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|FlValidator
argument_list|>
name|validators
parameter_list|,
specifier|final
name|SolrInputDocument
name|expected
parameter_list|,
specifier|final
name|SolrDocument
name|actual
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|expectedFieldName
operator|+
literal|" vs "
operator|+
name|actualFieldName
argument_list|,
name|expected
operator|.
name|getFieldValue
argument_list|(
name|expectedFieldName
argument_list|)
argument_list|,
name|actual
operator|.
name|getFirstValue
argument_list|(
name|actualFieldName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
expr|<
name|String
operator|>
name|singleton
argument_list|(
name|actualFieldName
argument_list|)
return|;
block|}
block|}
DECL|class|SimpleFieldValueValidator
specifier|private
specifier|static
class|class
name|SimpleFieldValueValidator
extends|extends
name|FieldValueValidator
block|{
DECL|method|SimpleFieldValueValidator
specifier|public
name|SimpleFieldValueValidator
parameter_list|(
specifier|final
name|String
name|fieldName
parameter_list|)
block|{
name|super
argument_list|(
name|fieldName
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
block|}
DECL|method|getFlParam
specifier|public
name|String
name|getFlParam
parameter_list|()
block|{
return|return
name|expectedFieldName
return|;
block|}
block|}
DECL|class|RenameFieldValueValidator
specifier|private
specifier|static
class|class
name|RenameFieldValueValidator
extends|extends
name|FieldValueValidator
implements|implements
name|SuppressRealFields
block|{
DECL|method|RenameFieldValueValidator
specifier|public
name|RenameFieldValueValidator
parameter_list|(
specifier|final
name|String
name|origFieldName
parameter_list|,
specifier|final
name|String
name|alias
parameter_list|)
block|{
name|super
argument_list|(
name|origFieldName
argument_list|,
name|alias
argument_list|)
expr_stmt|;
block|}
DECL|method|getFlParam
specifier|public
name|String
name|getFlParam
parameter_list|()
block|{
return|return
name|actualFieldName
operator|+
literal|":"
operator|+
name|expectedFieldName
return|;
block|}
DECL|method|getSuppressedFields
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getSuppressedFields
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|singleton
argument_list|(
name|expectedFieldName
argument_list|)
return|;
block|}
block|}
comment|/**    * Validator for {@link RawValueTransformerFactory}    *    * This validator is fairly weak, because it doesn't do anything to verify the conditional logic    * in RawValueTransformerFactory realted to the output format -- but that's out of the scope of     * this randomized testing.      *     * What we're primarily concerned with is that the transformer does it's job and puts the string     * in the response, regardless of cloud/RTG/uncommited state of the document.    */
DECL|class|RawFieldValueValidator
specifier|private
specifier|static
class|class
name|RawFieldValueValidator
extends|extends
name|RenameFieldValueValidator
block|{
DECL|field|type
specifier|final
name|String
name|type
decl_stmt|;
DECL|field|alias
specifier|final
name|String
name|alias
decl_stmt|;
DECL|method|RawFieldValueValidator
specifier|public
name|RawFieldValueValidator
parameter_list|(
specifier|final
name|String
name|type
parameter_list|,
specifier|final
name|String
name|fieldName
parameter_list|,
specifier|final
name|String
name|alias
parameter_list|)
block|{
comment|// transformer is weird, default result key doesn't care what params are used...
name|super
argument_list|(
name|fieldName
argument_list|,
literal|null
operator|==
name|alias
condition|?
literal|"["
operator|+
name|type
operator|+
literal|"]"
else|:
name|alias
argument_list|)
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
block|}
DECL|method|RawFieldValueValidator
specifier|public
name|RawFieldValueValidator
parameter_list|(
specifier|final
name|String
name|type
parameter_list|,
specifier|final
name|String
name|fieldName
parameter_list|)
block|{
name|this
argument_list|(
name|type
argument_list|,
name|fieldName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|getFlParam
specifier|public
name|String
name|getFlParam
parameter_list|()
block|{
return|return
operator|(
literal|null
operator|==
name|alias
condition|?
literal|""
else|:
operator|(
name|alias
operator|+
literal|":"
operator|)
operator|)
operator|+
literal|"["
operator|+
name|type
operator|+
literal|" f="
operator|+
name|expectedFieldName
operator|+
literal|"]"
return|;
block|}
DECL|method|getDefaultTransformerFactoryName
specifier|public
name|String
name|getDefaultTransformerFactoryName
parameter_list|()
block|{
return|return
name|type
return|;
block|}
block|}
comment|/**     * enforces that a valid<code>[docid]</code> is present in the response, possibly using a     * resultKey alias.  By default the only validation of docId values is that they are an integer     * greater than or equal to<code>-1</code> -- but if any other validator in use returns true     * from {@link #requiresRealtimeSearcherReOpen} then the constraint is tightened and values must     * be greater than or equal to<code>0</code>     */
DECL|class|DocIdValidator
specifier|private
specifier|static
class|class
name|DocIdValidator
implements|implements
name|FlValidator
block|{
DECL|field|NAME
specifier|private
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"docid"
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"["
operator|+
name|NAME
operator|+
literal|"]"
decl_stmt|;
DECL|field|resultKey
specifier|private
specifier|final
name|String
name|resultKey
decl_stmt|;
DECL|method|DocIdValidator
specifier|public
name|DocIdValidator
parameter_list|(
specifier|final
name|String
name|resultKey
parameter_list|)
block|{
name|this
operator|.
name|resultKey
operator|=
name|resultKey
expr_stmt|;
block|}
DECL|method|DocIdValidator
specifier|public
name|DocIdValidator
parameter_list|()
block|{
name|this
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
block|}
DECL|method|getDefaultTransformerFactoryName
specifier|public
name|String
name|getDefaultTransformerFactoryName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
DECL|method|getFlParam
specifier|public
name|String
name|getFlParam
parameter_list|()
block|{
return|return
name|USAGE
operator|.
name|equals
argument_list|(
name|resultKey
argument_list|)
condition|?
name|resultKey
else|:
name|resultKey
operator|+
literal|":"
operator|+
name|USAGE
return|;
block|}
DECL|method|assertRTGResults
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|assertRTGResults
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|FlValidator
argument_list|>
name|validators
parameter_list|,
specifier|final
name|SolrInputDocument
name|expected
parameter_list|,
specifier|final
name|SolrDocument
name|actual
parameter_list|)
block|{
specifier|final
name|Object
name|value
init|=
name|actual
operator|.
name|getFirstValue
argument_list|(
name|resultKey
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|getFlParam
argument_list|()
operator|+
literal|" => no value in actual doc"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|USAGE
operator|+
literal|" must be an Integer: "
operator|+
name|value
argument_list|,
name|value
operator|instanceof
name|Integer
argument_list|)
expr_stmt|;
name|int
name|minValidDocId
init|=
operator|-
literal|1
decl_stmt|;
comment|// if it comes from update log
for|for
control|(
name|FlValidator
name|other
range|:
name|validators
control|)
block|{
if|if
condition|(
name|other
operator|.
name|requiresRealtimeSearcherReOpen
argument_list|()
condition|)
block|{
name|minValidDocId
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|assertTrue
argument_list|(
name|USAGE
operator|+
literal|" must be>= "
operator|+
name|minValidDocId
operator|+
literal|": "
operator|+
name|value
argument_list|,
name|minValidDocId
operator|<=
operator|(
operator|(
name|Integer
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
expr|<
name|String
operator|>
name|singleton
argument_list|(
name|resultKey
argument_list|)
return|;
block|}
block|}
comment|/** Trivial validator of ShardAugmenterFactory */
DECL|class|ShardValidator
specifier|private
specifier|static
class|class
name|ShardValidator
implements|implements
name|FlValidator
block|{
DECL|field|NAME
specifier|private
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"shard"
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"["
operator|+
name|NAME
operator|+
literal|"]"
decl_stmt|;
DECL|field|resultKey
specifier|private
specifier|final
name|String
name|resultKey
decl_stmt|;
DECL|method|ShardValidator
specifier|public
name|ShardValidator
parameter_list|(
specifier|final
name|String
name|resultKey
parameter_list|)
block|{
name|this
operator|.
name|resultKey
operator|=
name|resultKey
expr_stmt|;
block|}
DECL|method|ShardValidator
specifier|public
name|ShardValidator
parameter_list|()
block|{
name|this
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
block|}
DECL|method|getDefaultTransformerFactoryName
specifier|public
name|String
name|getDefaultTransformerFactoryName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
DECL|method|getFlParam
specifier|public
name|String
name|getFlParam
parameter_list|()
block|{
return|return
name|USAGE
operator|.
name|equals
argument_list|(
name|resultKey
argument_list|)
condition|?
name|resultKey
else|:
name|resultKey
operator|+
literal|":"
operator|+
name|USAGE
return|;
block|}
DECL|method|assertRTGResults
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|assertRTGResults
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|FlValidator
argument_list|>
name|validators
parameter_list|,
specifier|final
name|SolrInputDocument
name|expected
parameter_list|,
specifier|final
name|SolrDocument
name|actual
parameter_list|)
block|{
specifier|final
name|Object
name|value
init|=
name|actual
operator|.
name|getFirstValue
argument_list|(
name|resultKey
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|getFlParam
argument_list|()
operator|+
literal|" => no value in actual doc"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|USAGE
operator|+
literal|" must be an String: "
operator|+
name|value
argument_list|,
name|value
operator|instanceof
name|String
argument_list|)
expr_stmt|;
comment|// trivial sanity check
name|assertFalse
argument_list|(
name|USAGE
operator|+
literal|" => blank string"
argument_list|,
name|value
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
expr|<
name|String
operator|>
name|singleton
argument_list|(
name|resultKey
argument_list|)
return|;
block|}
block|}
comment|/** Trivial validator of ValueAugmenter */
DECL|class|ValueAugmenterValidator
specifier|private
specifier|static
class|class
name|ValueAugmenterValidator
implements|implements
name|FlValidator
block|{
DECL|field|NAME
specifier|private
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"value"
decl_stmt|;
DECL|method|trans
specifier|private
specifier|static
name|String
name|trans
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
literal|"["
operator|+
name|NAME
operator|+
literal|" v="
operator|+
name|value
operator|+
literal|" t=int]"
return|;
block|}
DECL|field|resultKey
specifier|private
specifier|final
name|String
name|resultKey
decl_stmt|;
DECL|field|fl
specifier|private
specifier|final
name|String
name|fl
decl_stmt|;
DECL|field|expectedVal
specifier|private
specifier|final
name|Integer
name|expectedVal
decl_stmt|;
DECL|method|ValueAugmenterValidator
specifier|private
name|ValueAugmenterValidator
parameter_list|(
specifier|final
name|String
name|fl
parameter_list|,
specifier|final
name|int
name|expectedVal
parameter_list|,
specifier|final
name|String
name|resultKey
parameter_list|)
block|{
name|this
operator|.
name|resultKey
operator|=
name|resultKey
expr_stmt|;
name|this
operator|.
name|expectedVal
operator|=
name|expectedVal
expr_stmt|;
name|this
operator|.
name|fl
operator|=
name|fl
expr_stmt|;
block|}
DECL|method|ValueAugmenterValidator
specifier|public
name|ValueAugmenterValidator
parameter_list|(
specifier|final
name|int
name|expectedVal
parameter_list|,
specifier|final
name|String
name|resultKey
parameter_list|)
block|{
name|this
argument_list|(
name|resultKey
operator|+
literal|":"
operator|+
name|trans
argument_list|(
name|expectedVal
argument_list|)
argument_list|,
name|expectedVal
argument_list|,
name|resultKey
argument_list|)
expr_stmt|;
block|}
DECL|method|ValueAugmenterValidator
specifier|public
name|ValueAugmenterValidator
parameter_list|(
specifier|final
name|int
name|expectedVal
parameter_list|)
block|{
comment|// value transformer is weird, default result key doesn't care what params are used...
name|this
argument_list|(
name|trans
argument_list|(
name|expectedVal
argument_list|)
argument_list|,
name|expectedVal
argument_list|,
literal|"["
operator|+
name|NAME
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
DECL|method|getDefaultTransformerFactoryName
specifier|public
name|String
name|getDefaultTransformerFactoryName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
DECL|method|getFlParam
specifier|public
name|String
name|getFlParam
parameter_list|()
block|{
return|return
name|fl
return|;
block|}
DECL|method|assertRTGResults
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|assertRTGResults
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|FlValidator
argument_list|>
name|validators
parameter_list|,
specifier|final
name|SolrInputDocument
name|expected
parameter_list|,
specifier|final
name|SolrDocument
name|actual
parameter_list|)
block|{
specifier|final
name|Object
name|actualVal
init|=
name|actual
operator|.
name|getFirstValue
argument_list|(
name|resultKey
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|getFlParam
argument_list|()
operator|+
literal|" => no value in actual doc"
argument_list|,
name|actualVal
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|getFlParam
argument_list|()
argument_list|,
name|expectedVal
argument_list|,
name|actualVal
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
expr|<
name|String
operator|>
name|singleton
argument_list|(
name|resultKey
argument_list|)
return|;
block|}
block|}
comment|/** Trivial validator of a ValueSourceAugmenter */
DECL|class|FunctionValidator
specifier|private
specifier|static
class|class
name|FunctionValidator
implements|implements
name|FlValidator
block|{
DECL|method|func
specifier|private
specifier|static
name|String
name|func
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
literal|"add(1.3,sub("
operator|+
name|fieldName
operator|+
literal|","
operator|+
name|fieldName
operator|+
literal|"))"
return|;
block|}
DECL|field|fl
specifier|protected
specifier|final
name|String
name|fl
decl_stmt|;
DECL|field|resultKey
specifier|protected
specifier|final
name|String
name|resultKey
decl_stmt|;
DECL|field|fieldName
specifier|protected
specifier|final
name|String
name|fieldName
decl_stmt|;
DECL|method|FunctionValidator
specifier|public
name|FunctionValidator
parameter_list|(
specifier|final
name|String
name|fieldName
parameter_list|)
block|{
name|this
argument_list|(
name|func
argument_list|(
name|fieldName
argument_list|)
argument_list|,
name|fieldName
argument_list|,
name|func
argument_list|(
name|fieldName
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|FunctionValidator
specifier|public
name|FunctionValidator
parameter_list|(
specifier|final
name|String
name|fieldName
parameter_list|,
specifier|final
name|String
name|resultKey
parameter_list|)
block|{
name|this
argument_list|(
name|resultKey
operator|+
literal|":"
operator|+
name|func
argument_list|(
name|fieldName
argument_list|)
argument_list|,
name|fieldName
argument_list|,
name|resultKey
argument_list|)
expr_stmt|;
block|}
DECL|method|FunctionValidator
specifier|private
name|FunctionValidator
parameter_list|(
specifier|final
name|String
name|fl
parameter_list|,
specifier|final
name|String
name|fieldName
parameter_list|,
specifier|final
name|String
name|resultKey
parameter_list|)
block|{
name|this
operator|.
name|fl
operator|=
name|fl
expr_stmt|;
name|this
operator|.
name|resultKey
operator|=
name|resultKey
expr_stmt|;
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
block|}
comment|/** always returns true */
DECL|method|requiresRealtimeSearcherReOpen
specifier|public
name|boolean
name|requiresRealtimeSearcherReOpen
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
DECL|method|getFlParam
specifier|public
name|String
name|getFlParam
parameter_list|()
block|{
return|return
name|fl
return|;
block|}
DECL|method|assertRTGResults
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|assertRTGResults
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|FlValidator
argument_list|>
name|validators
parameter_list|,
specifier|final
name|SolrInputDocument
name|expected
parameter_list|,
specifier|final
name|SolrDocument
name|actual
parameter_list|)
block|{
specifier|final
name|Object
name|origVal
init|=
name|expected
operator|.
name|getFieldValue
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"this validator only works on numeric fields: "
operator|+
name|origVal
argument_list|,
name|origVal
operator|instanceof
name|Number
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fl
argument_list|,
literal|1.3F
argument_list|,
name|actual
operator|.
name|getFirstValue
argument_list|(
name|resultKey
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
expr|<
name|String
operator|>
name|singleton
argument_list|(
name|resultKey
argument_list|)
return|;
block|}
block|}
comment|/**     * Trivial validator of a SubQueryAugmenter.      *    * This validator ignores 90% of the features/complexity    * of SubQueryAugmenter, and instead just focuses on the basics of     * "did we match at least one doc based on a field value of the requested doc?"    */
DECL|class|SubQueryValidator
specifier|private
specifier|static
class|class
name|SubQueryValidator
implements|implements
name|FlValidator
block|{
DECL|field|NAME
specifier|public
specifier|final
specifier|static
name|String
name|NAME
init|=
literal|"subquery"
decl_stmt|;
DECL|field|SUBQ_KEY
specifier|public
specifier|final
specifier|static
name|String
name|SUBQ_KEY
init|=
literal|"subq"
decl_stmt|;
DECL|field|SUBQ_FIELD
specifier|public
specifier|final
specifier|static
name|String
name|SUBQ_FIELD
init|=
literal|"aaa_i"
decl_stmt|;
comment|/** always returns true */
DECL|method|requiresRealtimeSearcherReOpen
specifier|public
name|boolean
name|requiresRealtimeSearcherReOpen
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
DECL|method|getFlParam
specifier|public
name|String
name|getFlParam
parameter_list|()
block|{
return|return
name|SUBQ_KEY
operator|+
literal|":["
operator|+
name|NAME
operator|+
literal|"]"
return|;
block|}
DECL|method|assertRTGResults
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|assertRTGResults
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|FlValidator
argument_list|>
name|validators
parameter_list|,
specifier|final
name|SolrInputDocument
name|expected
parameter_list|,
specifier|final
name|SolrDocument
name|actual
parameter_list|)
block|{
specifier|final
name|Object
name|origVal
init|=
name|expected
operator|.
name|getFieldValue
argument_list|(
name|SUBQ_FIELD
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|actualVal
init|=
name|actual
operator|.
name|getFieldValue
argument_list|(
name|SUBQ_KEY
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Expected a doclist: "
operator|+
name|actualVal
argument_list|,
name|actualVal
operator|instanceof
name|SolrDocumentList
argument_list|)
expr_stmt|;
name|SolrDocumentList
name|subList
init|=
operator|(
name|SolrDocumentList
operator|)
name|actualVal
decl_stmt|;
name|assertTrue
argument_list|(
literal|"sub query should have producted at least one result (this doc)"
argument_list|,
literal|1
operator|<=
name|subList
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|SolrDocument
name|subDoc
range|:
name|subList
control|)
block|{
name|assertEquals
argument_list|(
literal|"orig doc value doesn't match subquery doc value"
argument_list|,
name|origVal
argument_list|,
name|subDoc
operator|.
name|getFirstValue
argument_list|(
name|SUBQ_FIELD
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
expr|<
name|String
operator|>
name|singleton
argument_list|(
name|SUBQ_KEY
argument_list|)
return|;
block|}
DECL|method|getDefaultTransformerFactoryName
specifier|public
name|String
name|getDefaultTransformerFactoryName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
block|}
comment|/** Trivial validator of a GeoTransformer */
DECL|class|GeoTransformerValidator
specifier|private
specifier|static
class|class
name|GeoTransformerValidator
implements|implements
name|FlValidator
implements|,
name|SuppressRealFields
block|{
DECL|field|NAME
specifier|private
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"geo"
decl_stmt|;
comment|/**       * we're not worried about testing the actual geo parsing/formatting of values,      * just that the transformer gets called with the expected field value.      * so have a small set of fixed input values we use when indexing docs,      * and the expected output for each      */
DECL|field|VALUES
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|VALUES
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**       * The set of legal field values this validator is willing to test as a list so we can      * reliably index into it with random ints      */
DECL|field|ALLOWED_FIELD_VALUES
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|ALLOWED_FIELD_VALUES
decl_stmt|;
static|static
block|{
for|for
control|(
name|int
name|i
init|=
operator|-
literal|42
init|;
name|i
operator|<
literal|66
condition|;
name|i
operator|+=
literal|13
control|)
block|{
name|VALUES
operator|.
name|put
argument_list|(
literal|"POINT( 42 "
operator|+
name|i
operator|+
literal|" )"
argument_list|,
literal|"{\"type\":\"Point\",\"coordinates\":[42,"
operator|+
name|i
operator|+
literal|"]}"
argument_list|)
expr_stmt|;
block|}
name|ALLOWED_FIELD_VALUES
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|VALUES
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**       * returns a random field value usable when indexing a document that this validator will      * be able to handle.      */
DECL|method|getValueForIndexing
specifier|public
specifier|static
name|String
name|getValueForIndexing
parameter_list|(
specifier|final
name|Random
name|rand
parameter_list|)
block|{
return|return
name|ALLOWED_FIELD_VALUES
operator|.
name|get
argument_list|(
name|rand
operator|.
name|nextInt
argument_list|(
name|ALLOWED_FIELD_VALUES
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|trans
specifier|private
specifier|static
name|String
name|trans
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
literal|"["
operator|+
name|NAME
operator|+
literal|" f="
operator|+
name|fieldName
operator|+
literal|"]"
return|;
block|}
DECL|field|fl
specifier|protected
specifier|final
name|String
name|fl
decl_stmt|;
DECL|field|resultKey
specifier|protected
specifier|final
name|String
name|resultKey
decl_stmt|;
DECL|field|fieldName
specifier|protected
specifier|final
name|String
name|fieldName
decl_stmt|;
DECL|method|GeoTransformerValidator
specifier|public
name|GeoTransformerValidator
parameter_list|(
specifier|final
name|String
name|fieldName
parameter_list|)
block|{
comment|// geo transformer is weird, default result key doesn't care what params are used...
name|this
argument_list|(
name|trans
argument_list|(
name|fieldName
argument_list|)
argument_list|,
name|fieldName
argument_list|,
literal|"["
operator|+
name|NAME
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
DECL|method|GeoTransformerValidator
specifier|public
name|GeoTransformerValidator
parameter_list|(
specifier|final
name|String
name|fieldName
parameter_list|,
specifier|final
name|String
name|resultKey
parameter_list|)
block|{
name|this
argument_list|(
name|resultKey
operator|+
literal|":"
operator|+
name|trans
argument_list|(
name|fieldName
argument_list|)
argument_list|,
name|fieldName
argument_list|,
name|resultKey
argument_list|)
expr_stmt|;
block|}
DECL|method|GeoTransformerValidator
specifier|private
name|GeoTransformerValidator
parameter_list|(
specifier|final
name|String
name|fl
parameter_list|,
specifier|final
name|String
name|fieldName
parameter_list|,
specifier|final
name|String
name|resultKey
parameter_list|)
block|{
name|this
operator|.
name|fl
operator|=
name|fl
expr_stmt|;
name|this
operator|.
name|resultKey
operator|=
name|resultKey
expr_stmt|;
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
block|}
DECL|method|getDefaultTransformerFactoryName
specifier|public
name|String
name|getDefaultTransformerFactoryName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
DECL|method|getFlParam
specifier|public
name|String
name|getFlParam
parameter_list|()
block|{
return|return
name|fl
return|;
block|}
DECL|method|assertRTGResults
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|assertRTGResults
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|FlValidator
argument_list|>
name|validators
parameter_list|,
specifier|final
name|SolrInputDocument
name|expected
parameter_list|,
specifier|final
name|SolrDocument
name|actual
parameter_list|)
block|{
specifier|final
name|Object
name|origVal
init|=
name|expected
operator|.
name|getFieldValue
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fl
operator|+
literal|": orig field value is not supported: "
operator|+
name|origVal
argument_list|,
name|VALUES
operator|.
name|containsKey
argument_list|(
name|origVal
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fl
argument_list|,
name|VALUES
operator|.
name|get
argument_list|(
name|origVal
argument_list|)
argument_list|,
name|actual
operator|.
name|getFirstValue
argument_list|(
name|resultKey
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
expr|<
name|String
operator|>
name|singleton
argument_list|(
name|resultKey
argument_list|)
return|;
block|}
DECL|method|getSuppressedFields
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getSuppressedFields
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|singleton
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
block|}
comment|/**     * Glob based validator.    * This class checks that every field in the expected doc exists in the actual doc with the expected     * value -- with special exceptions for fields that are "suppressed" (usually via an alias)    *    * By design, fields that are aliased are "moved" unless the original field name was explicitly included     * in the fl, globs don't count.    *    * @see RenameFieldValueValidator    */
DECL|class|GlobValidator
specifier|private
specifier|static
class|class
name|GlobValidator
implements|implements
name|FlValidator
block|{
DECL|field|glob
specifier|private
specifier|final
name|String
name|glob
decl_stmt|;
DECL|method|GlobValidator
specifier|public
name|GlobValidator
parameter_list|(
specifier|final
name|String
name|glob
parameter_list|)
block|{
name|this
operator|.
name|glob
operator|=
name|glob
expr_stmt|;
block|}
DECL|field|matchingFieldsCache
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|matchingFieldsCache
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|getFlParam
specifier|public
name|String
name|getFlParam
parameter_list|()
block|{
return|return
name|glob
return|;
block|}
DECL|method|matchesGlob
specifier|private
name|boolean
name|matchesGlob
parameter_list|(
specifier|final
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|FilenameUtils
operator|.
name|wildcardMatch
argument_list|(
name|fieldName
argument_list|,
name|glob
argument_list|)
condition|)
block|{
name|matchingFieldsCache
operator|.
name|add
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
comment|// Don't calculate it again
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|assertRTGResults
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|assertRTGResults
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|FlValidator
argument_list|>
name|validators
parameter_list|,
specifier|final
name|SolrInputDocument
name|expected
parameter_list|,
specifier|final
name|SolrDocument
name|actual
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|renamed
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|validators
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|FlValidator
name|v
range|:
name|validators
control|)
block|{
if|if
condition|(
name|v
operator|instanceof
name|SuppressRealFields
condition|)
block|{
name|renamed
operator|.
name|addAll
argument_list|(
operator|(
operator|(
name|SuppressRealFields
operator|)
name|v
operator|)
operator|.
name|getSuppressedFields
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// every real field name matching the glob that is not renamed should be in the results
name|Set
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|expected
operator|.
name|getFieldNames
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|expected
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
if|if
condition|(
name|matchesGlob
argument_list|(
name|f
argument_list|)
operator|&&
operator|(
operator|!
name|renamed
operator|.
name|contains
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|glob
operator|+
literal|" => "
operator|+
name|f
argument_list|,
name|expected
operator|.
name|getFieldValue
argument_list|(
name|f
argument_list|)
argument_list|,
name|actual
operator|.
name|getFirstValue
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
block|}
comment|/**     * for things like "score" and "[explain]" where we explicitly expect what we ask for in the fl    * to<b>not</b> be returned when using RTG.    */
DECL|class|NotIncludedValidator
specifier|private
specifier|static
class|class
name|NotIncludedValidator
implements|implements
name|FlValidator
block|{
DECL|field|fieldName
specifier|private
specifier|final
name|String
name|fieldName
decl_stmt|;
DECL|field|fl
specifier|private
specifier|final
name|String
name|fl
decl_stmt|;
DECL|method|NotIncludedValidator
specifier|public
name|NotIncludedValidator
parameter_list|(
specifier|final
name|String
name|fl
parameter_list|)
block|{
name|this
argument_list|(
name|fl
argument_list|,
name|fl
argument_list|)
expr_stmt|;
block|}
DECL|method|NotIncludedValidator
specifier|public
name|NotIncludedValidator
parameter_list|(
specifier|final
name|String
name|fieldName
parameter_list|,
specifier|final
name|String
name|fl
parameter_list|)
block|{
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
name|this
operator|.
name|fl
operator|=
name|fl
expr_stmt|;
block|}
DECL|method|getFlParam
specifier|public
name|String
name|getFlParam
parameter_list|()
block|{
return|return
name|fl
return|;
block|}
DECL|method|assertRTGResults
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|assertRTGResults
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|FlValidator
argument_list|>
name|validators
parameter_list|,
specifier|final
name|SolrInputDocument
name|expected
parameter_list|,
specifier|final
name|SolrDocument
name|actual
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|fl
argument_list|,
literal|null
argument_list|,
name|actual
operator|.
name|getFirstValue
argument_list|(
name|fieldName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
block|}
comment|/** explain should always be ignored when using RTG */
DECL|class|ExplainValidator
specifier|private
specifier|static
class|class
name|ExplainValidator
extends|extends
name|NotIncludedValidator
block|{
DECL|field|NAME
specifier|private
specifier|final
specifier|static
name|String
name|NAME
init|=
literal|"explain"
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|final
specifier|static
name|String
name|USAGE
init|=
literal|"["
operator|+
name|NAME
operator|+
literal|"]"
decl_stmt|;
DECL|method|ExplainValidator
specifier|public
name|ExplainValidator
parameter_list|()
block|{
name|super
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
block|}
DECL|method|ExplainValidator
specifier|public
name|ExplainValidator
parameter_list|(
specifier|final
name|String
name|resultKey
parameter_list|)
block|{
name|super
argument_list|(
name|USAGE
argument_list|,
name|resultKey
operator|+
literal|":"
operator|+
name|USAGE
argument_list|)
expr_stmt|;
block|}
DECL|method|getDefaultTransformerFactoryName
specifier|public
name|String
name|getDefaultTransformerFactoryName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
block|}
comment|/** helper method for adding a random number (may be 0) of items from {@link #FL_VALIDATORS} */
DECL|method|addRandomFlValidators
specifier|private
specifier|static
name|void
name|addRandomFlValidators
parameter_list|(
specifier|final
name|Random
name|r
parameter_list|,
specifier|final
name|Set
argument_list|<
name|FlValidator
argument_list|>
name|validators
parameter_list|)
block|{
name|List
argument_list|<
name|FlValidator
argument_list|>
name|copyToShuffle
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|FL_VALIDATORS
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|copyToShuffle
argument_list|,
name|r
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numToReturn
init|=
name|r
operator|.
name|nextInt
argument_list|(
name|copyToShuffle
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|validators
operator|.
name|addAll
argument_list|(
name|copyToShuffle
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|numToReturn
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Given an ordered list of values to include in a (key) param, randomly groups them (ie: comma seperated)     * into actual param key=values which are returned as a new SolrParams instance    */
DECL|method|buildCommaSepParams
specifier|private
specifier|static
name|SolrParams
name|buildCommaSepParams
parameter_list|(
specifier|final
name|Random
name|rand
parameter_list|,
specifier|final
name|String
name|key
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|values
parameter_list|)
block|{
name|ModifiableSolrParams
name|result
init|=
operator|new
name|ModifiableSolrParams
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|copy
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|values
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|copy
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|slice
init|=
name|copy
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|1
operator|+
name|copy
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|String
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|slice
argument_list|)
argument_list|)
expr_stmt|;
name|slice
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_class

end_unit

