begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|rules
operator|.
name|SystemPropertiesRestoreRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|CloudSolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|CollectionAdminRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|UpdateRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|schema
operator|.
name|FieldTypeDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|schema
operator|.
name|SchemaRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|FacetField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|Group
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|GroupCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|GroupResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|QueryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|schema
operator|.
name|SchemaResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocumentList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|RuleChain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestRule
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|schema
operator|.
name|SchemaRequest
operator|.
name|*
import|;
end_import

begin_class
DECL|class|DocValuesNotIndexedTest
specifier|public
class|class
name|DocValuesNotIndexedTest
extends|extends
name|SolrCloudTestCase
block|{
annotation|@
name|Rule
DECL|field|solrTestRules
specifier|public
name|TestRule
name|solrTestRules
init|=
name|RuleChain
operator|.
name|outerRule
argument_list|(
operator|new
name|SystemPropertiesRestoreRule
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|COLLECTION
specifier|static
specifier|final
name|String
name|COLLECTION
init|=
literal|"dv_coll"
decl_stmt|;
DECL|field|fieldsToTestSingle
specifier|static
name|List
argument_list|<
name|FieldProps
argument_list|>
name|fieldsToTestSingle
init|=
literal|null
decl_stmt|;
DECL|field|fieldsToTestMulti
specifier|static
name|List
argument_list|<
name|FieldProps
argument_list|>
name|fieldsToTestMulti
init|=
literal|null
decl_stmt|;
DECL|field|fieldsToTestGroupSortFirst
specifier|static
name|List
argument_list|<
name|FieldProps
argument_list|>
name|fieldsToTestGroupSortFirst
init|=
literal|null
decl_stmt|;
DECL|field|fieldsToTestGroupSortLast
specifier|static
name|List
argument_list|<
name|FieldProps
argument_list|>
name|fieldsToTestGroupSortLast
init|=
literal|null
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|createCluster
specifier|public
specifier|static
name|void
name|createCluster
parameter_list|()
throws|throws
name|Exception
block|{
name|System
operator|.
name|setProperty
argument_list|(
literal|"managed.schema.mutable"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|configureCluster
argument_list|(
literal|2
argument_list|)
operator|.
name|addConfig
argument_list|(
literal|"conf1"
argument_list|,
name|TEST_PATH
argument_list|()
operator|.
name|resolve
argument_list|(
literal|"configsets"
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"cloud-managed"
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"conf"
argument_list|)
argument_list|)
operator|.
name|configure
argument_list|()
expr_stmt|;
comment|// Need enough shards that we have some shards that don't have any docs on them.
name|CollectionAdminRequest
operator|.
name|createCollection
argument_list|(
name|COLLECTION
argument_list|,
literal|"conf1"
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
operator|.
name|setMaxShardsPerNode
argument_list|(
literal|2
argument_list|)
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|)
expr_stmt|;
name|fieldsToTestSingle
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Stream
operator|.
name|of
argument_list|(
operator|new
name|FieldProps
argument_list|(
literal|"intField"
argument_list|,
literal|"int"
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"longField"
argument_list|,
literal|"long"
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"doubleField"
argument_list|,
literal|"double"
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"floatField"
argument_list|,
literal|"float"
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"dateField"
argument_list|,
literal|"date"
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"stringField"
argument_list|,
literal|"string"
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"boolField"
argument_list|,
literal|"boolean"
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fieldsToTestMulti
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Stream
operator|.
name|of
argument_list|(
operator|new
name|FieldProps
argument_list|(
literal|"intFieldMulti"
argument_list|,
literal|"int"
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"longFieldMulti"
argument_list|,
literal|"long"
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"doubleFieldMulti"
argument_list|,
literal|"double"
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"floatFieldMulti"
argument_list|,
literal|"float"
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"dateFieldMulti"
argument_list|,
literal|"date"
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"stringFieldMulti"
argument_list|,
literal|"string"
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"boolFieldMulti"
argument_list|,
literal|"boolean"
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Fields to test for grouping and sorting with sortMinssingFirst/Last.
name|fieldsToTestGroupSortFirst
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Stream
operator|.
name|of
argument_list|(
operator|new
name|FieldProps
argument_list|(
literal|"intGSF"
argument_list|,
literal|"int"
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"longGSF"
argument_list|,
literal|"long"
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"doubleGSF"
argument_list|,
literal|"double"
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"floatGSF"
argument_list|,
literal|"float"
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"dateGSF"
argument_list|,
literal|"date"
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"stringGSF"
argument_list|,
literal|"string"
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"boolGSF"
argument_list|,
literal|"boolean"
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fieldsToTestGroupSortLast
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Stream
operator|.
name|of
argument_list|(
operator|new
name|FieldProps
argument_list|(
literal|"intGSL"
argument_list|,
literal|"int"
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"longGSL"
argument_list|,
literal|"long"
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"doubleGSL"
argument_list|,
literal|"double"
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"floatGSL"
argument_list|,
literal|"float"
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"dateGSL"
argument_list|,
literal|"date"
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"stringGSL"
argument_list|,
literal|"string"
argument_list|)
argument_list|,
operator|new
name|FieldProps
argument_list|(
literal|"boolGSL"
argument_list|,
literal|"boolean"
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Update
argument_list|>
name|updateList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fieldsToTestSingle
operator|.
name|size
argument_list|()
operator|+
name|fieldsToTestMulti
operator|.
name|size
argument_list|()
operator|+
name|fieldsToTestGroupSortFirst
operator|.
name|size
argument_list|()
operator|+
name|fieldsToTestGroupSortLast
operator|.
name|size
argument_list|()
operator|+
literal|4
argument_list|)
decl_stmt|;
name|updateList
operator|.
name|add
argument_list|(
name|getType
argument_list|(
literal|"name"
argument_list|,
literal|"float"
argument_list|,
literal|"class"
argument_list|,
literal|"solr.TrieFloatField"
argument_list|,
literal|"precisionStep"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
name|updateList
operator|.
name|add
argument_list|(
name|getType
argument_list|(
literal|"name"
argument_list|,
literal|"double"
argument_list|,
literal|"class"
argument_list|,
literal|"solr.TrieDoubleField"
argument_list|,
literal|"precisionStep"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
name|updateList
operator|.
name|add
argument_list|(
name|getType
argument_list|(
literal|"name"
argument_list|,
literal|"date"
argument_list|,
literal|"class"
argument_list|,
literal|"solr.TrieDateField"
argument_list|,
literal|"precisionStep"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
name|updateList
operator|.
name|add
argument_list|(
name|getType
argument_list|(
literal|"name"
argument_list|,
literal|"boolean"
argument_list|,
literal|"class"
argument_list|,
literal|"solr.BoolField"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add a field for each of the types we want to the schema.
name|defineFields
argument_list|(
name|updateList
argument_list|,
name|fieldsToTestSingle
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|defineFields
argument_list|(
name|updateList
argument_list|,
name|fieldsToTestMulti
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|defineFields
argument_list|(
name|updateList
argument_list|,
name|fieldsToTestGroupSortFirst
argument_list|,
literal|false
argument_list|,
literal|"sorMissingFirst"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|defineFields
argument_list|(
name|updateList
argument_list|,
name|fieldsToTestGroupSortLast
argument_list|,
literal|false
argument_list|,
literal|"sorMissingLast"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|MultiUpdate
name|multiUpdateRequest
init|=
operator|new
name|MultiUpdate
argument_list|(
name|updateList
argument_list|)
decl_stmt|;
name|SchemaResponse
operator|.
name|UpdateResponse
name|multipleUpdatesResponse
init|=
name|multiUpdateRequest
operator|.
name|process
argument_list|(
name|cluster
operator|.
name|getSolrClient
argument_list|()
argument_list|,
name|COLLECTION
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
literal|"Error adding fields"
argument_list|,
name|multipleUpdatesResponse
operator|.
name|getResponse
argument_list|()
operator|.
name|get
argument_list|(
literal|"errors"
argument_list|)
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|getSolrClient
argument_list|()
operator|.
name|setDefaultCollection
argument_list|(
name|COLLECTION
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Before
DECL|method|before
specifier|public
name|void
name|before
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
name|CloudSolrClient
name|client
init|=
name|cluster
operator|.
name|getSolrClient
argument_list|()
decl_stmt|;
name|client
operator|.
name|deleteByQuery
argument_list|(
literal|"*:*"
argument_list|)
expr_stmt|;
name|client
operator|.
name|commit
argument_list|()
expr_stmt|;
name|resetFieldBases
argument_list|(
name|fieldsToTestSingle
argument_list|)
expr_stmt|;
name|resetFieldBases
argument_list|(
name|fieldsToTestMulti
argument_list|)
expr_stmt|;
name|resetFieldBases
argument_list|(
name|fieldsToTestGroupSortFirst
argument_list|)
expr_stmt|;
name|resetFieldBases
argument_list|(
name|fieldsToTestGroupSortLast
argument_list|)
expr_stmt|;
block|}
DECL|method|resetFieldBases
specifier|private
name|void
name|resetFieldBases
parameter_list|(
name|List
argument_list|<
name|FieldProps
argument_list|>
name|props
parameter_list|)
block|{
comment|// OK, it's not bad with the int and string fields, but every time a new test counts on docs being
comment|// indexed so they sort in a particular order, then particularly the boolean and string fields need to be
comment|// reset to a known state.
for|for
control|(
name|FieldProps
name|prop
range|:
name|props
control|)
block|{
name|prop
operator|.
name|resetBase
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testDistribFaceting
specifier|public
name|void
name|testDistribFaceting
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
comment|// For this test, I want to insure that there are shards that do _not_ have a doc with any of the DV_only
comment|// fields, see SOLR-5260. So I'll add exactly 1 document to a 4 shard collection.
name|CloudSolrClient
name|client
init|=
name|cluster
operator|.
name|getSolrClient
argument_list|()
decl_stmt|;
name|SolrInputDocument
name|doc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
name|doc
operator|.
name|addField
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
for|for
control|(
name|FieldProps
name|prop
range|:
name|fieldsToTestSingle
control|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
name|prop
operator|.
name|getValue
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|FieldProps
name|prop
range|:
name|fieldsToTestMulti
control|)
block|{
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
literal|5
condition|;
operator|++
name|idx
control|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
name|prop
operator|.
name|getValue
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|new
name|UpdateRequest
argument_list|()
operator|.
name|add
argument_list|(
name|doc
argument_list|)
operator|.
name|commit
argument_list|(
name|client
argument_list|,
name|COLLECTION
argument_list|)
expr_stmt|;
specifier|final
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"rows"
argument_list|,
literal|"0"
argument_list|)
decl_stmt|;
name|solrQuery
operator|.
name|setFacet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|FieldProps
name|prop
range|:
name|fieldsToTestSingle
control|)
block|{
name|solrQuery
operator|.
name|addFacetField
argument_list|(
name|prop
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|FieldProps
name|prop
range|:
name|fieldsToTestMulti
control|)
block|{
name|solrQuery
operator|.
name|addFacetField
argument_list|(
name|prop
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|QueryResponse
name|rsp
init|=
name|client
operator|.
name|query
argument_list|(
name|COLLECTION
argument_list|,
name|solrQuery
argument_list|)
decl_stmt|;
for|for
control|(
name|FieldProps
name|props
range|:
name|fieldsToTestSingle
control|)
block|{
name|testFacet
argument_list|(
name|props
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|FieldProps
name|props
range|:
name|fieldsToTestMulti
control|)
block|{
name|testFacet
argument_list|(
name|props
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
block|}
block|}
comment|// We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.
annotation|@
name|Test
DECL|method|testGroupingSorting
specifier|public
name|void
name|testGroupingSorting
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
name|CloudSolrClient
name|client
init|=
name|cluster
operator|.
name|getSolrClient
argument_list|()
decl_stmt|;
comment|// The point of these is to have at least one shard w/o the value.
comment|// While getting values for each of these fields starts _out_ random, each successive
comment|// _value_ increases.
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|docs
operator|.
name|add
argument_list|(
name|makeGSDoc
argument_list|(
literal|2
argument_list|,
name|fieldsToTestGroupSortFirst
argument_list|,
name|fieldsToTestGroupSortLast
argument_list|)
argument_list|)
expr_stmt|;
name|docs
operator|.
name|add
argument_list|(
name|makeGSDoc
argument_list|(
literal|1
argument_list|,
name|fieldsToTestGroupSortFirst
argument_list|,
name|fieldsToTestGroupSortLast
argument_list|)
argument_list|)
expr_stmt|;
name|docs
operator|.
name|add
argument_list|(
name|makeGSDoc
argument_list|(
literal|3
argument_list|,
name|fieldsToTestGroupSortFirst
argument_list|,
name|fieldsToTestGroupSortLast
argument_list|)
argument_list|)
expr_stmt|;
name|SolrInputDocument
name|doc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
name|doc
operator|.
name|addField
argument_list|(
literal|"id"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|docs
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
operator|new
name|UpdateRequest
argument_list|()
operator|.
name|add
argument_list|(
name|docs
argument_list|)
operator|.
name|commit
argument_list|(
name|client
argument_list|,
name|COLLECTION
argument_list|)
expr_stmt|;
name|checkSortOrder
argument_list|(
name|client
argument_list|,
name|fieldsToTestGroupSortFirst
argument_list|,
literal|"asc"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"4"
block|,
literal|"2"
block|,
literal|"1"
block|,
literal|"3"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"4"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|}
argument_list|)
expr_stmt|;
name|checkSortOrder
argument_list|(
name|client
argument_list|,
name|fieldsToTestGroupSortFirst
argument_list|,
literal|"desc"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"3"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"4"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"2"
block|,
literal|"3"
block|,
literal|"1"
block|,
literal|"4"
block|}
argument_list|)
expr_stmt|;
name|checkSortOrder
argument_list|(
name|client
argument_list|,
name|fieldsToTestGroupSortLast
argument_list|,
literal|"asc"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"4"
block|,
literal|"2"
block|,
literal|"1"
block|,
literal|"3"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"4"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|}
argument_list|)
expr_stmt|;
name|checkSortOrder
argument_list|(
name|client
argument_list|,
name|fieldsToTestGroupSortLast
argument_list|,
literal|"desc"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"3"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"4"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"2"
block|,
literal|"3"
block|,
literal|"1"
block|,
literal|"4"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|checkSortOrder
specifier|private
name|void
name|checkSortOrder
parameter_list|(
name|CloudSolrClient
name|client
parameter_list|,
name|List
argument_list|<
name|FieldProps
argument_list|>
name|props
parameter_list|,
name|String
name|sortDir
parameter_list|,
name|String
index|[]
name|order
parameter_list|,
name|String
index|[]
name|orderBool
parameter_list|)
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
for|for
control|(
name|FieldProps
name|prop
range|:
name|props
control|)
block|{
specifier|final
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"rows"
argument_list|,
literal|"100"
argument_list|)
decl_stmt|;
name|solrQuery
operator|.
name|setSort
argument_list|(
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
literal|"asc"
operator|.
name|equals
argument_list|(
name|sortDir
argument_list|)
condition|?
name|SolrQuery
operator|.
name|ORDER
operator|.
name|asc
else|:
name|SolrQuery
operator|.
name|ORDER
operator|.
name|desc
argument_list|)
expr_stmt|;
name|solrQuery
operator|.
name|addSort
argument_list|(
literal|"id"
argument_list|,
name|SolrQuery
operator|.
name|ORDER
operator|.
name|asc
argument_list|)
expr_stmt|;
specifier|final
name|QueryResponse
name|rsp
init|=
name|client
operator|.
name|query
argument_list|(
name|COLLECTION
argument_list|,
name|solrQuery
argument_list|)
decl_stmt|;
name|SolrDocumentList
name|res
init|=
name|rsp
operator|.
name|getResults
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Should have exactly "
operator|+
name|order
operator|.
name|length
operator|+
literal|" documents returned"
argument_list|,
name|order
operator|.
name|length
argument_list|,
name|res
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|expected
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|res
operator|.
name|size
argument_list|()
condition|;
operator|++
name|idx
control|)
block|{
if|if
condition|(
name|prop
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"bool"
argument_list|)
condition|)
name|expected
operator|=
name|orderBool
index|[
name|idx
index|]
expr_stmt|;
else|else
name|expected
operator|=
name|order
index|[
name|idx
index|]
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Documents in wrong order for field: "
operator|+
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
name|expected
argument_list|,
name|res
operator|.
name|get
argument_list|(
name|idx
argument_list|)
operator|.
name|get
argument_list|(
literal|"id"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Test
DECL|method|testGroupingDocAbsent
specifier|public
name|void
name|testGroupingDocAbsent
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|docs
operator|.
name|add
argument_list|(
name|makeGSDoc
argument_list|(
literal|2
argument_list|,
name|fieldsToTestGroupSortFirst
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|docs
operator|.
name|add
argument_list|(
name|makeGSDoc
argument_list|(
literal|1
argument_list|,
name|fieldsToTestGroupSortFirst
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|docs
operator|.
name|add
argument_list|(
name|makeGSDoc
argument_list|(
literal|3
argument_list|,
name|fieldsToTestGroupSortFirst
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|SolrInputDocument
name|doc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
name|doc
operator|.
name|addField
argument_list|(
literal|"id"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|docs
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|CloudSolrClient
name|client
init|=
name|cluster
operator|.
name|getSolrClient
argument_list|()
decl_stmt|;
operator|new
name|UpdateRequest
argument_list|()
operator|.
name|add
argument_list|(
name|docs
argument_list|)
operator|.
name|commit
argument_list|(
name|client
argument_list|,
name|COLLECTION
argument_list|)
expr_stmt|;
comment|// when grouping on any of these DV-only (not indexed) fields we expect exactly 4 groups except for Boolean.
for|for
control|(
name|FieldProps
name|prop
range|:
name|fieldsToTestGroupSortFirst
control|)
block|{
comment|// Special handling until SOLR-9802 is fixed
if|if
condition|(
name|prop
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"date"
argument_list|)
condition|)
continue|continue;
comment|// SOLR-9802 to here
specifier|final
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"group"
argument_list|,
literal|"true"
argument_list|,
literal|"group.field"
argument_list|,
name|prop
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|QueryResponse
name|rsp
init|=
name|client
operator|.
name|query
argument_list|(
name|COLLECTION
argument_list|,
name|solrQuery
argument_list|)
decl_stmt|;
name|GroupResponse
name|groupResponse
init|=
name|rsp
operator|.
name|getGroupResponse
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|GroupCommand
argument_list|>
name|commands
init|=
name|groupResponse
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|GroupCommand
name|fieldCommand
init|=
name|commands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|expected
init|=
literal|4
decl_stmt|;
if|if
condition|(
name|prop
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"bool"
argument_list|)
condition|)
name|expected
operator|=
literal|3
expr_stmt|;
comment|//true, false and null
name|List
argument_list|<
name|Group
argument_list|>
name|fieldCommandGroups
init|=
name|fieldCommand
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Did not find the expected number of groups!"
argument_list|,
name|expected
argument_list|,
name|fieldCommandGroups
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|// Verify that we actually form groups that are "expected". Most of the processing takes some care to
comment|// make sure all the values for each field are unique. We need to have docs that have values that are _not_
comment|// unique.
DECL|method|testGroupingDVOnly
specifier|public
name|void
name|testGroupingDVOnly
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|50
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
literal|49
condition|;
operator|++
name|idx
control|)
block|{
name|SolrInputDocument
name|doc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
name|doc
operator|.
name|addField
argument_list|(
literal|"id"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|boolean
name|doInc
init|=
operator|(
operator|(
name|idx
operator|%
literal|7
operator|)
operator|==
literal|0
operator|)
decl_stmt|;
for|for
control|(
name|FieldProps
name|prop
range|:
name|fieldsToTestGroupSortFirst
control|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
name|prop
operator|.
name|getValue
argument_list|(
name|doInc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|docs
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|idx
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
name|doc
operator|=
operator|new
name|SolrInputDocument
argument_list|()
expr_stmt|;
name|doc
operator|.
name|addField
argument_list|(
literal|"id"
argument_list|,
name|idx
operator|+
literal|100
argument_list|)
expr_stmt|;
name|docs
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
name|CloudSolrClient
name|client
init|=
name|cluster
operator|.
name|getSolrClient
argument_list|()
decl_stmt|;
operator|new
name|UpdateRequest
argument_list|()
operator|.
name|add
argument_list|(
name|docs
argument_list|)
operator|.
name|commit
argument_list|(
name|client
argument_list|,
name|COLLECTION
argument_list|)
expr_stmt|;
comment|// OK, we should have one group with 10 entries for null, a group with 1 entry and 7 groups with 7
for|for
control|(
name|FieldProps
name|prop
range|:
name|fieldsToTestGroupSortFirst
control|)
block|{
comment|// Special handling until SOLR-9802 is fixed
if|if
condition|(
name|prop
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"date"
argument_list|)
condition|)
continue|continue;
comment|// SOLR-9802 to here
specifier|final
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"rows"
argument_list|,
literal|"100"
argument_list|,
literal|"group"
argument_list|,
literal|"true"
argument_list|,
literal|"group.field"
argument_list|,
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
literal|"group.limit"
argument_list|,
literal|"100"
argument_list|)
decl_stmt|;
specifier|final
name|QueryResponse
name|rsp
init|=
name|client
operator|.
name|query
argument_list|(
name|COLLECTION
argument_list|,
name|solrQuery
argument_list|)
decl_stmt|;
name|GroupResponse
name|groupResponse
init|=
name|rsp
operator|.
name|getGroupResponse
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|GroupCommand
argument_list|>
name|commands
init|=
name|groupResponse
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|int
name|nullCount
init|=
literal|0
decl_stmt|;
name|int
name|sevenCount
init|=
literal|0
decl_stmt|;
name|int
name|boolCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|commands
operator|.
name|size
argument_list|()
condition|;
operator|++
name|idx
control|)
block|{
name|GroupCommand
name|fieldCommand
init|=
name|commands
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
for|for
control|(
name|Group
name|grp
range|:
name|fieldCommand
operator|.
name|getValues
argument_list|()
control|)
block|{
switch|switch
condition|(
name|grp
operator|.
name|getResult
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|7
case|:
operator|++
name|sevenCount
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"Every group with 7 entries should have a group value."
argument_list|,
name|grp
operator|.
name|getGroupValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
operator|++
name|nullCount
expr_stmt|;
name|assertNull
argument_list|(
literal|"This should be the null group"
argument_list|,
name|grp
operator|.
name|getGroupValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|25
case|:
case|case
literal|24
case|:
operator|++
name|boolCount
expr_stmt|;
name|assertEquals
argument_list|(
literal|"We should have more counts for boolean fields!"
argument_list|,
literal|"boolGSF"
argument_list|,
name|prop
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fail
argument_list|(
literal|"Unexpected number of elements in the group for "
operator|+
name|prop
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|grp
operator|.
name|getResult
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|assertEquals
argument_list|(
literal|"Should be exactly one group with 1 entry of 10 for null for field "
operator|+
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
literal|1
argument_list|,
name|nullCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"bool"
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|"Should be exactly 2 groups with non-null Boolean types "
operator|+
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
literal|2
argument_list|,
name|boolCount
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Should be no seven count groups for Boolean types "
operator|+
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
literal|0
argument_list|,
name|sevenCount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
literal|"Should be exactly 7 groups with seven entries for field "
operator|+
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
literal|7
argument_list|,
name|sevenCount
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Should be no gropus with 24 or 25 entries for field "
operator|+
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
literal|0
argument_list|,
name|boolCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|makeGSDoc
specifier|private
name|SolrInputDocument
name|makeGSDoc
parameter_list|(
name|int
name|id
parameter_list|,
name|List
argument_list|<
name|FieldProps
argument_list|>
name|p1
parameter_list|,
name|List
argument_list|<
name|FieldProps
argument_list|>
name|p2
parameter_list|,
name|String
modifier|...
name|args
parameter_list|)
block|{
name|SolrInputDocument
name|doc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
name|doc
operator|.
name|addField
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
for|for
control|(
name|FieldProps
name|prop
range|:
name|p1
control|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
name|prop
operator|.
name|getValue
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p2
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FieldProps
name|prop
range|:
name|p2
control|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prop
operator|.
name|getName
argument_list|()
argument_list|,
name|prop
operator|.
name|getValue
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|args
operator|.
name|length
condition|;
name|idx
operator|+=
literal|2
control|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|,
name|args
index|[
name|idx
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|doc
return|;
block|}
DECL|method|defineFields
specifier|private
specifier|static
name|void
name|defineFields
parameter_list|(
name|List
argument_list|<
name|Update
argument_list|>
name|updateList
parameter_list|,
name|List
argument_list|<
name|FieldProps
argument_list|>
name|props
parameter_list|,
name|boolean
name|multi
parameter_list|,
name|String
modifier|...
name|extras
parameter_list|)
block|{
for|for
control|(
name|FieldProps
name|prop
range|:
name|props
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|fieldAttributes
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|fieldAttributes
operator|.
name|put
argument_list|(
literal|"name"
argument_list|,
name|prop
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|fieldAttributes
operator|.
name|put
argument_list|(
literal|"type"
argument_list|,
name|prop
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|fieldAttributes
operator|.
name|put
argument_list|(
literal|"indexed"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|fieldAttributes
operator|.
name|put
argument_list|(
literal|"multiValued"
argument_list|,
name|multi
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|fieldAttributes
operator|.
name|put
argument_list|(
literal|"docValues"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|updateList
operator|.
name|add
argument_list|(
operator|new
name|AddField
argument_list|(
name|fieldAttributes
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getType
specifier|private
specifier|static
name|AddFieldType
name|getType
parameter_list|(
name|String
modifier|...
name|args
parameter_list|)
block|{
name|FieldTypeDefinition
name|ftd
init|=
operator|new
name|FieldTypeDefinition
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|ftas
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|args
operator|.
name|length
condition|;
name|idx
operator|+=
literal|2
control|)
block|{
name|ftas
operator|.
name|put
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|,
name|args
index|[
name|idx
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|ftd
operator|.
name|setAttributes
argument_list|(
name|ftas
argument_list|)
expr_stmt|;
return|return
operator|new
name|SchemaRequest
operator|.
name|AddFieldType
argument_list|(
name|ftd
argument_list|)
return|;
block|}
DECL|method|testFacet
specifier|private
name|void
name|testFacet
parameter_list|(
name|FieldProps
name|props
parameter_list|,
name|QueryResponse
name|rsp
parameter_list|)
block|{
name|String
name|name
init|=
name|props
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FacetField
operator|.
name|Count
argument_list|>
name|counts
init|=
name|rsp
operator|.
name|getFacetField
argument_list|(
name|name
argument_list|)
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|long
name|expectedCount
init|=
name|props
operator|.
name|getExpectedCount
argument_list|()
decl_stmt|;
name|long
name|foundCount
init|=
name|getCount
argument_list|(
name|counts
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Field "
operator|+
name|name
operator|+
literal|" should have a count of "
operator|+
name|expectedCount
argument_list|,
name|expectedCount
argument_list|,
name|foundCount
argument_list|)
expr_stmt|;
block|}
DECL|method|getCount
specifier|private
name|long
name|getCount
parameter_list|(
specifier|final
name|List
argument_list|<
name|FacetField
operator|.
name|Count
argument_list|>
name|counts
parameter_list|)
block|{
return|return
name|counts
operator|.
name|stream
argument_list|()
operator|.
name|mapToLong
argument_list|(
name|FacetField
operator|.
name|Count
operator|::
name|getCount
argument_list|)
operator|.
name|sum
argument_list|()
return|;
block|}
block|}
end_class

begin_class
DECL|class|FieldProps
class|class
name|FieldProps
block|{
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|type
specifier|private
specifier|final
name|String
name|type
decl_stmt|;
DECL|field|expectedCount
specifier|private
specifier|final
name|int
name|expectedCount
decl_stmt|;
DECL|field|base
specifier|private
name|Object
name|base
decl_stmt|;
DECL|field|counter
specifier|private
name|int
name|counter
init|=
literal|0
decl_stmt|;
DECL|field|format
specifier|static
name|SimpleDateFormat
name|format
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
DECL|method|FieldProps
name|FieldProps
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|type
parameter_list|,
name|int
name|expectedCount
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|expectedCount
operator|=
name|expectedCount
expr_stmt|;
name|resetBase
argument_list|()
expr_stmt|;
block|}
DECL|method|resetBase
name|void
name|resetBase
parameter_list|()
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"int"
argument_list|)
condition|)
block|{
name|base
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|DocValuesNotIndexedTest
operator|.
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"long"
argument_list|)
condition|)
block|{
name|base
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|DocValuesNotIndexedTest
operator|.
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
name|base
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|DocValuesNotIndexedTest
operator|.
name|random
argument_list|()
operator|.
name|nextFloat
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
name|base
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|DocValuesNotIndexedTest
operator|.
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"date"
argument_list|)
condition|)
block|{
name|base
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|DocValuesNotIndexedTest
operator|.
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"bool"
argument_list|)
condition|)
block|{
name|base
operator|=
literal|true
expr_stmt|;
comment|// Must start with a known value since bools only have a two values....
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
name|base
operator|=
literal|"base_string_"
operator|+
name|DocValuesNotIndexedTest
operator|.
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|1_000_000
argument_list|)
operator|+
literal|"_"
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Should have found a prefix for the field before now!"
argument_list|)
throw|;
block|}
block|}
DECL|method|FieldProps
name|FieldProps
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|type
parameter_list|)
block|{
name|this
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|getName
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getType
name|String
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
DECL|method|getExpectedCount
name|int
name|getExpectedCount
parameter_list|()
block|{
return|return
name|expectedCount
return|;
block|}
DECL|method|getValue
specifier|public
name|String
name|getValue
parameter_list|(
name|boolean
name|incrementCounter
parameter_list|)
block|{
if|if
condition|(
name|incrementCounter
condition|)
block|{
name|counter
operator|+=
name|DocValuesNotIndexedTest
operator|.
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|+
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"int"
argument_list|)
condition|)
block|{
return|return
name|Integer
operator|.
name|toString
argument_list|(
operator|(
name|int
operator|)
name|base
operator|+
name|counter
argument_list|)
return|;
block|}
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"long"
argument_list|)
condition|)
block|{
return|return
name|Long
operator|.
name|toString
argument_list|(
operator|(
name|long
operator|)
name|base
operator|+
name|counter
argument_list|)
return|;
block|}
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
return|return
name|Float
operator|.
name|toString
argument_list|(
operator|(
name|float
operator|)
name|base
operator|+
name|counter
argument_list|)
return|;
block|}
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
return|return
name|Double
operator|.
name|toString
argument_list|(
operator|(
name|double
operator|)
name|base
operator|+
name|counter
argument_list|)
return|;
block|}
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"date"
argument_list|)
condition|)
block|{
return|return
name|format
operator|.
name|format
argument_list|(
literal|985_847_645
operator|+
operator|(
name|long
operator|)
name|base
operator|+
name|counter
argument_list|)
return|;
block|}
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"bool"
argument_list|)
condition|)
block|{
name|String
name|ret
init|=
name|Boolean
operator|.
name|toString
argument_list|(
operator|(
name|boolean
operator|)
name|base
argument_list|)
decl_stmt|;
name|base
operator|=
operator|!
operator|(
operator|(
name|boolean
operator|)
name|base
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%s_%08d"
argument_list|,
operator|(
name|String
operator|)
name|base
argument_list|,
name|counter
argument_list|)
return|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Should have found a prefix for the field before now!"
argument_list|)
throw|;
block|}
block|}
end_class

end_unit

