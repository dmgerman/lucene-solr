begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.update
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|internal
operator|.
name|matchers
operator|.
name|StringContains
operator|.
name|containsString
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateLogTest
operator|.
name|buildAddUpdateCommand
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|SolrTestCaseJ4
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|embedded
operator|.
name|EmbeddedSolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocumentList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributedUpdateProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|AtomicUpdateDocumentMerger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RefCounted
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_comment
comment|/**  * Tests the in-place updates (docValues updates) for a standalone Solr instance.  */
end_comment

begin_class
DECL|class|TestInPlaceUpdatesStandalone
specifier|public
class|class
name|TestInPlaceUpdatesStandalone
extends|extends
name|SolrTestCaseJ4
block|{
DECL|field|client
specifier|private
specifier|static
name|SolrClient
name|client
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|beforeClass
specifier|public
specifier|static
name|void
name|beforeClass
parameter_list|()
throws|throws
name|Exception
block|{
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.tests.intClassName"
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"TrieIntField"
else|:
literal|"IntPointField"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.tests.longClassName"
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"TrieLongField"
else|:
literal|"LongPointField"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.tests.floatClassName"
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"TrieFloatField"
else|:
literal|"FloatPointField"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.tests.doubleClassName"
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"TrieDoubleField"
else|:
literal|"DoublePointField"
argument_list|)
expr_stmt|;
name|initCore
argument_list|(
literal|"solrconfig-tlog.xml"
argument_list|,
literal|"schema-inplace-updates.xml"
argument_list|)
expr_stmt|;
comment|// sanity check that autocommits are disabled
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getUpdateHandlerInfo
argument_list|()
operator|.
name|autoCommmitMaxTime
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getUpdateHandlerInfo
argument_list|()
operator|.
name|autoSoftCommmitMaxTime
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getUpdateHandlerInfo
argument_list|()
operator|.
name|autoCommmitMaxDocs
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getUpdateHandlerInfo
argument_list|()
operator|.
name|autoSoftCommmitMaxDocs
argument_list|)
expr_stmt|;
comment|// validate that the schema was not changed to an unexpected state
name|IndexSchema
name|schema
init|=
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getLatestSchema
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|Arrays
operator|.
name|asList
argument_list|(
literal|"_version_"
argument_list|,
literal|"inplace_l_dvo"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
literal|"inplace_updatable_int"
argument_list|,
literal|"inplace_updatable_float_with_default"
argument_list|,
literal|"inplace_updatable_int_with_default"
argument_list|)
control|)
block|{
comment|// these fields must only be using docValues to support inplace updates
name|SchemaField
name|field
init|=
name|schema
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|field
operator|.
name|toString
argument_list|()
argument_list|,
name|field
operator|.
name|hasDocValues
argument_list|()
operator|&&
operator|!
name|field
operator|.
name|indexed
argument_list|()
operator|&&
operator|!
name|field
operator|.
name|stored
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|fieldName
range|:
name|Arrays
operator|.
name|asList
argument_list|(
literal|"title_s"
argument_list|,
literal|"regular_l"
argument_list|,
literal|"stored_i"
argument_list|)
control|)
block|{
comment|// these fields must support atomic updates, but not inplace updates (ie: stored)
name|SchemaField
name|field
init|=
name|schema
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|field
operator|.
name|toString
argument_list|()
argument_list|,
name|field
operator|.
name|stored
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Don't close this client, it would shutdown the CoreContainer
name|client
operator|=
operator|new
name|EmbeddedSolrServer
argument_list|(
name|h
operator|.
name|getCoreContainer
argument_list|()
argument_list|,
name|h
operator|.
name|coreName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|after
specifier|public
name|void
name|after
parameter_list|()
block|{
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.tests.intClassName"
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.tests.longClassName"
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.tests.floatClassName"
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.tests.doubleClassName"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Before
DECL|method|deleteAllAndCommit
specifier|public
name|void
name|deleteAllAndCommit
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testUpdatingDocValues
specifier|public
name|void
name|testUpdatingDocValues
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|version1
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"title_s"
argument_list|,
literal|"first"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
literal|41
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|long
name|version2
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"title_s"
argument_list|,
literal|"second"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
literal|42
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|long
name|version3
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"title_s"
argument_list|,
literal|"third"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
literal|43
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"//*[@numFound='3']"
argument_list|)
expr_stmt|;
comment|// the reason we're fetching these docids is to validate that the subsequent updates
comment|// are done in place and don't cause the docids to change
name|int
name|docid1
init|=
name|getDocId
argument_list|(
literal|"1"
argument_list|)
decl_stmt|;
name|int
name|docid2
init|=
name|getDocId
argument_list|(
literal|"2"
argument_list|)
decl_stmt|;
name|int
name|docid3
init|=
name|getDocId
argument_list|(
literal|"3"
argument_list|)
decl_stmt|;
comment|// Check docValues were "set"
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|200
argument_list|)
argument_list|)
expr_stmt|;
name|version2
operator|=
name|addAndAssertVersion
argument_list|(
name|version2
argument_list|,
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|300
argument_list|)
argument_list|)
expr_stmt|;
name|version3
operator|=
name|addAndAssertVersion
argument_list|(
name|version3
argument_list|,
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"id asc"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,[docid]"
argument_list|)
argument_list|,
literal|"//*[@numFound='3']"
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='200.0']"
argument_list|,
literal|"//result/doc[2]/float[@name='inplace_updatable_float'][.='300.0']"
argument_list|,
literal|"//result/doc[3]/float[@name='inplace_updatable_float'][.='100.0']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|version1
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[2]/long[@name='_version_'][.='"
operator|+
name|version2
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[3]/long[@name='_version_'][.='"
operator|+
name|version3
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[1]/int[@name='[docid]'][.='"
operator|+
name|docid1
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[2]/int[@name='[docid]'][.='"
operator|+
name|docid2
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[3]/int[@name='[docid]'][.='"
operator|+
name|docid3
operator|+
literal|"']"
argument_list|)
expr_stmt|;
comment|// Check docValues are "inc"ed
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|version2
operator|=
name|addAndAssertVersion
argument_list|(
name|version2
argument_list|,
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|version3
operator|=
name|addAndAssertVersion
argument_list|(
name|version3
argument_list|,
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"id asc"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,[docid]"
argument_list|)
argument_list|,
literal|"//*[@numFound='3']"
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='201.0']"
argument_list|,
literal|"//result/doc[2]/float[@name='inplace_updatable_float'][.='298.0']"
argument_list|,
literal|"//result/doc[3]/float[@name='inplace_updatable_float'][.='103.0']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|version1
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[2]/long[@name='_version_'][.='"
operator|+
name|version2
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[3]/long[@name='_version_'][.='"
operator|+
name|version3
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[1]/int[@name='[docid]'][.='"
operator|+
name|docid1
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[2]/int[@name='[docid]'][.='"
operator|+
name|docid2
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[3]/int[@name='[docid]'][.='"
operator|+
name|docid3
operator|+
literal|"']"
argument_list|)
expr_stmt|;
comment|// Check back to back "inc"s are working (off the transaction log)
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// new value should be 204
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,[docid]"
argument_list|)
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='204.0']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|version1
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[1]/int[@name='[docid]'][.='"
operator|+
name|docid1
operator|+
literal|"']"
argument_list|)
expr_stmt|;
comment|// Now let the document be atomically updated (non-inplace), ensure the old docvalue is part of new doc
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"title_s"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|"new first"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|newDocid1
init|=
name|getDocId
argument_list|(
literal|"1"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|newDocid1
operator|!=
name|docid1
argument_list|)
expr_stmt|;
name|docid1
operator|=
name|newDocid1
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1"
argument_list|)
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='204.0']"
argument_list|,
literal|"//result/doc[1]/str[@name='title_s'][.='new first']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|version1
operator|+
literal|"']"
argument_list|)
expr_stmt|;
comment|// Check if atomic update with "inc" to a docValue works
name|version2
operator|=
name|addAndAssertVersion
argument_list|(
name|version2
argument_list|,
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"title_s"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|"new second"
argument_list|)
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|newDocid2
init|=
name|getDocId
argument_list|(
literal|"2"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|newDocid2
operator|!=
name|docid2
argument_list|)
expr_stmt|;
name|docid2
operator|=
name|newDocid2
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:2"
argument_list|)
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='300.0']"
argument_list|,
literal|"//result/doc[1]/str[@name='title_s'][.='new second']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|version2
operator|+
literal|"']"
argument_list|)
expr_stmt|;
comment|// Check if docvalue "inc" update works for a newly created document, which is not yet committed
comment|// Case1: docvalue was supplied during add of new document
name|long
name|version4
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"4"
argument_list|,
literal|"title_s"
argument_list|,
literal|"fourth"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
literal|"400"
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
decl_stmt|;
name|version4
operator|=
name|addAndAssertVersion
argument_list|(
name|version4
argument_list|,
literal|"id"
argument_list|,
literal|"4"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:4"
argument_list|)
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='401.0']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|version4
operator|+
literal|"']"
argument_list|)
expr_stmt|;
comment|// Check if docvalue "inc" update works for a newly created document, which is not yet committed
comment|// Case2: docvalue was not supplied during add of new document, should assume default
name|long
name|version5
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"5"
argument_list|,
literal|"title_s"
argument_list|,
literal|"fifth"
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
decl_stmt|;
name|version5
operator|=
name|addAndAssertVersion
argument_list|(
name|version5
argument_list|,
literal|"id"
argument_list|,
literal|"5"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:5"
argument_list|)
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='1.0']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|version5
operator|+
literal|"']"
argument_list|)
expr_stmt|;
comment|// Check if docvalue "set" update works for a newly created document, which is not yet committed
name|long
name|version6
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"6"
argument_list|,
literal|"title_s"
argument_list|,
literal|"sixth"
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
decl_stmt|;
name|version6
operator|=
name|addAndAssertVersion
argument_list|(
name|version6
argument_list|,
literal|"id"
argument_list|,
literal|"6"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|600
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:6"
argument_list|)
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='600.0']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|version6
operator|+
literal|"']"
argument_list|)
expr_stmt|;
comment|// Check optimistic concurrency works
name|long
name|v20
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"20"
argument_list|,
literal|"title_s"
argument_list|,
literal|"first"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
literal|100
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
decl_stmt|;
name|SolrException
name|exception
init|=
name|expectThrows
argument_list|(
name|SolrException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"20"
argument_list|,
literal|"_version_"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|exception
operator|.
name|toString
argument_list|()
argument_list|,
name|SolrException
operator|.
name|ErrorCode
operator|.
name|CONFLICT
operator|.
name|code
argument_list|,
name|exception
operator|.
name|code
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|exception
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"expected=-1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|exception
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"actual="
operator|+
name|v20
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|oldV20
init|=
name|v20
decl_stmt|;
name|v20
operator|=
name|addAndAssertVersion
argument_list|(
name|v20
argument_list|,
literal|"id"
argument_list|,
literal|"20"
argument_list|,
literal|"_version_"
argument_list|,
name|v20
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|exception
operator|=
name|expectThrows
argument_list|(
name|SolrException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"20"
argument_list|,
literal|"_version_"
argument_list|,
name|oldV20
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|exception
operator|.
name|toString
argument_list|()
argument_list|,
name|SolrException
operator|.
name|ErrorCode
operator|.
name|CONFLICT
operator|.
name|code
argument_list|,
name|exception
operator|.
name|code
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|exception
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"expected="
operator|+
name|oldV20
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|exception
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"actual="
operator|+
name|v20
argument_list|)
argument_list|)
expr_stmt|;
name|v20
operator|=
name|addAndAssertVersion
argument_list|(
name|v20
argument_list|,
literal|"id"
argument_list|,
literal|"20"
argument_list|,
literal|"_version_"
argument_list|,
name|v20
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// RTG before a commit
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"id"
argument_list|,
literal|"20"
argument_list|,
literal|"fl"
argument_list|,
literal|"id,inplace_updatable_float,_version_"
argument_list|)
argument_list|,
literal|"=={'doc':{'id':'20', 'inplace_updatable_float':"
operator|+
literal|102.0
operator|+
literal|",'_version_':"
operator|+
name|v20
operator|+
literal|"}}"
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:20"
argument_list|)
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='102.0']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|v20
operator|+
literal|"']"
argument_list|)
expr_stmt|;
comment|// Check if updated DVs can be used for search
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"inplace_updatable_float:102"
argument_list|)
argument_list|,
literal|"//result/doc[1]/str[@name='id'][.='20']"
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='102.0']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|v20
operator|+
literal|"']"
argument_list|)
expr_stmt|;
comment|// Check if updated DVs can be used for sorting
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"inplace_updatable_float asc"
argument_list|)
argument_list|,
literal|"//result/doc[4]/str[@name='id'][.='1']"
argument_list|,
literal|"//result/doc[4]/float[@name='inplace_updatable_float'][.='204.0']"
argument_list|,
literal|"//result/doc[5]/str[@name='id'][.='2']"
argument_list|,
literal|"//result/doc[5]/float[@name='inplace_updatable_float'][.='300.0']"
argument_list|,
literal|"//result/doc[3]/str[@name='id'][.='3']"
argument_list|,
literal|"//result/doc[3]/float[@name='inplace_updatable_float'][.='103.0']"
argument_list|,
literal|"//result/doc[6]/str[@name='id'][.='4']"
argument_list|,
literal|"//result/doc[6]/float[@name='inplace_updatable_float'][.='401.0']"
argument_list|,
literal|"//result/doc[1]/str[@name='id'][.='5']"
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='1.0']"
argument_list|,
literal|"//result/doc[7]/str[@name='id'][.='6']"
argument_list|,
literal|"//result/doc[7]/float[@name='inplace_updatable_float'][.='600.0']"
argument_list|,
literal|"//result/doc[2]/str[@name='id'][.='20']"
argument_list|,
literal|"//result/doc[2]/float[@name='inplace_updatable_float'][.='102.0']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testUpdateTwoDifferentFields
specifier|public
name|void
name|testUpdateTwoDifferentFields
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|version1
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"title_s"
argument_list|,
literal|"first"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
literal|42
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"//*[@numFound='1']"
argument_list|)
expr_stmt|;
name|int
name|docid1
init|=
name|getDocId
argument_list|(
literal|"1"
argument_list|)
decl_stmt|;
comment|// Check docValues were "set"
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|200
argument_list|)
argument_list|)
expr_stmt|;
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_int"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"id asc"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,[docid]"
argument_list|)
argument_list|,
literal|"//*[@numFound='1']"
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='200.0']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|version1
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[1]/int[@name='[docid]'][.='"
operator|+
name|docid1
operator|+
literal|"']"
argument_list|)
expr_stmt|;
comment|// two different update commands, updating each of the fields separately
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_int"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// same update command, updating both the fields together
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_int"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"id asc"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,[docid]"
argument_list|)
argument_list|,
literal|"//*[@numFound='1']"
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='202.0']"
argument_list|,
literal|"//result/doc[1]/int[@name='inplace_updatable_int'][.='12']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|version1
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[1]/int[@name='[docid]'][.='"
operator|+
name|docid1
operator|+
literal|"']"
argument_list|)
expr_stmt|;
block|}
comment|// RTG
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"fl"
argument_list|,
literal|"id,inplace_updatable_float,inplace_updatable_int"
argument_list|)
argument_list|,
literal|"=={'doc':{'id':'1', 'inplace_updatable_float':"
operator|+
literal|202.0
operator|+
literal|",'inplace_updatable_int':"
operator|+
literal|12
operator|+
literal|"}}"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDVUpdatesWithDBQofUpdatedValue
specifier|public
name|void
name|testDVUpdatesWithDBQofUpdatedValue
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|version1
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"title_s"
argument_list|,
literal|"first"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
literal|"0"
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
comment|// in-place update
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|100
argument_list|)
argument_list|,
literal|"_version_"
argument_list|,
name|version1
argument_list|)
expr_stmt|;
comment|// DBQ where q=inplace_updatable_float:100
name|assertU
argument_list|(
name|delQ
argument_list|(
literal|"inplace_updatable_float:100"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"//*[@numFound='0']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDVUpdatesWithDelete
specifier|public
name|void
name|testDVUpdatesWithDelete
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|version1
init|=
literal|0
decl_stmt|;
for|for
control|(
name|boolean
name|postAddCommit
range|:
name|Arrays
operator|.
name|asList
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
control|)
block|{
for|for
control|(
name|boolean
name|delById
range|:
name|Arrays
operator|.
name|asList
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
control|)
block|{
for|for
control|(
name|boolean
name|postDelCommit
range|:
name|Arrays
operator|.
name|asList
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
control|)
block|{
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"title_s"
argument_list|,
literal|"first"
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|postAddCommit
condition|)
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|delById
condition|?
name|delI
argument_list|(
literal|"1"
argument_list|)
else|:
name|delQ
argument_list|(
literal|"id:1"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|postDelCommit
condition|)
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|version1
operator|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|200
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
expr_stmt|;
comment|// assert current doc#1 doesn't have old value of "title_s"
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"title_s:first"
argument_list|,
literal|"sort"
argument_list|,
literal|"id asc"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,[docid]"
argument_list|)
argument_list|,
literal|"//*[@numFound='0']"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Update to recently deleted (or non-existent) document with a "set" on updatable
comment|// field should succeed, since it is executed internally as a full update
comment|// because AUDM.doInPlaceUpdateMerge() returns false
name|assertU
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
name|delI
argument_list|(
literal|"1"
argument_list|)
else|:
name|delQ
argument_list|(
literal|"id:1"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|200
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1"
argument_list|,
literal|"sort"
argument_list|,
literal|"id asc"
argument_list|,
literal|"fl"
argument_list|,
literal|"*"
argument_list|)
argument_list|,
literal|"//*[@numFound='1']"
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='200.0']"
argument_list|)
expr_stmt|;
comment|// Another "set" on the same field should be an in-place update
name|int
name|docid1
init|=
name|getDocId
argument_list|(
literal|"1"
argument_list|)
decl_stmt|;
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|300
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,[docid]"
argument_list|)
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='300.0']"
argument_list|,
literal|"//result/doc[1]/int[@name='[docid]'][.='"
operator|+
name|docid1
operator|+
literal|"']"
argument_list|)
expr_stmt|;
block|}
DECL|method|addAndAssertVersion
specifier|public
specifier|static
name|long
name|addAndAssertVersion
parameter_list|(
name|long
name|expectedCurrentVersion
parameter_list|,
name|Object
modifier|...
name|fields
parameter_list|)
throws|throws
name|Exception
block|{
assert|assert
literal|0
operator|<
name|expectedCurrentVersion
assert|;
name|long
name|currentVersion
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
name|fields
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|currentVersion
operator|>
name|expectedCurrentVersion
argument_list|)
expr_stmt|;
return|return
name|currentVersion
return|;
block|}
comment|/**    * Helper method to search for the specified (uniqueKey field) id using<code>fl=[docid]</code>     * and return the internal lucene docid.    */
DECL|method|getDocId
specifier|private
name|int
name|getDocId
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|NumberFormatException
throws|,
name|Exception
block|{
name|SolrDocumentList
name|results
init|=
name|client
operator|.
name|query
argument_list|(
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"id:"
operator|+
name|id
argument_list|,
literal|"fl"
argument_list|,
literal|"[docid]"
argument_list|)
argument_list|)
operator|.
name|getResults
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Object
name|docid
init|=
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldValue
argument_list|(
literal|"[docid]"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|docid
operator|instanceof
name|Integer
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Integer
operator|)
name|docid
operator|)
return|;
block|}
annotation|@
name|Test
DECL|method|testUpdateOfNonExistentDVsShouldNotFail
specifier|public
name|void
name|testUpdateOfNonExistentDVsShouldNotFail
parameter_list|()
throws|throws
name|Exception
block|{
comment|// schema sanity check: assert that the nonexistent_field_i_dvo doesn't exist already
name|FieldInfo
name|fi
decl_stmt|;
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|holder
init|=
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
try|try
block|{
name|fi
operator|=
name|holder
operator|.
name|get
argument_list|()
operator|.
name|getSlowAtomicReader
argument_list|()
operator|.
name|getFieldInfos
argument_list|()
operator|.
name|fieldInfo
argument_list|(
literal|"nonexistent_field_i_dvo"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|holder
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
name|assertNull
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|// Partial update
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"nonexistent_field_i_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|"42"
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"nonexistent_field_i_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"nonexistent_field_i_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"//*[@numFound='2']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"nonexistent_field_i_dvo:42"
argument_list|)
argument_list|,
literal|"//*[@numFound='1']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"nonexistent_field_i_dvo:2"
argument_list|)
argument_list|,
literal|"//*[@numFound='1']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testOnlyPartialUpdatesBetweenCommits
specifier|public
name|void
name|testOnlyPartialUpdatesBetweenCommits
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Full updates
name|long
name|version1
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"title_s"
argument_list|,
literal|"first"
argument_list|,
literal|"val1_i_dvo"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|"1"
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|version2
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"title_s"
argument_list|,
literal|"second"
argument_list|,
literal|"val1_i_dvo"
argument_list|,
literal|"2"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|"2"
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|version3
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"title_s"
argument_list|,
literal|"third"
argument_list|,
literal|"val1_i_dvo"
argument_list|,
literal|"3"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|"3"
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,[docid]"
argument_list|)
argument_list|,
literal|"//*[@numFound='3']"
argument_list|)
expr_stmt|;
name|int
name|docid1
init|=
name|getDocId
argument_list|(
literal|"1"
argument_list|)
decl_stmt|;
name|int
name|docid2
init|=
name|getDocId
argument_list|(
literal|"2"
argument_list|)
decl_stmt|;
name|int
name|docid3
init|=
name|getDocId
argument_list|(
literal|"3"
argument_list|)
decl_stmt|;
name|int
name|numPartialUpdates
init|=
literal|1
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|5000
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numPartialUpdates
condition|;
name|i
operator|++
control|)
block|{
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val1_i_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|version2
operator|=
name|addAndAssertVersion
argument_list|(
name|version2
argument_list|,
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"val1_i_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|version3
operator|=
name|addAndAssertVersion
argument_list|(
name|version3
argument_list|,
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"val1_i_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|version2
operator|=
name|addAndAssertVersion
argument_list|(
name|version2
argument_list|,
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|version3
operator|=
name|addAndAssertVersion
argument_list|(
name|version3
argument_list|,
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"true"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"id asc"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,[docid]"
argument_list|)
argument_list|,
literal|"//*[@numFound='3']"
argument_list|,
literal|"//result/doc[1]/int[@name='val1_i_dvo'][.='"
operator|+
operator|(
name|numPartialUpdates
operator|-
literal|1
operator|)
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[2]/int[@name='val1_i_dvo'][.='"
operator|+
operator|(
name|numPartialUpdates
operator|+
literal|2
operator|)
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[3]/int[@name='val1_i_dvo'][.='"
operator|+
operator|(
name|numPartialUpdates
operator|-
literal|1
operator|)
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[1]/long[@name='val2_l_dvo'][.='"
operator|+
operator|(
name|numPartialUpdates
operator|-
literal|1
operator|)
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[2]/long[@name='val2_l_dvo'][.='"
operator|+
operator|(
name|numPartialUpdates
operator|+
literal|2
operator|)
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[3]/long[@name='val2_l_dvo'][.='"
operator|+
operator|(
name|numPartialUpdates
operator|-
literal|1
operator|)
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[1]/int[@name='[docid]'][.='"
operator|+
name|docid1
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[2]/int[@name='[docid]'][.='"
operator|+
name|docid2
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[3]/int[@name='[docid]'][.='"
operator|+
name|docid3
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|version1
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[2]/long[@name='_version_'][.='"
operator|+
name|version2
operator|+
literal|"']"
argument_list|,
literal|"//result/doc[3]/long[@name='_version_'][.='"
operator|+
name|version3
operator|+
literal|"']"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Useful to store the state of an expected document into an in-memory model    * representing the index.    */
DECL|class|DocInfo
specifier|private
specifier|static
class|class
name|DocInfo
block|{
DECL|field|version
specifier|public
specifier|final
name|long
name|version
decl_stmt|;
DECL|field|value
specifier|public
specifier|final
name|Long
name|value
decl_stmt|;
DECL|method|DocInfo
specifier|public
name|DocInfo
parameter_list|(
name|long
name|version
parameter_list|,
name|Long
name|val
parameter_list|)
block|{
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|val
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"["
operator|+
name|version
operator|+
literal|", "
operator|+
name|value
operator|+
literal|"]"
return|;
block|}
block|}
comment|/** @see #checkReplay */
annotation|@
name|Test
DECL|method|testReplay_AfterInitialAddMixOfIncAndSet
specifier|public
name|void
name|testReplay_AfterInitialAddMixOfIncAndSet
parameter_list|()
throws|throws
name|Exception
block|{
name|checkReplay
argument_list|(
literal|"val2_l_dvo"
argument_list|,
comment|//
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|3000000000L
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|5
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|2000000000L
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|2000000002L
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|3000000000L
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|7
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|7000000000L
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|11
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|2000000000L
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|3000000000L
argument_list|)
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|)
expr_stmt|;
block|}
comment|/** @see #checkReplay */
annotation|@
name|Test
DECL|method|testReplay_AfterInitialAddMixOfIncAndSetAndFullUpdates
specifier|public
name|void
name|testReplay_AfterInitialAddMixOfIncAndSetAndFullUpdates
parameter_list|()
throws|throws
name|Exception
block|{
name|checkReplay
argument_list|(
literal|"val2_l_dvo"
argument_list|,
comment|//
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|3000000000L
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|3000000003L
argument_list|)
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|3000000008L
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|2000000000L
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|3000000000L
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|3000000015L
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|7000000000L
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|3000000026L
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|2000000000L
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|3000000000L
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|)
expr_stmt|;
block|}
comment|/** @see #checkReplay */
annotation|@
name|Test
DECL|method|testReplay_AllUpdatesAfterInitialAddAreInc
specifier|public
name|void
name|testReplay_AllUpdatesAfterInitialAddAreInc
parameter_list|()
throws|throws
name|Exception
block|{
name|checkReplay
argument_list|(
literal|"val2_l_dvo"
argument_list|,
comment|//
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|3000000000L
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|5
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|2000000000L
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|3000000000L
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|7
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|7000000000L
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|11
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|2000000000L
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|3000000000L
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|)
expr_stmt|;
block|}
comment|/** @see #checkReplay */
annotation|@
name|Test
DECL|method|testReplay_AllUpdatesAfterInitialAddAreSets
specifier|public
name|void
name|testReplay_AllUpdatesAfterInitialAddAreSets
parameter_list|()
throws|throws
name|Exception
block|{
name|checkReplay
argument_list|(
literal|"val2_l_dvo"
argument_list|,
comment|//
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|3000000000L
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|3000000003L
argument_list|)
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|3000000008L
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|2000000000L
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|2000000002L
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|3000000000L
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|3000000015L
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|7000000000L
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|3000000026L
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
literal|2000000000L
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"val2_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|3000000000L
argument_list|)
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|)
expr_stmt|;
block|}
comment|/** @see #checkReplay */
annotation|@
name|Test
DECL|method|testReplay_MixOfInplaceAndNonInPlaceAtomicUpdates
specifier|public
name|void
name|testReplay_MixOfInplaceAndNonInPlaceAtomicUpdates
parameter_list|()
throws|throws
name|Exception
block|{
name|checkReplay
argument_list|(
literal|"inplace_l_dvo"
argument_list|,
comment|//
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"inplace_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
operator|-
literal|13
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"inplace_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|19
argument_list|)
argument_list|,
literal|"regular_l"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
operator|-
literal|17
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"regular_l"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
operator|-
literal|19
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"inplace_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
operator|-
literal|11
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"inplace_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|28
argument_list|)
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"inplace_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|45
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"inplace_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|72
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"regular_l"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
operator|-
literal|55
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"inplace_l_dvo"
argument_list|,
operator|-
literal|48
argument_list|,
literal|"regular_l"
argument_list|,
literal|159
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"inplace_l_dvo"
argument_list|,
literal|52
argument_list|,
literal|"regular_l"
argument_list|,
literal|895
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"inplace_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|19
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"inplace_l_dvo"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
operator|-
literal|264
argument_list|)
argument_list|,
literal|"regular_l"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
operator|-
literal|207
argument_list|)
argument_list|)
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"inplace_l_dvo"
argument_list|,
operator|-
literal|762
argument_list|,
literal|"regular_l"
argument_list|,
literal|272
argument_list|)
argument_list|,
name|SOFTCOMMIT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testReplay_SetOverriddenWithNoValueThenInc
specifier|public
name|void
name|testReplay_SetOverriddenWithNoValueThenInc
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|inplaceField
init|=
literal|"inplace_l_dvo"
decl_stmt|;
name|checkReplay
argument_list|(
name|inplaceField
argument_list|,
comment|//
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
name|inplaceField
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|555L
argument_list|)
argument_list|)
argument_list|,
name|SOFTCOMMIT
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"regular_l"
argument_list|,
literal|666L
argument_list|)
argument_list|,
comment|// NOTE: no inplaceField, regular add w/overwrite
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
name|inplaceField
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
operator|-
literal|77
argument_list|)
argument_list|)
argument_list|,
name|HARDCOMMIT
argument_list|)
expr_stmt|;
block|}
comment|/**     * Simple enum for randomizing a type of update.    * Each enum value has an associated probability, and the class has built in sanity checks     * that the total is 100%    *     * @see RandomUpdate#pick    * @see #checkRandomReplay    */
DECL|enum|RandomUpdate
specifier|private
specifier|static
enum|enum
name|RandomUpdate
block|{
DECL|enum constant|HARD_COMMIT
name|HARD_COMMIT
argument_list|(
literal|5
argument_list|)
block|,
DECL|enum constant|SOFT_COMMIT
name|SOFT_COMMIT
argument_list|(
literal|5
argument_list|)
block|,
comment|/** doc w/o the inplaceField, atomic update on some other (non-inplace) field */
DECL|enum constant|ATOMIC_NOT_INPLACE
name|ATOMIC_NOT_INPLACE
argument_list|(
literal|5
argument_list|)
block|,
comment|/** atomic update of a doc w/ inc on both inplaceField *AND* non-inplace field */
DECL|enum constant|ATOMIC_INPLACE_AND_NOT_INPLACE
name|ATOMIC_INPLACE_AND_NOT_INPLACE
argument_list|(
literal|10
argument_list|)
block|,
comment|/** atomic update of a doc w/ set inplaceField */
DECL|enum constant|ATOMIC_INPLACE_SET
name|ATOMIC_INPLACE_SET
argument_list|(
literal|25
argument_list|)
block|,
comment|/** atomic update of a doc w/ inc inplaceField */
DECL|enum constant|ATOMIC_INPLACE_INC
name|ATOMIC_INPLACE_INC
argument_list|(
literal|25
argument_list|)
block|,
comment|/** doc w/o the inplaceField, normal add */
DECL|enum constant|ADD_NO_INPLACE_VALUE
name|ADD_NO_INPLACE_VALUE
argument_list|(
literal|5
argument_list|)
block|,
comment|/** a non atomic update of a doc w/ new inplaceField value */
DECL|enum constant|ADD_INPLACE_VALUE
name|ADD_INPLACE_VALUE
argument_list|(
literal|20
argument_list|)
block|;
DECL|method|RandomUpdate
specifier|private
name|RandomUpdate
parameter_list|(
name|int
name|odds
parameter_list|)
block|{
name|this
operator|.
name|odds
operator|=
name|odds
expr_stmt|;
block|}
DECL|field|odds
specifier|public
specifier|final
name|int
name|odds
decl_stmt|;
static|static
block|{
comment|// sanity check odds add up to 100%
name|int
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RandomUpdate
name|candidate
range|:
name|RandomUpdate
operator|.
name|values
argument_list|()
control|)
block|{
name|total
operator|+=
name|candidate
operator|.
name|odds
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"total odds doesn't equal 100"
argument_list|,
literal|100
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
comment|/** pick a random type of RandomUpdate */
DECL|method|pick
specifier|public
specifier|static
specifier|final
name|RandomUpdate
name|pick
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
specifier|final
name|int
name|target
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|int
name|cumulative_odds
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RandomUpdate
name|candidate
range|:
name|RandomUpdate
operator|.
name|values
argument_list|()
control|)
block|{
name|cumulative_odds
operator|+=
name|candidate
operator|.
name|odds
expr_stmt|;
if|if
condition|(
name|target
operator|<=
name|cumulative_odds
condition|)
block|{
return|return
name|candidate
return|;
block|}
block|}
name|fail
argument_list|(
literal|"how did we not find a candidate? target="
operator|+
name|target
operator|+
literal|", cumulative_odds="
operator|+
name|cumulative_odds
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// compiler mandated return
block|}
block|}
comment|/** @see #checkRandomReplay */
annotation|@
name|Test
DECL|method|testReplay_Random_ManyDocsManyUpdates
specifier|public
name|void
name|testReplay_Random_ManyDocsManyUpdates
parameter_list|()
throws|throws
name|Exception
block|{
comment|// build up a random list of updates
specifier|final
name|int
name|maxDocId
init|=
name|atLeast
argument_list|(
literal|50
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numUpdates
init|=
name|maxDocId
operator|*
literal|3
decl_stmt|;
name|checkRandomReplay
argument_list|(
name|maxDocId
argument_list|,
name|numUpdates
argument_list|)
expr_stmt|;
block|}
comment|/** @see #checkRandomReplay */
annotation|@
name|Test
DECL|method|testReplay_Random_FewDocsManyUpdates
specifier|public
name|void
name|testReplay_Random_FewDocsManyUpdates
parameter_list|()
throws|throws
name|Exception
block|{
comment|// build up a random list of updates
specifier|final
name|int
name|maxDocId
init|=
name|atLeast
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numUpdates
init|=
name|maxDocId
operator|*
literal|50
decl_stmt|;
name|checkRandomReplay
argument_list|(
name|maxDocId
argument_list|,
name|numUpdates
argument_list|)
expr_stmt|;
block|}
comment|/** @see #checkRandomReplay */
annotation|@
name|Test
DECL|method|testReplay_Random_FewDocsManyShortSequences
specifier|public
name|void
name|testReplay_Random_FewDocsManyShortSequences
parameter_list|()
throws|throws
name|Exception
block|{
comment|// build up a random list of updates
specifier|final
name|int
name|numIters
init|=
name|atLeast
argument_list|(
literal|50
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIters
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|maxDocId
init|=
name|atLeast
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numUpdates
init|=
name|maxDocId
operator|*
literal|5
decl_stmt|;
name|checkRandomReplay
argument_list|(
name|maxDocId
argument_list|,
name|numUpdates
argument_list|)
expr_stmt|;
name|deleteAllAndCommit
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**     * @see #checkReplay     * @see RandomUpdate    */
DECL|method|checkRandomReplay
specifier|public
name|void
name|checkRandomReplay
parameter_list|(
specifier|final
name|int
name|maxDocId
parameter_list|,
specifier|final
name|int
name|numCmds
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|String
name|not_inplaceField
init|=
literal|"regular_l"
decl_stmt|;
specifier|final
name|String
name|inplaceField
init|=
literal|"inplace_l_dvo"
decl_stmt|;
specifier|final
name|Object
index|[]
name|cmds
init|=
operator|new
name|Object
index|[
name|numCmds
index|]
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|numCmds
condition|;
name|iter
operator|++
control|)
block|{
specifier|final
name|int
name|id
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
name|maxDocId
argument_list|)
decl_stmt|;
specifier|final
name|RandomUpdate
name|update
init|=
name|RandomUpdate
operator|.
name|pick
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|update
condition|)
block|{
case|case
name|HARD_COMMIT
case|:
name|cmds
index|[
name|iter
index|]
operator|=
name|HARDCOMMIT
expr_stmt|;
break|break;
case|case
name|SOFT_COMMIT
case|:
name|cmds
index|[
name|iter
index|]
operator|=
name|SOFTCOMMIT
expr_stmt|;
break|break;
case|case
name|ATOMIC_NOT_INPLACE
case|:
comment|// atomic update on non_inplaceField, w/o any value specified for inplaceField
name|cmds
index|[
name|iter
index|]
operator|=
name|sdoc
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
name|not_inplaceField
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATOMIC_INPLACE_AND_NOT_INPLACE
case|:
comment|// atomic update of a doc w/ inc on both inplaceField and not_inplaceField
name|cmds
index|[
name|iter
index|]
operator|=
name|sdoc
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
name|inplaceField
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|,
name|not_inplaceField
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATOMIC_INPLACE_SET
case|:
comment|// atomic update of a doc w/ set inplaceField
name|cmds
index|[
name|iter
index|]
operator|=
name|sdoc
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
name|inplaceField
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATOMIC_INPLACE_INC
case|:
comment|// atomic update of a doc w/ inc inplaceField
name|cmds
index|[
name|iter
index|]
operator|=
name|sdoc
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
name|inplaceField
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD_NO_INPLACE_VALUE
case|:
comment|// regular add of doc w/o the inplaceField, but does include non_inplaceField
name|cmds
index|[
name|iter
index|]
operator|=
name|sdoc
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
name|not_inplaceField
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD_INPLACE_VALUE
case|:
comment|// a non atomic update of a doc w/ new inplaceField value
name|cmds
index|[
name|iter
index|]
operator|=
name|sdoc
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
name|inplaceField
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|,
name|not_inplaceField
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fail
argument_list|(
literal|"WTF is this? ... "
operator|+
name|update
argument_list|)
expr_stmt|;
block|}
name|assertNotNull
argument_list|(
name|cmds
index|[
name|iter
index|]
argument_list|)
expr_stmt|;
comment|// sanity check switch
block|}
name|checkReplay
argument_list|(
name|inplaceField
argument_list|,
name|cmds
argument_list|)
expr_stmt|;
block|}
comment|/** sentinal object for {@link #checkReplay} */
DECL|field|SOFTCOMMIT
specifier|public
name|Object
name|SOFTCOMMIT
init|=
operator|new
name|Object
argument_list|()
block|{
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"SOFTCOMMIT"
return|;
block|}
block|}
decl_stmt|;
comment|/** sentinal object for {@link #checkReplay} */
DECL|field|HARDCOMMIT
specifier|public
name|Object
name|HARDCOMMIT
init|=
operator|new
name|Object
argument_list|()
block|{
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"HARDCOMMIT"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Executes a sequence of commands against Solr, while tracking the expected value of a specified     *<code>valField</code> Long field (presumably that only uses docvalues) against an in memory model     * maintained in parallel (for the purpose of testing the correctness of in-place updates..    *    *<p>    * A few restrictions are placed on the {@link SolrInputDocument}s that can be included when using     * this method, in order to keep the in-memory model management simple:    *</p>    *<ul>    *<li><code>id</code> must be uniqueKey field</li>    *<li><code>id</code> may have any FieldType, but all values must be parsable as Integers</li>    *<li><code>valField</code> must be a single valued field</li>    *<li>All values in the<code>valField</code> must either be {@link Number}s, or Maps containing     *      atomic updates ("inc" or "set") where the atomic value is a {@link Number}</li>    *</ul>    *     * @param valField the field to model    * @param commands A sequence of Commands which can either be SolrInputDocuments     *                 (regular or containing atomic update Maps)    *                 or one of the {@link TestInPlaceUpdatesStandalone#HARDCOMMIT} or {@link TestInPlaceUpdatesStandalone#SOFTCOMMIT} sentinal objects.    */
DECL|method|checkReplay
specifier|public
name|void
name|checkReplay
parameter_list|(
specifier|final
name|String
name|valField
parameter_list|,
name|Object
modifier|...
name|commands
parameter_list|)
throws|throws
name|Exception
block|{
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|DocInfo
argument_list|>
name|model
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|DocInfo
argument_list|>
name|committedModel
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// by default, we only check the committed model after a commit
comment|// of if the number of total commands is relatively small.
comment|//
comment|// (in theory, there's no reason to check the committed model unless we know there's been a commit
comment|// but for smaller tests the overhead of doing so is tiny, so we might as well)
comment|//
comment|// if some test seed fails, and you want to force the committed model to be checked
comment|// after every command, just temporaribly force this variable to true...
name|boolean
name|checkCommittedModel
init|=
operator|(
name|commands
operator|.
name|length
operator|<
literal|50
operator|)
decl_stmt|;
for|for
control|(
name|Object
name|cmd
range|:
name|commands
control|)
block|{
if|if
condition|(
name|cmd
operator|==
name|SOFTCOMMIT
condition|)
block|{
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"true"
argument_list|)
argument_list|)
expr_stmt|;
name|committedModel
operator|=
operator|new
name|LinkedHashMap
argument_list|(
name|model
argument_list|)
expr_stmt|;
name|checkCommittedModel
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|HARDCOMMIT
condition|)
block|{
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|committedModel
operator|=
operator|new
name|LinkedHashMap
argument_list|(
name|model
argument_list|)
expr_stmt|;
name|checkCommittedModel
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|assertNotNull
argument_list|(
literal|"null command in checkReplay"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"cmd is neither sentinal (HARD|SOFT)COMMIT object, nor Solr doc: "
operator|+
name|cmd
operator|.
name|getClass
argument_list|()
argument_list|,
name|cmd
operator|instanceof
name|SolrInputDocument
argument_list|)
expr_stmt|;
specifier|final
name|SolrInputDocument
name|sdoc
init|=
operator|(
name|SolrInputDocument
operator|)
name|cmd
decl_stmt|;
specifier|final
name|int
name|id
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|sdoc
operator|.
name|getFieldValue
argument_list|(
literal|"id"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DocInfo
name|previousInfo
init|=
name|model
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
specifier|final
name|Long
name|previousValue
init|=
operator|(
literal|null
operator|==
name|previousInfo
operator|)
condition|?
literal|null
else|:
name|previousInfo
operator|.
name|value
decl_stmt|;
specifier|final
name|long
name|version
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|val
init|=
name|sdoc
operator|.
name|getFieldValue
argument_list|(
name|valField
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|instanceof
name|Map
condition|)
block|{
comment|// atomic update of the field we're modeling
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|atomicUpdate
init|=
operator|(
name|Map
operator|)
name|val
decl_stmt|;
name|assertEquals
argument_list|(
name|sdoc
operator|.
name|toString
argument_list|()
argument_list|,
literal|1
argument_list|,
name|atomicUpdate
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomicUpdate
operator|.
name|containsKey
argument_list|(
literal|"inc"
argument_list|)
condition|)
block|{
comment|// Solr treats inc on a non-existing doc (or doc w/o existing value) as if existing value is 0
specifier|final
name|long
name|base
init|=
operator|(
literal|null
operator|==
name|previousValue
operator|)
condition|?
literal|0L
else|:
name|previousValue
decl_stmt|;
name|model
operator|.
name|put
argument_list|(
name|id
argument_list|,
operator|new
name|DocInfo
argument_list|(
name|version
argument_list|,
name|base
operator|+
operator|(
operator|(
name|Number
operator|)
name|atomicUpdate
operator|.
name|get
argument_list|(
literal|"inc"
argument_list|)
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atomicUpdate
operator|.
name|containsKey
argument_list|(
literal|"set"
argument_list|)
condition|)
block|{
name|model
operator|.
name|put
argument_list|(
name|id
argument_list|,
operator|new
name|DocInfo
argument_list|(
name|version
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|atomicUpdate
operator|.
name|get
argument_list|(
literal|"set"
argument_list|)
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"wtf update is this? ... "
operator|+
name|sdoc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|null
operator|==
name|val
condition|)
block|{
comment|// the field we are modeling is not mentioned in this update, It's either...
comment|//
comment|// a) a regular update of some other fields (our model should have a null value)
comment|// b) an atomic update of some other field (keep existing value in model)
comment|//
comment|// for now, assume it's atomic and we're going to keep our existing value...
name|Long
name|newValue
init|=
operator|(
literal|null
operator|==
name|previousInfo
operator|)
condition|?
literal|null
else|:
name|previousInfo
operator|.
name|value
decl_stmt|;
for|for
control|(
name|SolrInputField
name|field
range|:
name|sdoc
control|)
block|{
if|if
condition|(
operator|!
operator|(
literal|"id"
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
operator|||
operator|(
name|field
operator|.
name|getValue
argument_list|()
operator|instanceof
name|Map
operator|)
operator|)
condition|)
block|{
comment|// not an atomic update, newValue in model should be null
name|newValue
operator|=
literal|null
expr_stmt|;
break|break;
block|}
block|}
name|model
operator|.
name|put
argument_list|(
name|id
argument_list|,
operator|new
name|DocInfo
argument_list|(
name|version
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// regular replacement of the value in the field we're modeling
name|assertTrue
argument_list|(
literal|"Model field value is not a Number: "
operator|+
name|val
operator|.
name|getClass
argument_list|()
argument_list|,
name|val
operator|instanceof
name|Number
argument_list|)
expr_stmt|;
name|model
operator|.
name|put
argument_list|(
name|id
argument_list|,
operator|new
name|DocInfo
argument_list|(
name|version
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|val
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// after every op, check the model(s)
comment|// RTG to check the values for every id against the model
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|DocInfo
argument_list|>
name|entry
range|:
name|model
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|Long
name|expected
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|value
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|client
operator|.
name|getById
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
operator|.
name|getFirstValue
argument_list|(
name|valField
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// search to check the values for every id in the committed model
if|if
condition|(
name|checkCommittedModel
condition|)
block|{
specifier|final
name|int
name|numCommitedDocs
init|=
name|committedModel
operator|.
name|size
argument_list|()
decl_stmt|;
name|String
index|[]
name|xpaths
init|=
operator|new
name|String
index|[
literal|1
operator|+
name|numCommitedDocs
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|DocInfo
argument_list|>
name|entry
range|:
name|committedModel
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Integer
name|id
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Long
name|expected
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|value
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|expected
condition|)
block|{
name|xpaths
index|[
name|i
index|]
operator|=
literal|"//result/doc[./str='"
operator|+
name|id
operator|+
literal|"'][./long='"
operator|+
name|expected
operator|+
literal|"']"
expr_stmt|;
block|}
else|else
block|{
name|xpaths
index|[
name|i
index|]
operator|=
literal|"//result/doc[./str='"
operator|+
name|id
operator|+
literal|"'][not(./long)]"
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|xpaths
index|[
name|i
index|]
operator|=
literal|"//*[@numFound='"
operator|+
name|numCommitedDocs
operator|+
literal|"']"
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"id,"
operator|+
name|valField
argument_list|,
literal|"rows"
argument_list|,
literal|""
operator|+
name|numCommitedDocs
argument_list|)
argument_list|,
name|xpaths
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Test
DECL|method|testMixedInPlaceAndNonInPlaceAtomicUpdates
specifier|public
name|void
name|testMixedInPlaceAndNonInPlaceAtomicUpdates
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrDocument
name|rtgDoc
init|=
literal|null
decl_stmt|;
name|long
name|version1
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
literal|"100"
argument_list|,
literal|"stored_i"
argument_list|,
literal|"100"
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
decl_stmt|;
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|"1"
argument_list|)
argument_list|,
literal|"stored_i"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|rtgDoc
operator|=
name|client
operator|.
name|getById
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|101
argument_list|,
name|rtgDoc
operator|.
name|getFieldValue
argument_list|(
literal|"stored_i"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|101.0f
argument_list|,
name|rtgDoc
operator|.
name|getFieldValue
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|rtgDoc
operator|=
name|client
operator|.
name|getById
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|101
argument_list|,
name|rtgDoc
operator|.
name|getFieldValue
argument_list|(
literal|"stored_i"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|102.0f
argument_list|,
name|rtgDoc
operator|.
name|getFieldValue
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"stored_i"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|rtgDoc
operator|=
name|client
operator|.
name|getById
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|102
argument_list|,
name|rtgDoc
operator|.
name|getFieldValue
argument_list|(
literal|"stored_i"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|102.0f
argument_list|,
name|rtgDoc
operator|.
name|getFieldValue
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"id asc"
argument_list|,
literal|"fl"
argument_list|,
literal|"*"
argument_list|)
argument_list|,
literal|"//*[@numFound='1']"
argument_list|,
literal|"//result/doc[1]/float[@name='inplace_updatable_float'][.='102.0']"
argument_list|,
literal|"//result/doc[1]/int[@name='stored_i'][.='102']"
argument_list|,
literal|"//result/doc[1]/long[@name='_version_'][.='"
operator|+
name|version1
operator|+
literal|"']"
argument_list|)
expr_stmt|;
comment|// recheck RTG after commit
name|rtgDoc
operator|=
name|client
operator|.
name|getById
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|102
argument_list|,
name|rtgDoc
operator|.
name|getFieldValue
argument_list|(
literal|"stored_i"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|102.0f
argument_list|,
name|rtgDoc
operator|.
name|getFieldValue
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * @see #callComputeInPlaceUpdatableFields    * @see AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields     */
annotation|@
name|Test
DECL|method|testComputeInPlaceUpdatableFields
specifier|public
name|void
name|testComputeInPlaceUpdatableFields
parameter_list|()
throws|throws
name|Exception
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|inPlaceUpdatedFields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// these asserts should hold true regardless of type, or wether the field has a default
name|List
argument_list|<
name|String
argument_list|>
name|fieldsToCheck
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"inplace_updatable_float"
argument_list|,
literal|"inplace_updatable_int"
argument_list|,
literal|"inplace_updatable_float_with_default"
argument_list|,
literal|"inplace_updatable_int_with_default"
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|fieldsToCheck
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
comment|// ... and regardless of order checked
for|for
control|(
name|String
name|field
range|:
name|fieldsToCheck
control|)
block|{
comment|// In-place updatable field updated before it exists SHOULD NOT BE in-place updated:
name|inPlaceUpdatedFields
operator|=
name|callComputeInPlaceUpdatableFields
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
name|field
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|field
argument_list|,
name|inPlaceUpdatedFields
operator|.
name|contains
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|// In-place updatable field updated after it exists SHOULD BE in-place updated:
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
name|field
argument_list|,
literal|"0"
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
expr_stmt|;
comment|// setting up the dv
name|inPlaceUpdatedFields
operator|=
name|callComputeInPlaceUpdatableFields
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
name|field
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|field
argument_list|,
name|inPlaceUpdatedFields
operator|.
name|contains
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|inPlaceUpdatedFields
operator|=
name|callComputeInPlaceUpdatableFields
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
name|field
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|field
argument_list|,
name|inPlaceUpdatedFields
operator|.
name|contains
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|altFieldWithDefault
init|=
name|field
operator|.
name|contains
argument_list|(
literal|"float"
argument_list|)
condition|?
literal|"inplace_updatable_int_with_default"
else|:
literal|"inplace_updatable_int_with_default"
decl_stmt|;
comment|// Updating an in-place updatable field (with a default) for the first time.
comment|// DV for it should have been already created when first document was indexed (above),
comment|// since it has a default value
name|inPlaceUpdatedFields
operator|=
name|callComputeInPlaceUpdatableFields
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
name|altFieldWithDefault
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|field
operator|+
literal|" -> "
operator|+
name|altFieldWithDefault
argument_list|,
name|inPlaceUpdatedFields
operator|.
name|contains
argument_list|(
name|altFieldWithDefault
argument_list|)
argument_list|)
expr_stmt|;
name|deleteAllAndCommit
argument_list|()
expr_stmt|;
block|}
comment|// Non in-place updates
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"stored_i"
argument_list|,
literal|"0"
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
expr_stmt|;
comment|// setting up the dv
name|assertTrue
argument_list|(
literal|"stored field updated"
argument_list|,
name|callComputeInPlaceUpdatableFields
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
literal|"stored_i"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"full document update"
argument_list|,
name|callComputeInPlaceUpdatableFields
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
literal|"inplace_updatable_int_with_default"
argument_list|,
literal|"100"
argument_list|)
argument_list|)
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"non existent dynamic dv field updated first time"
argument_list|,
name|callComputeInPlaceUpdatableFields
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
literal|"new_updatable_int_i_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// After adding a full document with the dynamic dv field, in-place update should work
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"new_updatable_int_i_dvo"
argument_list|,
literal|"0"
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
expr_stmt|;
comment|// setting up the dv
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inPlaceUpdatedFields
operator|=
name|callComputeInPlaceUpdatableFields
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
literal|"new_updatable_int_i_dvo"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|inPlaceUpdatedFields
operator|.
name|contains
argument_list|(
literal|"new_updatable_int_i_dvo"
argument_list|)
argument_list|)
expr_stmt|;
comment|// for copy fields, regardless of wether the source& target support inplace updates,
comment|// it won't be inplace if the DVs don't exist yet...
name|assertTrue
argument_list|(
literal|"inplace fields should be empty when doc has no copyfield src values yet"
argument_list|,
name|callComputeInPlaceUpdatableFields
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
literal|"copyfield1_src__both_updatable"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|"copyfield2_src__only_src_updatable"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// now add a doc that *does* have the src field for each copyfield...
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"copyfield1_src__both_updatable"
argument_list|,
operator|-
literal|13
argument_list|,
literal|"copyfield2_src__only_src_updatable"
argument_list|,
operator|-
literal|15
argument_list|)
argument_list|,
name|params
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If a supported dv field has a copyField target which is supported, it should be an in-place update
name|inPlaceUpdatedFields
operator|=
name|callComputeInPlaceUpdatableFields
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
literal|"copyfield1_src__both_updatable"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|inPlaceUpdatedFields
operator|.
name|contains
argument_list|(
literal|"copyfield1_src__both_updatable"
argument_list|)
argument_list|)
expr_stmt|;
comment|// If a supported dv field has a copyField target which is not supported, it should not be an in-place update
name|inPlaceUpdatedFields
operator|=
name|callComputeInPlaceUpdatableFields
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
literal|"copyfield2_src__only_src_updatable"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|inPlaceUpdatedFields
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/**    *  Test the @see {@link AtomicUpdateDocumentMerger#doInPlaceUpdateMerge(AddUpdateCommand,Set<String>)}     *  method is working fine    */
DECL|method|testDoInPlaceUpdateMerge
specifier|public
name|void
name|testDoInPlaceUpdateMerge
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|version1
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"title_s"
argument_list|,
literal|"first"
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|long
name|version2
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"title_s"
argument_list|,
literal|"second"
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|long
name|version3
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"title_s"
argument_list|,
literal|"third"
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"//*[@numFound='3']"
argument_list|)
expr_stmt|;
comment|// Adding a few in-place updates
name|version1
operator|=
name|addAndAssertVersion
argument_list|(
name|version1
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|200
argument_list|)
argument_list|)
expr_stmt|;
comment|// Test the AUDM.doInPlaceUpdateMerge() method is working fine
try|try
init|(
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|()
init|)
block|{
name|AddUpdateCommand
name|cmd
init|=
name|buildAddUpdateCommand
argument_list|(
name|req
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|AtomicUpdateDocumentMerger
name|docMerger
init|=
operator|new
name|AtomicUpdateDocumentMerger
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|docMerger
operator|.
name|doInPlaceUpdateMerge
argument_list|(
name|cmd
argument_list|,
name|AtomicUpdateDocumentMerger
operator|.
name|computeInPlaceUpdatableFields
argument_list|(
name|cmd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|42L
argument_list|,
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
operator|.
name|getFieldValue
argument_list|(
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|42L
argument_list|,
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
operator|.
name|getFieldValue
argument_list|(
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|210f
argument_list|,
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
operator|.
name|getFieldValue
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
comment|// in-place merged doc shouldn't have non-inplace fields from the index/tlog
name|assertFalse
argument_list|(
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
operator|.
name|containsKey
argument_list|(
literal|"title_s"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|version1
argument_list|,
name|cmd
operator|.
name|prevVersion
argument_list|)
expr_stmt|;
block|}
comment|// do a commit, and the same results should be repeated
name|assertU
argument_list|(
name|commit
argument_list|(
literal|"softCommit"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Test the AUDM.doInPlaceUpdateMerge() method is working fine
try|try
init|(
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|()
init|)
block|{
name|AddUpdateCommand
name|cmd
init|=
name|buildAddUpdateCommand
argument_list|(
name|req
argument_list|,
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"_version_"
argument_list|,
literal|42L
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|AtomicUpdateDocumentMerger
name|docMerger
init|=
operator|new
name|AtomicUpdateDocumentMerger
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|docMerger
operator|.
name|doInPlaceUpdateMerge
argument_list|(
name|cmd
argument_list|,
name|AtomicUpdateDocumentMerger
operator|.
name|computeInPlaceUpdatableFields
argument_list|(
name|cmd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|42L
argument_list|,
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
operator|.
name|getFieldValue
argument_list|(
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|42L
argument_list|,
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
operator|.
name|getFieldValue
argument_list|(
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|210f
argument_list|,
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
operator|.
name|getFieldValue
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
comment|// in-place merged doc shouldn't have non-inplace fields from the index/tlog
name|assertFalse
argument_list|(
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
operator|.
name|containsKey
argument_list|(
literal|"title_s"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|version1
argument_list|,
name|cmd
operator|.
name|prevVersion
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Helper method that sets up a req/cmd to run {@link AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields}     * on the specified solr input document.    */
DECL|method|callComputeInPlaceUpdatableFields
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|callComputeInPlaceUpdatableFields
parameter_list|(
specifier|final
name|SolrInputDocument
name|sdoc
parameter_list|)
throws|throws
name|Exception
block|{
try|try
init|(
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|()
init|)
block|{
name|AddUpdateCommand
name|cmd
init|=
operator|new
name|AddUpdateCommand
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|cmd
operator|.
name|solrDoc
operator|=
name|sdoc
expr_stmt|;
name|assertTrue
argument_list|(
name|cmd
operator|.
name|solrDoc
operator|.
name|containsKey
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|VERSION_FIELD
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|cmd
operator|.
name|solrDoc
operator|.
name|getFieldValue
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|VERSION_FIELD
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AtomicUpdateDocumentMerger
operator|.
name|computeInPlaceUpdatableFields
argument_list|(
name|cmd
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

