begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.update
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|Slow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|HttpSolrClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|UpdateRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|schema
operator|.
name|SchemaRequest
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|UpdateResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|schema
operator|.
name|SchemaResponse
operator|.
name|FieldResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|AbstractFullDistribZkTestBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|ZkController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocumentList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|ExecutorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|index
operator|.
name|NoMergePolicyFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributedUpdateProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DefaultSolrThreadFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Tests the in-place updates (docValues updates) for a one shard, three replica cluster.  */
end_comment

begin_class
annotation|@
name|Slow
DECL|class|TestInPlaceUpdatesDistrib
specifier|public
class|class
name|TestInPlaceUpdatesDistrib
extends|extends
name|AbstractFullDistribZkTestBase
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|beforeSuperClass
specifier|public
specifier|static
name|void
name|beforeSuperClass
parameter_list|()
throws|throws
name|Exception
block|{
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.tests.intClassName"
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"TrieIntField"
else|:
literal|"IntPointField"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.tests.longClassName"
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"TrieLongField"
else|:
literal|"LongPointField"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.tests.floatClassName"
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"TrieFloatField"
else|:
literal|"FloatPointField"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.tests.doubleClassName"
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"TrieDoubleField"
else|:
literal|"DoublePointField"
argument_list|)
expr_stmt|;
name|schemaString
operator|=
literal|"schema-inplace-updates.xml"
expr_stmt|;
name|configString
operator|=
literal|"solrconfig-tlog.xml"
expr_stmt|;
comment|// we need consistent segments that aren't re-ordered on merge because we're
comment|// asserting inplace updates happen by checking the internal [docid]
name|systemSetPropertySolrTestsMergePolicyFactory
argument_list|(
name|NoMergePolicyFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|initCore
argument_list|(
name|configString
argument_list|,
name|schemaString
argument_list|)
expr_stmt|;
comment|// sanity check that autocommits are disabled
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getUpdateHandlerInfo
argument_list|()
operator|.
name|autoCommmitMaxTime
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getUpdateHandlerInfo
argument_list|()
operator|.
name|autoSoftCommmitMaxTime
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getUpdateHandlerInfo
argument_list|()
operator|.
name|autoCommmitMaxDocs
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getUpdateHandlerInfo
argument_list|()
operator|.
name|autoSoftCommmitMaxDocs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|after
specifier|public
name|void
name|after
parameter_list|()
block|{
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.tests.intClassName"
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.tests.longClassName"
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.tests.floatClassName"
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.tests.doubleClassName"
argument_list|)
expr_stmt|;
block|}
DECL|method|TestInPlaceUpdatesDistrib
specifier|public
name|TestInPlaceUpdatesDistrib
parameter_list|()
throws|throws
name|Exception
block|{
name|super
argument_list|()
expr_stmt|;
name|sliceCount
operator|=
literal|1
expr_stmt|;
name|fixShardCount
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
DECL|field|LEADER
specifier|private
name|SolrClient
name|LEADER
init|=
literal|null
decl_stmt|;
DECL|field|NONLEADERS
specifier|private
name|List
argument_list|<
name|SolrClient
argument_list|>
name|NONLEADERS
init|=
literal|null
decl_stmt|;
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|3
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|test
specifier|public
name|void
name|test
parameter_list|()
throws|throws
name|Exception
block|{
name|waitForRecoveriesToFinish
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|mapReplicasToClients
argument_list|()
expr_stmt|;
comment|// sanity check no one broke the assumptions we make about our schema
name|checkExpectedSchemaField
argument_list|(
name|map
argument_list|(
literal|"name"
argument_list|,
literal|"inplace_updatable_int"
argument_list|,
literal|"type"
argument_list|,
literal|"int"
argument_list|,
literal|"stored"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"indexed"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"docValues"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|checkExpectedSchemaField
argument_list|(
name|map
argument_list|(
literal|"name"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
literal|"type"
argument_list|,
literal|"float"
argument_list|,
literal|"stored"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"indexed"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"docValues"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|checkExpectedSchemaField
argument_list|(
name|map
argument_list|(
literal|"name"
argument_list|,
literal|"_version_"
argument_list|,
literal|"type"
argument_list|,
literal|"long"
argument_list|,
literal|"stored"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"indexed"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"docValues"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|// Do the tests now:
name|reorderedDBQIndividualReplicaTest
argument_list|()
expr_stmt|;
name|testDBQUsingUpdatedFieldFromDroppedUpdate
argument_list|()
expr_stmt|;
name|outOfOrderDBQsTest
argument_list|()
expr_stmt|;
name|docValuesUpdateTest
argument_list|()
expr_stmt|;
name|ensureRtgWorksWithPartialUpdatesTest
argument_list|()
expr_stmt|;
name|delayedReorderingFetchesMissingUpdateFromLeaderTest
argument_list|()
expr_stmt|;
name|outOfOrderUpdatesIndividualReplicaTest
argument_list|()
expr_stmt|;
name|outOfOrderDeleteUpdatesIndividualReplicaTest
argument_list|()
expr_stmt|;
name|reorderedDBQsWithInPlaceUpdatesShouldNotThrowReplicaInLIRTest
argument_list|()
expr_stmt|;
block|}
DECL|method|mapReplicasToClients
specifier|private
name|void
name|mapReplicasToClients
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|ZkStateReader
name|zkStateReader
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
decl_stmt|;
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|forceUpdateCollection
argument_list|(
name|DEFAULT_COLLECTION
argument_list|)
expr_stmt|;
name|ClusterState
name|clusterState
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|Replica
name|leader
init|=
literal|null
decl_stmt|;
name|Slice
name|shard1
init|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|DEFAULT_COLLECTION
argument_list|)
operator|.
name|getSlice
argument_list|(
name|SHARD1
argument_list|)
decl_stmt|;
name|leader
operator|=
name|shard1
operator|.
name|getLeader
argument_list|()
expr_stmt|;
name|String
name|leaderBaseUrl
init|=
name|zkStateReader
operator|.
name|getBaseUrlForNodeName
argument_list|(
name|leader
operator|.
name|getNodeName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clients
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|HttpSolrClient
operator|)
name|clients
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getBaseURL
argument_list|()
operator|.
name|startsWith
argument_list|(
name|leaderBaseUrl
argument_list|)
condition|)
name|LEADER
operator|=
name|clients
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|NONLEADERS
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|Replica
name|rep
range|:
name|shard1
operator|.
name|getReplicas
argument_list|()
control|)
block|{
if|if
condition|(
name|rep
operator|.
name|equals
argument_list|(
name|leader
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|baseUrl
init|=
name|zkStateReader
operator|.
name|getBaseUrlForNodeName
argument_list|(
name|rep
operator|.
name|getNodeName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clients
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|HttpSolrClient
operator|)
name|clients
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getBaseURL
argument_list|()
operator|.
name|startsWith
argument_list|(
name|baseUrl
argument_list|)
condition|)
name|NONLEADERS
operator|.
name|add
argument_list|(
name|clients
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertNotNull
argument_list|(
name|LEADER
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|NONLEADERS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|field|NUM_RETRIES
DECL|field|WAIT_TIME
specifier|final
name|int
name|NUM_RETRIES
init|=
literal|100
decl_stmt|,
name|WAIT_TIME
init|=
literal|10
decl_stmt|;
comment|// The following should work: full update to doc 0, in-place update for doc 0, delete doc 0
DECL|method|outOfOrderDBQsTest
specifier|private
name|void
name|outOfOrderDBQsTest
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
name|buildRandomIndex
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|float
name|inplace_updatable_float
init|=
literal|1
decl_stmt|;
comment|// update doc, set
name|index
argument_list|(
literal|"id"
argument_list|,
literal|0
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
name|inplace_updatable_float
argument_list|)
argument_list|)
expr_stmt|;
name|LEADER
operator|.
name|commit
argument_list|()
expr_stmt|;
name|SolrDocument
name|sdoc
init|=
name|LEADER
operator|.
name|getById
argument_list|(
literal|"0"
argument_list|)
decl_stmt|;
comment|// RTG straight from the index
name|assertEquals
argument_list|(
name|inplace_updatable_float
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"title0"
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"title_s"
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|version0
init|=
operator|(
name|long
operator|)
name|sdoc
operator|.
name|get
argument_list|(
literal|"_version_"
argument_list|)
decl_stmt|;
comment|// put replica out of sync
name|float
name|newinplace_updatable_float
init|=
literal|100
decl_stmt|;
name|List
argument_list|<
name|UpdateRequest
argument_list|>
name|updates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|simulatedUpdateRequest
argument_list|(
literal|null
argument_list|,
literal|"id"
argument_list|,
literal|0
argument_list|,
literal|"title_s"
argument_list|,
literal|"title0_new"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|newinplace_updatable_float
argument_list|,
literal|"_version_"
argument_list|,
name|version0
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// full update
name|updates
operator|.
name|add
argument_list|(
name|simulatedUpdateRequest
argument_list|(
name|version0
operator|+
literal|1
argument_list|,
literal|"id"
argument_list|,
literal|0
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|newinplace_updatable_float
operator|+
literal|1
argument_list|,
literal|"_version_"
argument_list|,
name|version0
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// inplace_updatable_float=101
name|updates
operator|.
name|add
argument_list|(
name|simulatedDeleteRequest
argument_list|(
literal|0
argument_list|,
name|version0
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|// order the updates correctly for NONLEADER 1
for|for
control|(
name|UpdateRequest
name|update
range|:
name|updates
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Issuing well ordered update: "
operator|+
name|update
operator|.
name|getDocuments
argument_list|()
argument_list|)
expr_stmt|;
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|request
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
comment|// Reordering needs to happen using parallel threads
name|ExecutorService
name|threadpool
init|=
name|ExecutorUtil
operator|.
name|newMDCAwareFixedThreadPool
argument_list|(
name|updates
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
operator|new
name|DefaultSolrThreadFactory
argument_list|(
name|getTestName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// re-order the updates for NONLEADER 0
name|List
argument_list|<
name|UpdateRequest
argument_list|>
name|reorderedUpdates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|updates
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|reorderedUpdates
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Future
argument_list|<
name|UpdateResponse
argument_list|>
argument_list|>
name|updateResponses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateRequest
name|update
range|:
name|reorderedUpdates
control|)
block|{
name|AsyncUpdateWithRandomCommit
name|task
init|=
operator|new
name|AsyncUpdateWithRandomCommit
argument_list|(
name|update
argument_list|,
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
name|updateResponses
operator|.
name|add
argument_list|(
name|threadpool
operator|.
name|submit
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
comment|// while we can't guarantee/trust what order the updates are executed in, since multiple threads
comment|// are involved, but we're trying to bias the thread scheduling to run them in the order submitted
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|threadpool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Thread pool didn't terminate within 10 secs"
argument_list|,
name|threadpool
operator|.
name|awaitTermination
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
comment|// assert all requests were successful
for|for
control|(
name|Future
argument_list|<
name|UpdateResponse
argument_list|>
name|resp
range|:
name|updateResponses
control|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|resp
operator|.
name|get
argument_list|()
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// assert both replicas have same effect
for|for
control|(
name|SolrClient
name|client
range|:
name|NONLEADERS
control|)
block|{
comment|// 0th is re-ordered replica, 1st is well-ordered replica
name|SolrDocument
name|doc
init|=
name|client
operator|.
name|getById
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|params
argument_list|(
literal|"distrib"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
literal|"This doc was supposed to have been deleted, but was: "
operator|+
name|doc
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"outOfOrderDeleteUpdatesIndividualReplicaTest: This test passed fine..."
argument_list|)
expr_stmt|;
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
block|}
DECL|method|reorderedDBQIndividualReplicaTest
specifier|private
name|void
name|reorderedDBQIndividualReplicaTest
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
comment|// put replica out of sync
name|float
name|newinplace_updatable_float
init|=
literal|100
decl_stmt|;
name|long
name|version0
init|=
literal|2000
decl_stmt|;
name|List
argument_list|<
name|UpdateRequest
argument_list|>
name|updates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|simulatedUpdateRequest
argument_list|(
literal|null
argument_list|,
literal|"id"
argument_list|,
literal|0
argument_list|,
literal|"title_s"
argument_list|,
literal|"title0_new"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|newinplace_updatable_float
argument_list|,
literal|"_version_"
argument_list|,
name|version0
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// full update
name|updates
operator|.
name|add
argument_list|(
name|simulatedUpdateRequest
argument_list|(
name|version0
operator|+
literal|1
argument_list|,
literal|"id"
argument_list|,
literal|0
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|newinplace_updatable_float
operator|+
literal|1
argument_list|,
literal|"_version_"
argument_list|,
name|version0
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// inplace_updatable_float=101
name|updates
operator|.
name|add
argument_list|(
name|simulatedDeleteRequest
argument_list|(
literal|"inplace_updatable_float:"
operator|+
operator|(
name|newinplace_updatable_float
operator|+
literal|1
operator|)
argument_list|,
name|version0
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|// Reordering needs to happen using parallel threads
name|ExecutorService
name|threadpool
init|=
name|ExecutorUtil
operator|.
name|newMDCAwareFixedThreadPool
argument_list|(
name|updates
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
operator|new
name|DefaultSolrThreadFactory
argument_list|(
name|getTestName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// re-order the updates by swapping the last two
name|List
argument_list|<
name|UpdateRequest
argument_list|>
name|reorderedUpdates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|updates
argument_list|)
decl_stmt|;
name|reorderedUpdates
operator|.
name|set
argument_list|(
literal|1
argument_list|,
name|updates
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|reorderedUpdates
operator|.
name|set
argument_list|(
literal|2
argument_list|,
name|updates
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Future
argument_list|<
name|UpdateResponse
argument_list|>
argument_list|>
name|updateResponses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateRequest
name|update
range|:
name|reorderedUpdates
control|)
block|{
name|AsyncUpdateWithRandomCommit
name|task
init|=
operator|new
name|AsyncUpdateWithRandomCommit
argument_list|(
name|update
argument_list|,
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
name|updateResponses
operator|.
name|add
argument_list|(
name|threadpool
operator|.
name|submit
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
comment|// while we can't guarantee/trust what order the updates are executed in, since multiple threads
comment|// are involved, but we're trying to bias the thread scheduling to run them in the order submitted
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|threadpool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Thread pool didn't terminate within 10 secs"
argument_list|,
name|threadpool
operator|.
name|awaitTermination
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
comment|// assert all requests were successful
for|for
control|(
name|Future
argument_list|<
name|UpdateResponse
argument_list|>
name|resp
range|:
name|updateResponses
control|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|resp
operator|.
name|get
argument_list|()
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|SolrDocument
name|doc
init|=
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getById
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|params
argument_list|(
literal|"distrib"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
literal|"This doc was supposed to have been deleted, but was: "
operator|+
name|doc
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"reorderedDBQIndividualReplicaTest: This test passed fine..."
argument_list|)
expr_stmt|;
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
block|}
DECL|method|docValuesUpdateTest
specifier|private
name|void
name|docValuesUpdateTest
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
comment|// number of docs we're testing (0<= id), index may contain additional random docs (id< 0)
specifier|final
name|int
name|numDocs
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Trying num docs = "
operator|+
name|numDocs
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|numDocs
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|id
init|=
literal|0
init|;
name|id
operator|<
name|numDocs
condition|;
name|id
operator|++
control|)
block|{
name|ids
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|buildRandomIndex
argument_list|(
literal|101.0F
argument_list|,
name|ids
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|luceneDocids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|numDocs
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Float
argument_list|>
name|valuesList
init|=
operator|new
name|ArrayList
argument_list|<
name|Float
argument_list|>
argument_list|(
name|numDocs
argument_list|)
decl_stmt|;
name|SolrParams
name|params
init|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"id:[0 TO *]"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,[docid]"
argument_list|,
literal|"rows"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|numDocs
argument_list|)
argument_list|,
literal|"sort"
argument_list|,
literal|"id_i asc"
argument_list|)
decl_stmt|;
name|SolrDocumentList
name|results
init|=
name|LEADER
operator|.
name|query
argument_list|(
name|params
argument_list|)
operator|.
name|getResults
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|numDocs
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|SolrDocument
name|doc
range|:
name|results
control|)
block|{
name|luceneDocids
operator|.
name|add
argument_list|(
operator|(
name|int
operator|)
name|doc
operator|.
name|get
argument_list|(
literal|"[docid]"
argument_list|)
argument_list|)
expr_stmt|;
name|valuesList
operator|.
name|add
argument_list|(
operator|(
name|Float
operator|)
name|doc
operator|.
name|get
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Initial results: "
operator|+
name|results
argument_list|)
expr_stmt|;
comment|// before we do any atomic operations, sanity check our results against all clients
name|assertDocIdsAndValuesAgainstAllClients
argument_list|(
literal|"sanitycheck"
argument_list|,
name|params
argument_list|,
name|luceneDocids
argument_list|,
name|valuesList
argument_list|)
expr_stmt|;
comment|// now we're going to overwrite the value for all of our testing docs
comment|// giving them a value between -5 and +5
for|for
control|(
name|int
name|id
range|:
name|ids
control|)
block|{
comment|// NOTE: in rare cases, this may be setting the value to 0, on a doc that
comment|// already had an init value of 0 -- which is an interesting edge case, so we don't exclude it
specifier|final
name|float
name|multiplier
init|=
name|r
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|-
literal|5.0F
else|:
literal|5.0F
decl_stmt|;
specifier|final
name|float
name|value
init|=
name|r
operator|.
name|nextFloat
argument_list|()
operator|*
name|multiplier
decl_stmt|;
assert|assert
operator|-
literal|5.0F
operator|<=
name|value
operator|&&
name|value
operator|<=
literal|5.0F
assert|;
name|valuesList
operator|.
name|set
argument_list|(
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"inplace_updatable_float: "
operator|+
name|valuesList
argument_list|)
expr_stmt|;
comment|// update doc w/ set
name|Collections
operator|.
name|shuffle
argument_list|(
name|ids
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|// so updates aren't applied in index order
for|for
control|(
name|int
name|id
range|:
name|ids
control|)
block|{
name|index
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
name|valuesList
operator|.
name|get
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|commit
argument_list|()
expr_stmt|;
name|assertDocIdsAndValuesAgainstAllClients
argument_list|(
literal|"set"
argument_list|,
name|SolrParams
operator|.
name|wrapDefaults
argument_list|(
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"inplace_updatable_float:[-5.0 TO 5.0]"
argument_list|,
literal|"fq"
argument_list|,
literal|"id:[0 TO *]"
argument_list|)
argument_list|,
comment|// existing sort& fl that we want...
name|params
argument_list|)
argument_list|,
name|luceneDocids
argument_list|,
name|valuesList
argument_list|)
expr_stmt|;
comment|// update doc, w/increment
name|log
operator|.
name|info
argument_list|(
literal|"Updating the documents..."
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|ids
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|// so updates aren't applied in the same order as our 'set'
for|for
control|(
name|int
name|id
range|:
name|ids
control|)
block|{
comment|// all incremements will use some value X such that 20< abs(X)
comment|// thus ensuring that after all incrememnts are done, there should be
comment|// 0 test docs matching the query inplace_updatable_float:[-10 TO 10]
specifier|final
name|float
name|inc
init|=
operator|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|-
literal|1.0F
else|:
literal|1.0F
operator|)
operator|*
operator|(
name|r
operator|.
name|nextFloat
argument_list|()
operator|+
operator|(
name|float
operator|)
name|atLeast
argument_list|(
literal|20
argument_list|)
operator|)
decl_stmt|;
assert|assert
literal|20
operator|<
name|Math
operator|.
name|abs
argument_list|(
name|inc
argument_list|)
assert|;
specifier|final
name|float
name|value
init|=
name|valuesList
operator|.
name|get
argument_list|(
name|id
argument_list|)
operator|+
name|inc
decl_stmt|;
assert|assert
name|value
operator|<
operator|-
literal|10
operator|||
literal|10
operator|<
name|value
assert|;
name|valuesList
operator|.
name|set
argument_list|(
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|index
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
name|inc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|commit
argument_list|()
expr_stmt|;
name|assertDocIdsAndValuesAgainstAllClients
argument_list|(
literal|"inc"
argument_list|,
name|SolrParams
operator|.
name|wrapDefaults
argument_list|(
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"-inplace_updatable_float:[-10.0 TO 10.0]"
argument_list|,
literal|"fq"
argument_list|,
literal|"id:[0 TO *]"
argument_list|)
argument_list|,
comment|// existing sort& fl that we want...
name|params
argument_list|)
argument_list|,
name|luceneDocids
argument_list|,
name|valuesList
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"docValuesUpdateTest: This test passed fine..."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Retries the specified 'req' against each SolrClient in "clients" untill the expected number of     * results are returned, at which point the results are verified using assertDocIdsAndValuesInResults    *    * @param debug used in log and assertion messages    * @param req the query to execut, should include rows&amp; sort params such that the results can be compared to luceneDocids and valuesList    * @param luceneDocids a list of "[docid]" values to be tested against each doc in the req results (in order)    * @param valuesList a list of "inplace_updatable_float" values to be tested against each doc in the req results (in order)    */
DECL|method|assertDocIdsAndValuesAgainstAllClients
specifier|private
name|void
name|assertDocIdsAndValuesAgainstAllClients
parameter_list|(
specifier|final
name|String
name|debug
parameter_list|,
specifier|final
name|SolrParams
name|req
parameter_list|,
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|luceneDocids
parameter_list|,
specifier|final
name|List
argument_list|<
name|Float
argument_list|>
name|valuesList
parameter_list|)
throws|throws
name|Exception
block|{
assert|assert
name|luceneDocids
operator|.
name|size
argument_list|()
operator|==
name|valuesList
operator|.
name|size
argument_list|()
assert|;
specifier|final
name|long
name|numFoundExpected
init|=
name|luceneDocids
operator|.
name|size
argument_list|()
decl_stmt|;
name|CLIENT
label|:
for|for
control|(
name|SolrClient
name|client
range|:
name|clients
control|)
block|{
specifier|final
name|String
name|clientDebug
init|=
name|client
operator|.
name|toString
argument_list|()
operator|+
operator|(
name|LEADER
operator|.
name|equals
argument_list|(
name|client
argument_list|)
condition|?
literal|" (leader)"
else|:
literal|" (not leader)"
operator|)
decl_stmt|;
specifier|final
name|String
name|msg
init|=
literal|"'"
operator|+
name|debug
operator|+
literal|"' results against client: "
operator|+
name|clientDebug
decl_stmt|;
name|SolrDocumentList
name|results
init|=
literal|null
decl_stmt|;
comment|// For each client, do a (sorted) sanity check query to confirm searcher has been re-opened
comment|// after our update -- if the numFound matches our expectations, then verify the inplace float
comment|// value and [docid] of each result doc against our expecations to ensure that the values were
comment|// updated properly w/o the doc being completley re-added internally. (ie: truly inplace)
name|RETRY
label|:
for|for
control|(
name|int
name|attempt
init|=
literal|0
init|;
name|attempt
operator|<=
name|NUM_RETRIES
condition|;
name|attempt
operator|++
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Attempt #{} checking {}"
argument_list|,
name|attempt
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|results
operator|=
name|client
operator|.
name|query
argument_list|(
name|req
argument_list|)
operator|.
name|getResults
argument_list|()
expr_stmt|;
if|if
condition|(
name|numFoundExpected
operator|==
name|results
operator|.
name|getNumFound
argument_list|()
condition|)
block|{
break|break
name|RETRY
break|;
block|}
if|if
condition|(
name|attempt
operator|==
name|NUM_RETRIES
condition|)
block|{
name|fail
argument_list|(
literal|"Repeated retry for "
operator|+
name|msg
operator|+
literal|"; Never got numFound="
operator|+
name|numFoundExpected
operator|+
literal|"; results=> "
operator|+
name|results
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"numFound missmatch, searcher may not have re-opened yet.  Will sleep an retry..."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|WAIT_TIME
argument_list|)
expr_stmt|;
block|}
name|assertDocIdsAndValuesInResults
argument_list|(
name|msg
argument_list|,
name|results
argument_list|,
name|luceneDocids
argument_list|,
name|valuesList
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Given a result list sorted by "id", asserts that the "[docid] and "inplace_updatable_float" values     * for each document match in order.    *    * @param msgPre used as a prefix for assertion messages    * @param results the sorted results of some query, such that all matches are included (ie: rows = numFound)    * @param luceneDocids a list of "[docid]" values to be tested against each doc in results (in order)    * @param valuesList a list of "inplace_updatable_float" values to be tested against each doc in results (in order)    */
DECL|method|assertDocIdsAndValuesInResults
specifier|private
name|void
name|assertDocIdsAndValuesInResults
parameter_list|(
specifier|final
name|String
name|msgPre
parameter_list|,
specifier|final
name|SolrDocumentList
name|results
parameter_list|,
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|luceneDocids
parameter_list|,
specifier|final
name|List
argument_list|<
name|Float
argument_list|>
name|valuesList
parameter_list|)
block|{
assert|assert
name|luceneDocids
operator|.
name|size
argument_list|()
operator|==
name|valuesList
operator|.
name|size
argument_list|()
assert|;
name|assertEquals
argument_list|(
name|msgPre
operator|+
literal|": rows param wasn't big enough, we need to compare all results matching the query"
argument_list|,
name|results
operator|.
name|getNumFound
argument_list|()
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|msgPre
operator|+
literal|": didn't get a result for every known docid"
argument_list|,
name|luceneDocids
operator|.
name|size
argument_list|()
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|SolrDocument
name|doc
range|:
name|results
control|)
block|{
specifier|final
name|int
name|id
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|doc
operator|.
name|get
argument_list|(
literal|"id"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|val
init|=
name|doc
operator|.
name|get
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|docid
init|=
name|doc
operator|.
name|get
argument_list|(
literal|"[docid]"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|msgPre
operator|+
literal|" wrong val for "
operator|+
name|doc
operator|.
name|toString
argument_list|()
argument_list|,
name|valuesList
operator|.
name|get
argument_list|(
name|id
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|msgPre
operator|+
literal|" wrong [docid] for "
operator|+
name|doc
operator|.
name|toString
argument_list|()
argument_list|,
name|luceneDocids
operator|.
name|get
argument_list|(
name|id
argument_list|)
argument_list|,
name|docid
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|ensureRtgWorksWithPartialUpdatesTest
specifier|private
name|void
name|ensureRtgWorksWithPartialUpdatesTest
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
name|float
name|inplace_updatable_float
init|=
literal|1
decl_stmt|;
name|String
name|title
init|=
literal|"title100"
decl_stmt|;
name|long
name|version
init|=
literal|0
decl_stmt|,
name|currentVersion
decl_stmt|;
name|currentVersion
operator|=
name|buildRandomIndex
argument_list|(
literal|100
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|currentVersion
operator|>
name|version
argument_list|)
expr_stmt|;
comment|// do an initial (non-inplace) update to ensure both the float& int fields we care about have (any) value
comment|// that way all subsequent atomic updates will be inplace
name|currentVersion
operator|=
name|addDocAndGetVersion
argument_list|(
literal|"id"
argument_list|,
literal|100
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
name|r
operator|.
name|nextFloat
argument_list|()
argument_list|)
argument_list|,
literal|"inplace_updatable_int"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
name|r
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LEADER
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|// get the internal docids of id=100 document from the three replicas
name|List
argument_list|<
name|Integer
argument_list|>
name|docids
init|=
name|getInternalDocIds
argument_list|(
literal|"100"
argument_list|)
decl_stmt|;
comment|// update doc, set
name|currentVersion
operator|=
name|addDocAndGetVersion
argument_list|(
literal|"id"
argument_list|,
literal|100
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
name|inplace_updatable_float
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|currentVersion
operator|>
name|version
argument_list|)
expr_stmt|;
name|version
operator|=
name|currentVersion
expr_stmt|;
name|LEADER
operator|.
name|commit
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Earlier: "
operator|+
name|docids
operator|+
literal|", now: "
operator|+
name|getInternalDocIds
argument_list|(
literal|"100"
argument_list|)
argument_list|,
name|docids
operator|.
name|equals
argument_list|(
name|getInternalDocIds
argument_list|(
literal|"100"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SolrDocument
name|sdoc
init|=
name|LEADER
operator|.
name|getById
argument_list|(
literal|"100"
argument_list|)
decl_stmt|;
comment|// RTG straight from the index
name|assertEquals
argument_list|(
name|sdoc
operator|.
name|toString
argument_list|()
argument_list|,
operator|(
name|float
operator|)
name|inplace_updatable_float
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|sdoc
operator|.
name|toString
argument_list|()
argument_list|,
name|title
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"title_s"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|sdoc
operator|.
name|toString
argument_list|()
argument_list|,
name|version
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|title
operator|=
literal|"newtitle100"
expr_stmt|;
name|currentVersion
operator|=
name|addDocAndGetVersion
argument_list|(
literal|"id"
argument_list|,
literal|100
argument_list|,
literal|"title_s"
argument_list|,
name|title
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|inplace_updatable_float
argument_list|)
expr_stmt|;
comment|// full indexing
name|assertTrue
argument_list|(
name|currentVersion
operator|>
name|version
argument_list|)
expr_stmt|;
name|version
operator|=
name|currentVersion
expr_stmt|;
name|sdoc
operator|=
name|LEADER
operator|.
name|getById
argument_list|(
literal|"100"
argument_list|)
expr_stmt|;
comment|// RTG from the tlog
name|assertEquals
argument_list|(
name|sdoc
operator|.
name|toString
argument_list|()
argument_list|,
operator|(
name|float
operator|)
name|inplace_updatable_float
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|sdoc
operator|.
name|toString
argument_list|()
argument_list|,
name|title
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"title_s"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|sdoc
operator|.
name|toString
argument_list|()
argument_list|,
name|version
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
comment|// we've done a full index, so we need to update the [docid] for each replica
name|LEADER
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|// can't get (real) [docid] from the tlogs, need to force a commit
name|docids
operator|=
name|getInternalDocIds
argument_list|(
literal|"100"
argument_list|)
expr_stmt|;
block|}
name|inplace_updatable_float
operator|++
expr_stmt|;
name|currentVersion
operator|=
name|addDocAndGetVersion
argument_list|(
literal|"id"
argument_list|,
literal|100
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|currentVersion
operator|>
name|version
argument_list|)
expr_stmt|;
name|version
operator|=
name|currentVersion
expr_stmt|;
name|LEADER
operator|.
name|commit
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Earlier: "
operator|+
name|docids
operator|+
literal|", now: "
operator|+
name|getInternalDocIds
argument_list|(
literal|"100"
argument_list|)
argument_list|,
name|docids
operator|.
name|equals
argument_list|(
name|getInternalDocIds
argument_list|(
literal|"100"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|currentVersion
operator|=
name|addDocAndGetVersion
argument_list|(
literal|"id"
argument_list|,
literal|100
argument_list|,
literal|"inplace_updatable_int"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
literal|"100"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|currentVersion
operator|>
name|version
argument_list|)
expr_stmt|;
name|version
operator|=
name|currentVersion
expr_stmt|;
name|inplace_updatable_float
operator|++
expr_stmt|;
name|currentVersion
operator|=
name|addDocAndGetVersion
argument_list|(
literal|"id"
argument_list|,
literal|100
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|currentVersion
operator|>
name|version
argument_list|)
expr_stmt|;
name|version
operator|=
name|currentVersion
expr_stmt|;
comment|// RTG from tlog(s)
for|for
control|(
name|SolrClient
name|client
range|:
name|clients
control|)
block|{
specifier|final
name|String
name|clientDebug
init|=
name|client
operator|.
name|toString
argument_list|()
operator|+
operator|(
name|LEADER
operator|.
name|equals
argument_list|(
name|client
argument_list|)
condition|?
literal|" (leader)"
else|:
literal|" (not leader)"
operator|)
decl_stmt|;
name|sdoc
operator|=
name|client
operator|.
name|getById
argument_list|(
literal|"100"
argument_list|,
name|params
argument_list|(
literal|"distrib"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|clientDebug
operator|+
literal|" => "
operator|+
name|sdoc
argument_list|,
operator|(
name|int
operator|)
literal|100
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"inplace_updatable_int"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|clientDebug
operator|+
literal|" => "
operator|+
name|sdoc
argument_list|,
operator|(
name|float
operator|)
name|inplace_updatable_float
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|clientDebug
operator|+
literal|" => "
operator|+
name|sdoc
argument_list|,
name|title
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"title_s"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|clientDebug
operator|+
literal|" => "
operator|+
name|sdoc
argument_list|,
name|version
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// assert that the internal docid for id=100 document remains same, in each replica, as before
name|LEADER
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|// can't get (real) [docid] from the tlogs, need to force a commit
name|assertTrue
argument_list|(
literal|"Earlier: "
operator|+
name|docids
operator|+
literal|", now: "
operator|+
name|getInternalDocIds
argument_list|(
literal|"100"
argument_list|)
argument_list|,
name|docids
operator|.
name|equals
argument_list|(
name|getInternalDocIds
argument_list|(
literal|"100"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"ensureRtgWorksWithPartialUpdatesTest: This test passed fine..."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the "[docid]" value(s) returned from a non-distrib RTG to each of the clients used     * in this test (in the same order as the clients list)    */
DECL|method|getInternalDocIds
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|getInternalDocIds
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|clients
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|SolrClient
name|client
range|:
name|clients
control|)
block|{
name|SolrDocument
name|doc
init|=
name|client
operator|.
name|getById
argument_list|(
name|id
argument_list|,
name|params
argument_list|(
literal|"distrib"
argument_list|,
literal|"false"
argument_list|,
literal|"fl"
argument_list|,
literal|"[docid]"
argument_list|)
argument_list|)
decl_stmt|;
name|Object
name|docid
init|=
name|doc
operator|.
name|get
argument_list|(
literal|"[docid]"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|docid
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Integer
operator|.
name|class
argument_list|,
name|docid
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|ret
operator|.
name|add
argument_list|(
operator|(
name|Integer
operator|)
name|docid
argument_list|)
expr_stmt|;
block|}
assert|assert
name|clients
operator|.
name|size
argument_list|()
operator|==
name|ret
operator|.
name|size
argument_list|()
assert|;
return|return
name|ret
return|;
block|}
DECL|method|outOfOrderUpdatesIndividualReplicaTest
specifier|private
name|void
name|outOfOrderUpdatesIndividualReplicaTest
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
name|buildRandomIndex
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|float
name|inplace_updatable_float
init|=
literal|1
decl_stmt|;
comment|// update doc, set
name|index
argument_list|(
literal|"id"
argument_list|,
literal|0
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
name|inplace_updatable_float
argument_list|)
argument_list|)
expr_stmt|;
name|LEADER
operator|.
name|commit
argument_list|()
expr_stmt|;
name|SolrDocument
name|sdoc
init|=
name|LEADER
operator|.
name|getById
argument_list|(
literal|"0"
argument_list|)
decl_stmt|;
comment|// RTG straight from the index
name|assertEquals
argument_list|(
name|inplace_updatable_float
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"title0"
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"title_s"
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|version0
init|=
operator|(
name|long
operator|)
name|sdoc
operator|.
name|get
argument_list|(
literal|"_version_"
argument_list|)
decl_stmt|;
comment|// put replica out of sync
name|float
name|newinplace_updatable_float
init|=
literal|100
decl_stmt|;
name|List
argument_list|<
name|UpdateRequest
argument_list|>
name|updates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|simulatedUpdateRequest
argument_list|(
literal|null
argument_list|,
literal|"id"
argument_list|,
literal|0
argument_list|,
literal|"title_s"
argument_list|,
literal|"title0_new"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|newinplace_updatable_float
argument_list|,
literal|"_version_"
argument_list|,
name|version0
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// full update
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|atLeast
argument_list|(
literal|3
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|updates
operator|.
name|add
argument_list|(
name|simulatedUpdateRequest
argument_list|(
name|version0
operator|+
name|i
argument_list|,
literal|"id"
argument_list|,
literal|0
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|newinplace_updatable_float
operator|+
name|i
argument_list|,
literal|"_version_"
argument_list|,
name|version0
operator|+
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// order the updates correctly for NONLEADER 1
for|for
control|(
name|UpdateRequest
name|update
range|:
name|updates
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Issuing well ordered update: "
operator|+
name|update
operator|.
name|getDocuments
argument_list|()
argument_list|)
expr_stmt|;
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|request
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
comment|// Reordering needs to happen using parallel threads, since some of these updates will
comment|// be blocking calls, waiting for some previous updates to arrive on which it depends.
name|ExecutorService
name|threadpool
init|=
name|ExecutorUtil
operator|.
name|newMDCAwareFixedThreadPool
argument_list|(
name|updates
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
operator|new
name|DefaultSolrThreadFactory
argument_list|(
name|getTestName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// re-order the updates for NONLEADER 0
name|List
argument_list|<
name|UpdateRequest
argument_list|>
name|reorderedUpdates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|updates
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|reorderedUpdates
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Future
argument_list|<
name|UpdateResponse
argument_list|>
argument_list|>
name|updateResponses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateRequest
name|update
range|:
name|reorderedUpdates
control|)
block|{
name|AsyncUpdateWithRandomCommit
name|task
init|=
operator|new
name|AsyncUpdateWithRandomCommit
argument_list|(
name|update
argument_list|,
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
name|updateResponses
operator|.
name|add
argument_list|(
name|threadpool
operator|.
name|submit
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
comment|// while we can't guarantee/trust what order the updates are executed in, since multiple threads
comment|// are involved, but we're trying to bias the thread scheduling to run them in the order submitted
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|threadpool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Thread pool didn't terminate within 10 secs"
argument_list|,
name|threadpool
operator|.
name|awaitTermination
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
comment|// assert all requests were successful
for|for
control|(
name|Future
argument_list|<
name|UpdateResponse
argument_list|>
name|resp
range|:
name|updateResponses
control|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|resp
operator|.
name|get
argument_list|()
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// assert both replicas have same effect
for|for
control|(
name|SolrClient
name|client
range|:
name|NONLEADERS
control|)
block|{
comment|// 0th is re-ordered replica, 1st is well-ordered replica
name|log
operator|.
name|info
argument_list|(
literal|"Testing client: "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|client
operator|)
operator|.
name|getBaseURL
argument_list|()
argument_list|)
expr_stmt|;
name|assertReplicaValue
argument_list|(
name|client
argument_list|,
literal|0
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
operator|(
name|newinplace_updatable_float
operator|+
call|(
name|float
call|)
argument_list|(
name|updates
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|)
argument_list|,
literal|"inplace_updatable_float didn't match for replica at client: "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|client
operator|)
operator|.
name|getBaseURL
argument_list|()
argument_list|)
expr_stmt|;
name|assertReplicaValue
argument_list|(
name|client
argument_list|,
literal|0
argument_list|,
literal|"title_s"
argument_list|,
literal|"title0_new"
argument_list|,
literal|"Title didn't match for replica at client: "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|client
operator|)
operator|.
name|getBaseURL
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|version0
operator|+
name|updates
operator|.
name|size
argument_list|()
argument_list|,
name|getReplicaValue
argument_list|(
name|client
argument_list|,
literal|0
argument_list|,
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"outOfOrderUpdatesIndividualReplicaTest: This test passed fine..."
argument_list|)
expr_stmt|;
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
block|}
comment|// The following should work: full update to doc 0, in-place update for doc 0, delete doc 0
DECL|method|outOfOrderDeleteUpdatesIndividualReplicaTest
specifier|private
name|void
name|outOfOrderDeleteUpdatesIndividualReplicaTest
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
name|buildRandomIndex
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|float
name|inplace_updatable_float
init|=
literal|1
decl_stmt|;
comment|// update doc, set
name|index
argument_list|(
literal|"id"
argument_list|,
literal|0
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"set"
argument_list|,
name|inplace_updatable_float
argument_list|)
argument_list|)
expr_stmt|;
name|LEADER
operator|.
name|commit
argument_list|()
expr_stmt|;
name|SolrDocument
name|sdoc
init|=
name|LEADER
operator|.
name|getById
argument_list|(
literal|"0"
argument_list|)
decl_stmt|;
comment|// RTG straight from the index
name|assertEquals
argument_list|(
name|inplace_updatable_float
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"inplace_updatable_float"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"title0"
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"title_s"
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|version0
init|=
operator|(
name|long
operator|)
name|sdoc
operator|.
name|get
argument_list|(
literal|"_version_"
argument_list|)
decl_stmt|;
comment|// put replica out of sync
name|float
name|newinplace_updatable_float
init|=
literal|100
decl_stmt|;
name|List
argument_list|<
name|UpdateRequest
argument_list|>
name|updates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|simulatedUpdateRequest
argument_list|(
literal|null
argument_list|,
literal|"id"
argument_list|,
literal|0
argument_list|,
literal|"title_s"
argument_list|,
literal|"title0_new"
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|newinplace_updatable_float
argument_list|,
literal|"_version_"
argument_list|,
name|version0
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// full update
name|updates
operator|.
name|add
argument_list|(
name|simulatedUpdateRequest
argument_list|(
name|version0
operator|+
literal|1
argument_list|,
literal|"id"
argument_list|,
literal|0
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|newinplace_updatable_float
operator|+
literal|1
argument_list|,
literal|"_version_"
argument_list|,
name|version0
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// inplace_updatable_float=101
name|updates
operator|.
name|add
argument_list|(
name|simulatedDeleteRequest
argument_list|(
literal|0
argument_list|,
name|version0
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|// order the updates correctly for NONLEADER 1
for|for
control|(
name|UpdateRequest
name|update
range|:
name|updates
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Issuing well ordered update: "
operator|+
name|update
operator|.
name|getDocuments
argument_list|()
argument_list|)
expr_stmt|;
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|request
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
comment|// Reordering needs to happen using parallel threads
name|ExecutorService
name|threadpool
init|=
name|ExecutorUtil
operator|.
name|newMDCAwareFixedThreadPool
argument_list|(
name|updates
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
operator|new
name|DefaultSolrThreadFactory
argument_list|(
name|getTestName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// re-order the updates for NONLEADER 0
name|List
argument_list|<
name|UpdateRequest
argument_list|>
name|reorderedUpdates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|updates
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|reorderedUpdates
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Future
argument_list|<
name|UpdateResponse
argument_list|>
argument_list|>
name|updateResponses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateRequest
name|update
range|:
name|reorderedUpdates
control|)
block|{
name|AsyncUpdateWithRandomCommit
name|task
init|=
operator|new
name|AsyncUpdateWithRandomCommit
argument_list|(
name|update
argument_list|,
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
name|updateResponses
operator|.
name|add
argument_list|(
name|threadpool
operator|.
name|submit
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
comment|// while we can't guarantee/trust what order the updates are executed in, since multiple threads
comment|// are involved, but we're trying to bias the thread scheduling to run them in the order submitted
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|threadpool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Thread pool didn't terminate within 10 secs"
argument_list|,
name|threadpool
operator|.
name|awaitTermination
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
comment|// assert all requests were successful
for|for
control|(
name|Future
argument_list|<
name|UpdateResponse
argument_list|>
name|resp
range|:
name|updateResponses
control|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|resp
operator|.
name|get
argument_list|()
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// assert both replicas have same effect
for|for
control|(
name|SolrClient
name|client
range|:
name|NONLEADERS
control|)
block|{
comment|// 0th is re-ordered replica, 1st is well-ordered replica
name|SolrDocument
name|doc
init|=
name|client
operator|.
name|getById
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|params
argument_list|(
literal|"distrib"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
literal|"This doc was supposed to have been deleted, but was: "
operator|+
name|doc
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"outOfOrderDeleteUpdatesIndividualReplicaTest: This test passed fine..."
argument_list|)
expr_stmt|;
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
block|}
comment|/* Test for a situation when a document requiring in-place update cannot be "resurrected"    * when the original full indexed document has been deleted by an out of order DBQ.    * Expected behaviour in this case should be to throw the replica into LIR (since this will    * be rare). Here's an example of the situation:         ADD(id=x, val=5, ver=1)         UPD(id=x, val=10, ver = 2)         DBQ(q=val:10, v=4)         DV(id=x, val=5, ver=3)    */
DECL|method|reorderedDBQsWithInPlaceUpdatesShouldNotThrowReplicaInLIRTest
specifier|private
name|void
name|reorderedDBQsWithInPlaceUpdatesShouldNotThrowReplicaInLIRTest
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
name|buildRandomIndex
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SolrDocument
name|sdoc
init|=
name|LEADER
operator|.
name|getById
argument_list|(
literal|"0"
argument_list|)
decl_stmt|;
comment|// RTG straight from the index
comment|//assertEquals(value, sdoc.get("inplace_updatable_float"));
name|assertEquals
argument_list|(
literal|"title0"
argument_list|,
name|sdoc
operator|.
name|get
argument_list|(
literal|"title_s"
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|version0
init|=
operator|(
name|long
operator|)
name|sdoc
operator|.
name|get
argument_list|(
literal|"_version_"
argument_list|)
decl_stmt|;
name|String
name|field
init|=
literal|"inplace_updatable_int"
decl_stmt|;
comment|// put replica out of sync
name|List
argument_list|<
name|UpdateRequest
argument_list|>
name|updates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|simulatedUpdateRequest
argument_list|(
literal|null
argument_list|,
literal|"id"
argument_list|,
literal|0
argument_list|,
literal|"title_s"
argument_list|,
literal|"title0_new"
argument_list|,
name|field
argument_list|,
literal|5
argument_list|,
literal|"_version_"
argument_list|,
name|version0
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// full update
name|updates
operator|.
name|add
argument_list|(
name|simulatedUpdateRequest
argument_list|(
name|version0
operator|+
literal|1
argument_list|,
literal|"id"
argument_list|,
literal|0
argument_list|,
name|field
argument_list|,
literal|10
argument_list|,
literal|"_version_"
argument_list|,
name|version0
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// inplace_updatable_float=101
name|updates
operator|.
name|add
argument_list|(
name|simulatedUpdateRequest
argument_list|(
name|version0
operator|+
literal|2
argument_list|,
literal|"id"
argument_list|,
literal|0
argument_list|,
name|field
argument_list|,
literal|5
argument_list|,
literal|"_version_"
argument_list|,
name|version0
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|// inplace_updatable_float=101
name|updates
operator|.
name|add
argument_list|(
name|simulatedDeleteRequest
argument_list|(
name|field
operator|+
literal|":10"
argument_list|,
name|version0
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|// supposed to not delete anything
comment|// order the updates correctly for NONLEADER 1
for|for
control|(
name|UpdateRequest
name|update
range|:
name|updates
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Issuing well ordered update: "
operator|+
name|update
operator|.
name|getDocuments
argument_list|()
argument_list|)
expr_stmt|;
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|request
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
comment|// Reordering needs to happen using parallel threads
name|ExecutorService
name|threadpool
init|=
name|ExecutorUtil
operator|.
name|newMDCAwareFixedThreadPool
argument_list|(
name|updates
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
operator|new
name|DefaultSolrThreadFactory
argument_list|(
name|getTestName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// re-order the last two updates for NONLEADER 0
name|List
argument_list|<
name|UpdateRequest
argument_list|>
name|reorderedUpdates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|updates
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|swap
argument_list|(
name|reorderedUpdates
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Future
argument_list|<
name|UpdateResponse
argument_list|>
argument_list|>
name|updateResponses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateRequest
name|update
range|:
name|reorderedUpdates
control|)
block|{
comment|// pretend as this update is coming from the other non-leader, so that
comment|// the resurrection can happen from there (instead of the leader)
name|update
operator|.
name|setParam
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|DISTRIB_FROM
argument_list|,
operator|(
operator|(
name|HttpSolrClient
operator|)
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getBaseURL
argument_list|()
argument_list|)
expr_stmt|;
name|AsyncUpdateWithRandomCommit
name|task
init|=
operator|new
name|AsyncUpdateWithRandomCommit
argument_list|(
name|update
argument_list|,
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
name|updateResponses
operator|.
name|add
argument_list|(
name|threadpool
operator|.
name|submit
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
comment|// while we can't guarantee/trust what order the updates are executed in, since multiple threads
comment|// are involved, but we're trying to bias the thread scheduling to run them in the order submitted
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|threadpool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Thread pool didn't terminate within 10 secs"
argument_list|,
name|threadpool
operator|.
name|awaitTermination
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|successful
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Future
argument_list|<
name|UpdateResponse
argument_list|>
name|resp
range|:
name|updateResponses
control|)
block|{
try|try
block|{
name|UpdateResponse
name|r
init|=
name|resp
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|getStatus
argument_list|()
operator|==
literal|0
condition|)
block|{
name|successful
operator|++
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
comment|// reordered DBQ should trigger an error, thus throwing the replica into LIR.
comment|// the cause of the error is that the full document was deleted by mistake due to the
comment|// out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to
comment|// arrive before) cannot be applied, since the full document can't now be "resurrected".
if|if
condition|(
operator|!
name|ex
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Tried to fetch missing update"
operator|+
literal|" from the leader, but missing wasn't present at leader."
argument_list|)
condition|)
block|{
throw|throw
name|ex
throw|;
block|}
block|}
block|}
comment|// All should succeed, i.e. no LIR
name|assertEquals
argument_list|(
name|updateResponses
operator|.
name|size
argument_list|()
argument_list|,
name|successful
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Non leader 0: "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getBaseURL
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Non leader 1: "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getBaseURL
argument_list|()
argument_list|)
expr_stmt|;
name|SolrDocument
name|doc0
init|=
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getById
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|params
argument_list|(
literal|"distrib"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
name|SolrDocument
name|doc1
init|=
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getById
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|params
argument_list|(
literal|"distrib"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Doc in both replica 0: "
operator|+
name|doc0
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Doc in both replica 1: "
operator|+
name|doc1
argument_list|)
expr_stmt|;
comment|// assert both replicas have same effect
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NONLEADERS
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// 0th is re-ordered replica, 1st is well-ordered replica
name|SolrClient
name|client
init|=
name|NONLEADERS
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|SolrDocument
name|doc
init|=
name|client
operator|.
name|getById
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|params
argument_list|(
literal|"distrib"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Client: "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|client
operator|)
operator|.
name|getBaseURL
argument_list|()
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Client: "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|client
operator|)
operator|.
name|getBaseURL
argument_list|()
argument_list|,
literal|5
argument_list|,
name|doc
operator|.
name|getFieldValue
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"reorderedDBQsWithInPlaceUpdatesShouldNotThrowReplicaInLIRTest: This test passed fine..."
argument_list|)
expr_stmt|;
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
block|}
DECL|method|delayedReorderingFetchesMissingUpdateFromLeaderTest
specifier|private
name|void
name|delayedReorderingFetchesMissingUpdateFromLeaderTest
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
name|float
name|inplace_updatable_float
init|=
literal|1F
decl_stmt|;
name|buildRandomIndex
argument_list|(
name|inplace_updatable_float
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|float
name|newinplace_updatable_float
init|=
literal|100F
decl_stmt|;
name|List
argument_list|<
name|UpdateRequest
argument_list|>
name|updates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|regularUpdateRequest
argument_list|(
literal|"id"
argument_list|,
literal|1
argument_list|,
literal|"title_s"
argument_list|,
literal|"title1_new"
argument_list|,
literal|"id_i"
argument_list|,
literal|1
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|newinplace_updatable_float
argument_list|)
argument_list|)
expr_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|regularUpdateRequest
argument_list|(
literal|"id"
argument_list|,
literal|1
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|regularUpdateRequest
argument_list|(
literal|"id"
argument_list|,
literal|1
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// The next request to replica2 will be delayed by 6 secs (timeout is 5s)
name|shardToJetty
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|jetty
operator|.
name|getDebugFilter
argument_list|()
operator|.
name|addDelay
argument_list|(
literal|"Waiting for dependant update to timeout"
argument_list|,
literal|1
argument_list|,
literal|6000
argument_list|)
expr_stmt|;
name|ExecutorService
name|threadpool
init|=
name|ExecutorUtil
operator|.
name|newMDCAwareFixedThreadPool
argument_list|(
name|updates
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
operator|new
name|DefaultSolrThreadFactory
argument_list|(
name|getTestName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|UpdateRequest
name|update
range|:
name|updates
control|)
block|{
name|AsyncUpdateWithRandomCommit
name|task
init|=
operator|new
name|AsyncUpdateWithRandomCommit
argument_list|(
name|update
argument_list|,
name|cloudClient
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
name|threadpool
operator|.
name|submit
argument_list|(
name|task
argument_list|)
expr_stmt|;
comment|// while we can't guarantee/trust what order the updates are executed in, since multiple threads
comment|// are involved, but we're trying to bias the thread scheduling to run them in the order submitted
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|threadpool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Thread pool didn't terminate within 10 secs"
argument_list|,
name|threadpool
operator|.
name|awaitTermination
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
comment|// TODO: Could try checking ZK for LIR flags to ensure LIR has not kicked in
comment|// Check every 10ms, 100 times, for a replica to go down (& assert that it doesn't)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|forceUpdateCollection
argument_list|(
name|DEFAULT_COLLECTION
argument_list|)
expr_stmt|;
name|ClusterState
name|state
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|int
name|numActiveReplicas
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Replica
name|rep
range|:
name|state
operator|.
name|getCollection
argument_list|(
name|DEFAULT_COLLECTION
argument_list|)
operator|.
name|getSlice
argument_list|(
name|SHARD1
argument_list|)
operator|.
name|getReplicas
argument_list|()
control|)
if|if
condition|(
name|rep
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|Replica
operator|.
name|State
operator|.
name|ACTIVE
argument_list|)
condition|)
name|numActiveReplicas
operator|++
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The replica receiving reordered updates must not have gone down"
argument_list|,
literal|3
argument_list|,
name|numActiveReplicas
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SolrClient
name|client
range|:
name|clients
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing client (Fetch missing test): "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|client
operator|)
operator|.
name|getBaseURL
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Version at "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|client
operator|)
operator|.
name|getBaseURL
argument_list|()
operator|+
literal|" is: "
operator|+
name|getReplicaValue
argument_list|(
name|client
argument_list|,
literal|1
argument_list|,
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
name|assertReplicaValue
argument_list|(
name|client
argument_list|,
literal|1
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
operator|(
name|newinplace_updatable_float
operator|+
literal|2.0f
operator|)
argument_list|,
literal|"inplace_updatable_float didn't match for replica at client: "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|client
operator|)
operator|.
name|getBaseURL
argument_list|()
argument_list|)
expr_stmt|;
name|assertReplicaValue
argument_list|(
name|client
argument_list|,
literal|1
argument_list|,
literal|"title_s"
argument_list|,
literal|"title1_new"
argument_list|,
literal|"Title didn't match for replica at client: "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|client
operator|)
operator|.
name|getBaseURL
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Try another round of these updates, this time with a delete request at the end.
comment|// This is to ensure that the fetch missing update from leader doesn't bomb out if the
comment|// document has been deleted on the leader later on
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
name|shardToJetty
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|jetty
operator|.
name|getDebugFilter
argument_list|()
operator|.
name|unsetDelay
argument_list|()
expr_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|regularDeleteRequest
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|shardToJetty
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|jetty
operator|.
name|getDebugFilter
argument_list|()
operator|.
name|addDelay
argument_list|(
literal|"Waiting for dependant update to timeout"
argument_list|,
literal|1
argument_list|,
literal|5999
argument_list|)
expr_stmt|;
comment|// the first update
name|shardToJetty
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|jetty
operator|.
name|getDebugFilter
argument_list|()
operator|.
name|addDelay
argument_list|(
literal|"Waiting for dependant update to timeout"
argument_list|,
literal|4
argument_list|,
literal|5998
argument_list|)
expr_stmt|;
comment|// the delete update
name|threadpool
operator|=
name|ExecutorUtil
operator|.
name|newMDCAwareFixedThreadPool
argument_list|(
name|updates
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
operator|new
name|DefaultSolrThreadFactory
argument_list|(
name|getTestName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|UpdateRequest
name|update
range|:
name|updates
control|)
block|{
name|AsyncUpdateWithRandomCommit
name|task
init|=
operator|new
name|AsyncUpdateWithRandomCommit
argument_list|(
name|update
argument_list|,
name|cloudClient
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
name|threadpool
operator|.
name|submit
argument_list|(
name|task
argument_list|)
expr_stmt|;
comment|// while we can't guarantee/trust what order the updates are executed in, since multiple threads
comment|// are involved, but we're trying to bias the thread scheduling to run them in the order submitted
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|threadpool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Thread pool didn't terminate within 15 secs"
argument_list|,
name|threadpool
operator|.
name|awaitTermination
argument_list|(
literal|15
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
comment|// TODO: Could try checking ZK for LIR flags to ensure LIR has not kicked in
comment|// Check every 10ms, 100 times, for a replica to go down (& assert that it doesn't)
name|ZkController
name|zkController
init|=
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
operator|.
name|jetty
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|getZkController
argument_list|()
decl_stmt|;
name|String
name|lirPath
init|=
name|zkController
operator|.
name|getLeaderInitiatedRecoveryZnodePath
argument_list|(
name|DEFAULT_TEST_COLLECTION_NAME
argument_list|,
name|SHARD1
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|zkController
operator|.
name|getZkClient
argument_list|()
operator|.
name|exists
argument_list|(
name|lirPath
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|forceUpdateCollection
argument_list|(
name|DEFAULT_COLLECTION
argument_list|)
expr_stmt|;
name|ClusterState
name|state
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|int
name|numActiveReplicas
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Replica
name|rep
range|:
name|state
operator|.
name|getCollection
argument_list|(
name|DEFAULT_COLLECTION
argument_list|)
operator|.
name|getSlice
argument_list|(
name|SHARD1
argument_list|)
operator|.
name|getReplicas
argument_list|()
control|)
if|if
condition|(
name|rep
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|Replica
operator|.
name|State
operator|.
name|ACTIVE
argument_list|)
condition|)
name|numActiveReplicas
operator|++
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The replica receiving reordered updates must not have gone down"
argument_list|,
literal|3
argument_list|,
name|numActiveReplicas
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SolrClient
name|client
range|:
operator|new
name|SolrClient
index|[]
block|{
name|LEADER
block|,
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|0
argument_list|)
block|,
name|NONLEADERS
operator|.
name|get
argument_list|(
literal|1
argument_list|)
block|}
control|)
block|{
comment|// nonleader 0 re-ordered replica, nonleader 1 well-ordered replica
name|SolrDocument
name|doc
init|=
name|client
operator|.
name|getById
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|)
argument_list|,
name|params
argument_list|(
literal|"distrib"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
literal|"This doc was supposed to have been deleted, but was: "
operator|+
name|doc
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"delayedReorderingFetchesMissingUpdateFromLeaderTest: This test passed fine..."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Use the schema API to verify that the specified expected Field exists with those exact attributes.     */
DECL|method|checkExpectedSchemaField
specifier|public
name|void
name|checkExpectedSchemaField
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|expected
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|fieldName
init|=
operator|(
name|String
operator|)
name|expected
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"expected contains no name: "
operator|+
name|expected
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
name|FieldResponse
name|rsp
init|=
operator|new
name|Field
argument_list|(
name|fieldName
argument_list|)
operator|.
name|process
argument_list|(
name|this
operator|.
name|cloudClient
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Field Null Response: "
operator|+
name|fieldName
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Field Status: "
operator|+
name|fieldName
operator|+
literal|" => "
operator|+
name|rsp
operator|.
name|toString
argument_list|()
argument_list|,
literal|0
argument_list|,
name|rsp
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Field: "
operator|+
name|fieldName
argument_list|,
name|expected
argument_list|,
name|rsp
operator|.
name|getField
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|class|AsyncUpdateWithRandomCommit
specifier|private
specifier|static
class|class
name|AsyncUpdateWithRandomCommit
implements|implements
name|Callable
argument_list|<
name|UpdateResponse
argument_list|>
block|{
DECL|field|update
name|UpdateRequest
name|update
decl_stmt|;
DECL|field|solrClient
name|SolrClient
name|solrClient
decl_stmt|;
DECL|field|rnd
specifier|final
name|Random
name|rnd
decl_stmt|;
DECL|method|AsyncUpdateWithRandomCommit
specifier|public
name|AsyncUpdateWithRandomCommit
parameter_list|(
name|UpdateRequest
name|update
parameter_list|,
name|SolrClient
name|solrClient
parameter_list|,
name|long
name|seed
parameter_list|)
block|{
name|this
operator|.
name|update
operator|=
name|update
expr_stmt|;
name|this
operator|.
name|solrClient
operator|=
name|solrClient
expr_stmt|;
name|this
operator|.
name|rnd
operator|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call
specifier|public
name|UpdateResponse
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|UpdateResponse
name|resp
init|=
name|update
operator|.
name|process
argument_list|(
name|solrClient
argument_list|)
decl_stmt|;
comment|//solrClient.request(update);
if|if
condition|(
name|rnd
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|solrClient
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|resp
return|;
block|}
block|}
DECL|method|getReplicaValue
name|Object
name|getReplicaValue
parameter_list|(
name|SolrClient
name|client
parameter_list|,
name|int
name|doc
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|SolrDocument
name|sdoc
init|=
name|client
operator|.
name|getById
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|doc
argument_list|)
argument_list|,
name|params
argument_list|(
literal|"distrib"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|sdoc
operator|==
literal|null
condition|?
literal|null
else|:
name|sdoc
operator|.
name|get
argument_list|(
name|field
argument_list|)
return|;
block|}
DECL|method|assertReplicaValue
name|void
name|assertReplicaValue
parameter_list|(
name|SolrClient
name|client
parameter_list|,
name|int
name|doc
parameter_list|,
name|String
name|field
parameter_list|,
name|Object
name|expected
parameter_list|,
name|String
name|message
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|assertEquals
argument_list|(
name|message
argument_list|,
name|expected
argument_list|,
name|getReplicaValue
argument_list|(
name|client
argument_list|,
name|doc
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// This returns an UpdateRequest with the given fields that represent a document.
comment|// This request is constructed such that it is a simulation of a request coming from
comment|// a leader to a replica.
DECL|method|simulatedUpdateRequest
name|UpdateRequest
name|simulatedUpdateRequest
parameter_list|(
name|Long
name|prevVersion
parameter_list|,
name|Object
modifier|...
name|fields
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|SolrInputDocument
name|doc
init|=
name|sdoc
argument_list|(
name|fields
argument_list|)
decl_stmt|;
comment|// get baseUrl of the leader
name|String
name|baseUrl
init|=
name|getBaseUrl
argument_list|(
name|doc
operator|.
name|get
argument_list|(
literal|"id"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|UpdateRequest
name|ur
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
name|ur
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|ur
operator|.
name|setParam
argument_list|(
literal|"update.distrib"
argument_list|,
literal|"FROMLEADER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevVersion
operator|!=
literal|null
condition|)
block|{
name|ur
operator|.
name|setParam
argument_list|(
literal|"distrib.inplace.prevversion"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|prevVersion
argument_list|)
argument_list|)
expr_stmt|;
name|ur
operator|.
name|setParam
argument_list|(
literal|"distrib.inplace.update"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
name|ur
operator|.
name|setParam
argument_list|(
literal|"distrib.from"
argument_list|,
name|baseUrl
argument_list|)
expr_stmt|;
return|return
name|ur
return|;
block|}
DECL|method|simulatedDeleteRequest
name|UpdateRequest
name|simulatedDeleteRequest
parameter_list|(
name|int
name|id
parameter_list|,
name|long
name|version
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|String
name|baseUrl
init|=
name|getBaseUrl
argument_list|(
literal|""
operator|+
name|id
argument_list|)
decl_stmt|;
name|UpdateRequest
name|ur
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|ur
operator|.
name|deleteById
argument_list|(
literal|""
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ur
operator|.
name|deleteByQuery
argument_list|(
literal|"id:"
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
name|ur
operator|.
name|setParam
argument_list|(
literal|"_version_"
argument_list|,
literal|""
operator|+
name|version
argument_list|)
expr_stmt|;
name|ur
operator|.
name|setParam
argument_list|(
literal|"update.distrib"
argument_list|,
literal|"FROMLEADER"
argument_list|)
expr_stmt|;
name|ur
operator|.
name|setParam
argument_list|(
literal|"distrib.from"
argument_list|,
name|baseUrl
argument_list|)
expr_stmt|;
return|return
name|ur
return|;
block|}
DECL|method|simulatedDeleteRequest
name|UpdateRequest
name|simulatedDeleteRequest
parameter_list|(
name|String
name|query
parameter_list|,
name|long
name|version
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|String
name|baseUrl
init|=
name|getBaseUrl
argument_list|(
operator|(
name|HttpSolrClient
operator|)
name|LEADER
argument_list|)
decl_stmt|;
name|UpdateRequest
name|ur
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
name|ur
operator|.
name|deleteByQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|ur
operator|.
name|setParam
argument_list|(
literal|"_version_"
argument_list|,
literal|""
operator|+
name|version
argument_list|)
expr_stmt|;
name|ur
operator|.
name|setParam
argument_list|(
literal|"update.distrib"
argument_list|,
literal|"FROMLEADER"
argument_list|)
expr_stmt|;
name|ur
operator|.
name|setParam
argument_list|(
literal|"distrib.from"
argument_list|,
name|baseUrl
operator|+
name|DEFAULT_COLLECTION
operator|+
literal|"/"
argument_list|)
expr_stmt|;
return|return
name|ur
return|;
block|}
DECL|method|getBaseUrl
specifier|private
name|String
name|getBaseUrl
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|DocCollection
name|collection
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
operator|.
name|getCollection
argument_list|(
name|DEFAULT_COLLECTION
argument_list|)
decl_stmt|;
name|Slice
name|slice
init|=
name|collection
operator|.
name|getRouter
argument_list|()
operator|.
name|getTargetSlice
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|collection
argument_list|)
decl_stmt|;
name|String
name|baseUrl
init|=
name|slice
operator|.
name|getLeader
argument_list|()
operator|.
name|getCoreUrl
argument_list|()
decl_stmt|;
return|return
name|baseUrl
return|;
block|}
DECL|method|regularUpdateRequest
name|UpdateRequest
name|regularUpdateRequest
parameter_list|(
name|Object
modifier|...
name|fields
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|UpdateRequest
name|ur
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
name|SolrInputDocument
name|doc
init|=
name|sdoc
argument_list|(
name|fields
argument_list|)
decl_stmt|;
name|ur
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
return|return
name|ur
return|;
block|}
DECL|method|regularDeleteRequest
name|UpdateRequest
name|regularDeleteRequest
parameter_list|(
name|int
name|id
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|UpdateRequest
name|ur
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
name|ur
operator|.
name|deleteById
argument_list|(
literal|""
operator|+
name|id
argument_list|)
expr_stmt|;
return|return
name|ur
return|;
block|}
DECL|method|regularDeleteByQueryRequest
name|UpdateRequest
name|regularDeleteByQueryRequest
parameter_list|(
name|String
name|q
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|UpdateRequest
name|ur
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
name|ur
operator|.
name|deleteByQuery
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|ur
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
DECL|method|addDocAndGetVersion
specifier|protected
name|long
name|addDocAndGetVersion
parameter_list|(
name|Object
modifier|...
name|fields
parameter_list|)
throws|throws
name|Exception
block|{
name|SolrInputDocument
name|doc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
name|addFields
argument_list|(
name|doc
argument_list|,
name|fields
argument_list|)
expr_stmt|;
name|UpdateRequest
name|ureq
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
name|ureq
operator|.
name|setParam
argument_list|(
literal|"versions"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|ureq
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|UpdateResponse
name|resp
decl_stmt|;
comment|// send updates to leader, to avoid SOLR-8733
name|resp
operator|=
name|ureq
operator|.
name|process
argument_list|(
name|LEADER
argument_list|)
expr_stmt|;
name|long
name|returnedVersion
init|=
name|Long
operator|.
name|parseLong
argument_list|(
operator|(
operator|(
name|NamedList
operator|)
name|resp
operator|.
name|getResponse
argument_list|()
operator|.
name|get
argument_list|(
literal|"adds"
argument_list|)
operator|)
operator|.
name|getVal
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Due to SOLR-8733, sometimes returned version is 0. Let us assert that we have successfully"
operator|+
literal|" worked around that problem here."
argument_list|,
name|returnedVersion
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|returnedVersion
return|;
block|}
comment|/**    * Convinience method variant that never uses<code>initFloat</code>    * @see #buildRandomIndex(Float,List)    */
DECL|method|buildRandomIndex
specifier|protected
name|List
argument_list|<
name|Long
argument_list|>
name|buildRandomIndex
parameter_list|(
name|Integer
modifier|...
name|specialIds
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|buildRandomIndex
argument_list|(
literal|null
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|specialIds
argument_list|)
argument_list|)
return|;
block|}
comment|/**     * Helper method to build a randomized index with the fields needed for all test methods in this class.    * At a minimum, this index will contain 1 doc per "special" (non-negative) document id.  These special documents will be added with the<code>initFloat</code> specified in the "inplace_updatable_float" field.    *    * A random number of documents (with negative ids) will be indexed in between each of the     * "special" documents, as well as before/after the first/last special document.    *    * @param initFloat Value to use in the "inplace_updatable_float" for the special documents; will never be used if null    * @param specialIds The ids to use for the special documents, all values must be non-negative    * @return the versions of each of the specials document returned when indexing it    */
DECL|method|buildRandomIndex
specifier|protected
name|List
argument_list|<
name|Long
argument_list|>
name|buildRandomIndex
parameter_list|(
name|Float
name|initFloat
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|specialIds
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|id
init|=
operator|-
literal|1
decl_stmt|;
comment|// used for non special docs
specifier|final
name|int
name|numPreDocs
init|=
name|rarely
argument_list|()
condition|?
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|)
else|:
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numPreDocs
condition|;
name|i
operator|++
control|)
block|{
name|addDocAndGetVersion
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
literal|"title_s"
argument_list|,
literal|"title"
operator|+
name|id
argument_list|,
literal|"id_i"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|id
operator|--
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|Long
argument_list|>
name|versions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|specialIds
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|special
range|:
name|specialIds
control|)
block|{
if|if
condition|(
literal|null
operator|==
name|initFloat
condition|)
block|{
name|versions
operator|.
name|add
argument_list|(
name|addDocAndGetVersion
argument_list|(
literal|"id"
argument_list|,
name|special
argument_list|,
literal|"title_s"
argument_list|,
literal|"title"
operator|+
name|special
argument_list|,
literal|"id_i"
argument_list|,
name|special
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|versions
operator|.
name|add
argument_list|(
name|addDocAndGetVersion
argument_list|(
literal|"id"
argument_list|,
name|special
argument_list|,
literal|"title_s"
argument_list|,
literal|"title"
operator|+
name|special
argument_list|,
literal|"id_i"
argument_list|,
name|special
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|initFloat
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|numPostDocs
init|=
name|rarely
argument_list|()
condition|?
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|)
else|:
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numPostDocs
condition|;
name|i
operator|++
control|)
block|{
name|addDocAndGetVersion
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
literal|"title_s"
argument_list|,
literal|"title"
operator|+
name|id
argument_list|,
literal|"id_i"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|id
operator|--
expr_stmt|;
block|}
block|}
name|LEADER
operator|.
name|commit
argument_list|()
expr_stmt|;
assert|assert
name|specialIds
operator|.
name|size
argument_list|()
operator|==
name|versions
operator|.
name|size
argument_list|()
assert|;
return|return
name|versions
return|;
block|}
comment|/*    * Situation:    * add(id=1,inpfield=12,title=mytitle,version=1)    * inp(id=1,inpfield=13,prevVersion=1,version=2) // timeout indefinitely    * inp(id=1,inpfield=14,prevVersion=2,version=3) // will wait till timeout, and then fetch a "not found" from leader    * dbq("inp:14",version=4)    */
DECL|method|testDBQUsingUpdatedFieldFromDroppedUpdate
specifier|private
name|void
name|testDBQUsingUpdatedFieldFromDroppedUpdate
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
name|float
name|inplace_updatable_float
init|=
literal|1F
decl_stmt|;
name|buildRandomIndex
argument_list|(
name|inplace_updatable_float
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|UpdateRequest
argument_list|>
name|updates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|regularUpdateRequest
argument_list|(
literal|"id"
argument_list|,
literal|1
argument_list|,
literal|"id_i"
argument_list|,
literal|1
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
literal|12
argument_list|,
literal|"title_s"
argument_list|,
literal|"mytitle"
argument_list|)
argument_list|)
expr_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|regularUpdateRequest
argument_list|(
literal|"id"
argument_list|,
literal|1
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// delay indefinitely
name|updates
operator|.
name|add
argument_list|(
name|regularUpdateRequest
argument_list|(
literal|"id"
argument_list|,
literal|1
argument_list|,
literal|"inplace_updatable_float"
argument_list|,
name|map
argument_list|(
literal|"inc"
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|regularDeleteByQueryRequest
argument_list|(
literal|"inplace_updatable_float:14"
argument_list|)
argument_list|)
expr_stmt|;
comment|// The second request will be delayed very very long, so that the next update actually gives up waiting for this
comment|// and fetches a full update from the leader.
name|shardToJetty
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|jetty
operator|.
name|getDebugFilter
argument_list|()
operator|.
name|addDelay
argument_list|(
literal|"Waiting for dependant update to timeout"
argument_list|,
literal|2
argument_list|,
literal|8000
argument_list|)
expr_stmt|;
name|ExecutorService
name|threadpool
init|=
name|ExecutorUtil
operator|.
name|newMDCAwareFixedThreadPool
argument_list|(
name|updates
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
operator|new
name|DefaultSolrThreadFactory
argument_list|(
name|getTestName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|UpdateRequest
name|update
range|:
name|updates
control|)
block|{
name|AsyncUpdateWithRandomCommit
name|task
init|=
operator|new
name|AsyncUpdateWithRandomCommit
argument_list|(
name|update
argument_list|,
name|cloudClient
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
name|threadpool
operator|.
name|submit
argument_list|(
name|task
argument_list|)
expr_stmt|;
comment|// while we can't guarantee/trust what order the updates are executed in, since multiple threads
comment|// are involved, but we're trying to bias the thread scheduling to run them in the order submitted
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|threadpool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Thread pool didn't terminate within 12 secs"
argument_list|,
name|threadpool
operator|.
name|awaitTermination
argument_list|(
literal|12
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
comment|// TODO: Could try checking ZK for LIR flags to ensure LIR has not kicked in
comment|// Check every 10ms, 100 times, for a replica to go down (& assert that it doesn't)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|forceUpdateCollection
argument_list|(
name|DEFAULT_COLLECTION
argument_list|)
expr_stmt|;
name|ClusterState
name|state
init|=
name|cloudClient
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|int
name|numActiveReplicas
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Replica
name|rep
range|:
name|state
operator|.
name|getCollection
argument_list|(
name|DEFAULT_COLLECTION
argument_list|)
operator|.
name|getSlice
argument_list|(
name|SHARD1
argument_list|)
operator|.
name|getReplicas
argument_list|()
control|)
if|if
condition|(
name|rep
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|Replica
operator|.
name|State
operator|.
name|ACTIVE
argument_list|)
condition|)
name|numActiveReplicas
operator|++
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The replica receiving reordered updates must not have gone down"
argument_list|,
literal|3
argument_list|,
name|numActiveReplicas
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SolrClient
name|client
range|:
name|clients
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing client (testDBQUsingUpdatedFieldFromDroppedUpdate): "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|client
operator|)
operator|.
name|getBaseURL
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Version at "
operator|+
operator|(
operator|(
name|HttpSolrClient
operator|)
name|client
operator|)
operator|.
name|getBaseURL
argument_list|()
operator|+
literal|" is: "
operator|+
name|getReplicaValue
argument_list|(
name|client
argument_list|,
literal|1
argument_list|,
literal|"_version_"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|client
operator|.
name|getById
argument_list|(
literal|"1"
argument_list|,
name|params
argument_list|(
literal|"distrib"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"testDBQUsingUpdatedFieldFromDroppedUpdate: This test passed fine..."
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

