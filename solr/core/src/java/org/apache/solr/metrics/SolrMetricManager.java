begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.metrics
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|metrics
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|PatternSyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|Counter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|Gauge
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|Histogram
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|Meter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|Metric
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|MetricFilter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|MetricRegistry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|MetricSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|SharedMetricRegistries
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|Timer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|CoreContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|PluginInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrInfoBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrResourceLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|metrics
operator|.
name|reporters
operator|.
name|solr
operator|.
name|SolrClusterReporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|metrics
operator|.
name|reporters
operator|.
name|solr
operator|.
name|SolrShardReporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This class maintains a repository of named {@link MetricRegistry} instances, and provides several  * helper methods for managing various aspects of metrics reporting:  *<ul>  *<li>registry creation, clearing and removal,</li>  *<li>creation of most common metric implementations,</li>  *<li>management of {@link SolrMetricReporter}-s specific to a named registry.</li>  *</ul>  * {@link MetricRegistry} instances are automatically created when first referenced by name. Similarly,  * instances of {@link Metric} implementations, such as {@link Meter}, {@link Counter}, {@link Timer} and  * {@link Histogram} are automatically created and registered under hierarchical names, in a specified  * registry, when {@link #meter(SolrInfoBean, String, String, String...)} and other similar methods are called.  *<p>This class enforces a common prefix ({@link #REGISTRY_NAME_PREFIX}) in all registry  * names.</p>  *<p>Solr uses several different registries for collecting metrics belonging to different groups, using  * {@link org.apache.solr.core.SolrInfoBean.Group} as the main name of the registry (plus the  * above-mentioned prefix). Instances of {@link SolrMetricManager} are created for each {@link org.apache.solr.core.CoreContainer},  * and most registries are local to each instance, with the exception of two global registries:  *<code>solr.jetty</code> and<code>solr.jvm</code>, which are shared between all {@link org.apache.solr.core.CoreContainer}-s</p>  */
end_comment

begin_class
DECL|class|SolrMetricManager
specifier|public
class|class
name|SolrMetricManager
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Common prefix for all registry names that Solr uses. */
DECL|field|REGISTRY_NAME_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|REGISTRY_NAME_PREFIX
init|=
literal|"solr."
decl_stmt|;
comment|/** Registry name for Jetty-specific metrics. This name is also subject to overrides controlled by    * system properties. This registry is shared between instances of {@link SolrMetricManager}. */
DECL|field|JETTY_REGISTRY
specifier|public
specifier|static
specifier|final
name|String
name|JETTY_REGISTRY
init|=
name|REGISTRY_NAME_PREFIX
operator|+
name|SolrInfoBean
operator|.
name|Group
operator|.
name|jetty
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|/** Registry name for JVM-specific metrics. This name is also subject to overrides controlled by    * system properties. This registry is shared between instances of {@link SolrMetricManager}. */
DECL|field|JVM_REGISTRY
specifier|public
specifier|static
specifier|final
name|String
name|JVM_REGISTRY
init|=
name|REGISTRY_NAME_PREFIX
operator|+
name|SolrInfoBean
operator|.
name|Group
operator|.
name|jvm
operator|.
name|toString
argument_list|()
decl_stmt|;
DECL|field|registries
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|MetricRegistry
argument_list|>
name|registries
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|reporters
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|SolrMetricReporter
argument_list|>
argument_list|>
name|reporters
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|reportersLock
specifier|private
specifier|final
name|Lock
name|reportersLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
DECL|field|swapLock
specifier|private
specifier|final
name|Lock
name|swapLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
DECL|field|DEFAULT_CLOUD_REPORTER_PERIOD
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_CLOUD_REPORTER_PERIOD
init|=
literal|60
decl_stmt|;
DECL|method|SolrMetricManager
specifier|public
name|SolrMetricManager
parameter_list|()
block|{ }
comment|/**    * An implementation of {@link MetricFilter} that selects metrics    * with names that start with one of prefixes.    */
DECL|class|PrefixFilter
specifier|public
specifier|static
class|class
name|PrefixFilter
implements|implements
name|MetricFilter
block|{
DECL|field|prefixes
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|prefixes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|matched
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|matched
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|allMatch
specifier|private
name|boolean
name|allMatch
init|=
literal|false
decl_stmt|;
comment|/**      * Create a filter that uses the provided prefixes.      * @param prefixes prefixes to use, must not be null. If empty then any      *               name will match, if not empty then match on any prefix will      *                 succeed (logical OR).      */
DECL|method|PrefixFilter
specifier|public
name|PrefixFilter
parameter_list|(
name|String
modifier|...
name|prefixes
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|prefixes
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefixes
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|prefixes
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|prefixes
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|prefixes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|allMatch
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|method|PrefixFilter
specifier|public
name|PrefixFilter
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|prefixes
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|prefixes
argument_list|)
expr_stmt|;
name|this
operator|.
name|prefixes
operator|.
name|addAll
argument_list|(
name|prefixes
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|prefixes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|allMatch
operator|=
literal|true
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
name|String
name|name
parameter_list|,
name|Metric
name|metric
parameter_list|)
block|{
if|if
condition|(
name|allMatch
condition|)
block|{
name|matched
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
for|for
control|(
name|String
name|prefix
range|:
name|prefixes
control|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
name|matched
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Return the set of names that matched this filter.      * @return matching names      */
DECL|method|getMatched
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getMatched
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|matched
argument_list|)
return|;
block|}
comment|/**      * Clear the set of names that matched.      */
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|matched
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"PrefixFilter{"
operator|+
literal|"prefixes="
operator|+
name|prefixes
operator|+
literal|'}'
return|;
block|}
block|}
comment|/**    * An implementation of {@link MetricFilter} that selects metrics    * with names that match regular expression patterns.    */
DECL|class|RegexFilter
specifier|public
specifier|static
class|class
name|RegexFilter
implements|implements
name|MetricFilter
block|{
DECL|field|compiledPatterns
specifier|private
specifier|final
name|Set
argument_list|<
name|Pattern
argument_list|>
name|compiledPatterns
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|matched
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|matched
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|allMatch
specifier|private
name|boolean
name|allMatch
init|=
literal|false
decl_stmt|;
comment|/**      * Create a filter that uses the provided prefix.      * @param patterns regex patterns to use, must not be null. If empty then any      *               name will match, if not empty then match on any pattern will      *                 succeed (logical OR).      */
DECL|method|RegexFilter
specifier|public
name|RegexFilter
parameter_list|(
name|String
modifier|...
name|patterns
parameter_list|)
throws|throws
name|PatternSyntaxException
block|{
name|this
argument_list|(
name|patterns
operator|!=
literal|null
condition|?
name|Arrays
operator|.
name|asList
argument_list|(
name|patterns
argument_list|)
else|:
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|RegexFilter
specifier|public
name|RegexFilter
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|patterns
parameter_list|)
throws|throws
name|PatternSyntaxException
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|patterns
argument_list|)
expr_stmt|;
if|if
condition|(
name|patterns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|allMatch
operator|=
literal|true
expr_stmt|;
return|return;
block|}
name|patterns
operator|.
name|forEach
argument_list|(
name|p
lambda|->
block|{
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|compiledPatterns
operator|.
name|add
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|patterns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|allMatch
operator|=
literal|true
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
name|String
name|name
parameter_list|,
name|Metric
name|metric
parameter_list|)
block|{
if|if
condition|(
name|allMatch
condition|)
block|{
name|matched
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
for|for
control|(
name|Pattern
name|p
range|:
name|compiledPatterns
control|)
block|{
if|if
condition|(
name|p
operator|.
name|matcher
argument_list|(
name|name
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|matched
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Return the set of names that matched this filter.      * @return matching names      */
DECL|method|getMatched
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getMatched
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|matched
argument_list|)
return|;
block|}
comment|/**      * Clear the set of names that matched.      */
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|matched
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"RegexFilter{"
operator|+
literal|"compiledPatterns="
operator|+
name|compiledPatterns
operator|+
literal|'}'
return|;
block|}
block|}
DECL|class|OrFilter
specifier|public
specifier|static
class|class
name|OrFilter
implements|implements
name|MetricFilter
block|{
DECL|field|filters
name|List
argument_list|<
name|MetricFilter
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|OrFilter
specifier|public
name|OrFilter
parameter_list|(
name|Collection
argument_list|<
name|MetricFilter
argument_list|>
name|filters
parameter_list|)
block|{
if|if
condition|(
name|filters
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|filters
operator|.
name|addAll
argument_list|(
name|filters
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|OrFilter
specifier|public
name|OrFilter
parameter_list|(
name|MetricFilter
modifier|...
name|filters
parameter_list|)
block|{
if|if
condition|(
name|filters
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|MetricFilter
name|filter
range|:
name|filters
control|)
block|{
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|filters
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
name|String
name|s
parameter_list|,
name|Metric
name|metric
parameter_list|)
block|{
for|for
control|(
name|MetricFilter
name|filter
range|:
name|filters
control|)
block|{
if|if
condition|(
name|filter
operator|.
name|matches
argument_list|(
name|s
argument_list|,
name|metric
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
DECL|class|AndFilter
specifier|public
specifier|static
class|class
name|AndFilter
implements|implements
name|MetricFilter
block|{
DECL|field|filters
name|List
argument_list|<
name|MetricFilter
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|AndFilter
specifier|public
name|AndFilter
parameter_list|(
name|Collection
argument_list|<
name|MetricFilter
argument_list|>
name|filters
parameter_list|)
block|{
if|if
condition|(
name|filters
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|filters
operator|.
name|addAll
argument_list|(
name|filters
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|AndFilter
specifier|public
name|AndFilter
parameter_list|(
name|MetricFilter
modifier|...
name|filters
parameter_list|)
block|{
if|if
condition|(
name|filters
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|MetricFilter
name|filter
range|:
name|filters
control|)
block|{
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|filters
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
name|String
name|s
parameter_list|,
name|Metric
name|metric
parameter_list|)
block|{
for|for
control|(
name|MetricFilter
name|filter
range|:
name|filters
control|)
block|{
if|if
condition|(
operator|!
name|filter
operator|.
name|matches
argument_list|(
name|s
argument_list|,
name|metric
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Return a set of existing registry names.    */
DECL|method|registryNames
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|registryNames
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|registries
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|SharedMetricRegistries
operator|.
name|names
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|/**    * Return set of existing registry names that match a regex pattern    * @param patterns regex patterns. NOTE: users need to make sure that patterns that    *                 don't start with a wildcard use the full registry name starting with    *                 {@link #REGISTRY_NAME_PREFIX}    * @return set of existing registry names where at least one pattern matched.    */
DECL|method|registryNames
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|registryNames
parameter_list|(
name|String
modifier|...
name|patterns
parameter_list|)
throws|throws
name|PatternSyntaxException
block|{
if|if
condition|(
name|patterns
operator|==
literal|null
operator|||
name|patterns
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|registryNames
argument_list|()
return|;
block|}
name|List
argument_list|<
name|Pattern
argument_list|>
name|compiled
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|pattern
range|:
name|patterns
control|)
block|{
name|compiled
operator|.
name|add
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|registryNames
argument_list|(
operator|(
name|Pattern
index|[]
operator|)
name|compiled
operator|.
name|toArray
argument_list|(
operator|new
name|Pattern
index|[
name|compiled
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
DECL|method|registryNames
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|registryNames
parameter_list|(
name|Pattern
modifier|...
name|patterns
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|allNames
init|=
name|registryNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|patterns
operator|==
literal|null
operator|||
name|patterns
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|allNames
return|;
block|}
return|return
name|allNames
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|s
lambda|->
block|{
for|for
control|(
name|Pattern
name|p
range|:
name|patterns
control|)
block|{
if|if
condition|(
name|p
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toSet
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Check for predefined shared registry names. This compares the input name    * with normalized and possibly overriden names of predefined shared registries -    * {@link #JVM_REGISTRY} and {@link #JETTY_REGISTRY}.    * @param registry already normalized and possibly overriden name    * @return true if the name matches one of shared registries    */
DECL|method|isSharedRegistry
specifier|private
specifier|static
name|boolean
name|isSharedRegistry
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
if|if
condition|(
name|overridableRegistryName
argument_list|(
name|JETTY_REGISTRY
argument_list|)
operator|.
name|equals
argument_list|(
name|registry
argument_list|)
operator|||
name|overridableRegistryName
argument_list|(
name|JVM_REGISTRY
argument_list|)
operator|.
name|equals
argument_list|(
name|registry
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Get (or create if not present) a named registry    * @param registry name of the registry    * @return existing or newly created registry    */
DECL|method|registry
specifier|public
name|MetricRegistry
name|registry
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
name|registry
operator|=
name|overridableRegistryName
argument_list|(
name|registry
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSharedRegistry
argument_list|(
name|registry
argument_list|)
condition|)
block|{
return|return
name|SharedMetricRegistries
operator|.
name|getOrCreate
argument_list|(
name|registry
argument_list|)
return|;
block|}
else|else
block|{
name|swapLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getOrCreate
argument_list|(
name|registries
argument_list|,
name|registry
argument_list|)
return|;
block|}
finally|finally
block|{
name|swapLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getOrCreate
specifier|private
specifier|static
name|MetricRegistry
name|getOrCreate
parameter_list|(
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|MetricRegistry
argument_list|>
name|map
parameter_list|,
name|String
name|registry
parameter_list|)
block|{
specifier|final
name|MetricRegistry
name|existing
init|=
name|map
operator|.
name|get
argument_list|(
name|registry
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|==
literal|null
condition|)
block|{
specifier|final
name|MetricRegistry
name|created
init|=
operator|new
name|MetricRegistry
argument_list|()
decl_stmt|;
specifier|final
name|MetricRegistry
name|raced
init|=
name|map
operator|.
name|putIfAbsent
argument_list|(
name|registry
argument_list|,
name|created
argument_list|)
decl_stmt|;
if|if
condition|(
name|raced
operator|==
literal|null
condition|)
block|{
return|return
name|created
return|;
block|}
else|else
block|{
return|return
name|raced
return|;
block|}
block|}
else|else
block|{
return|return
name|existing
return|;
block|}
block|}
comment|/**    * Remove a named registry.    * @param registry name of the registry to remove    */
DECL|method|removeRegistry
specifier|public
name|void
name|removeRegistry
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
comment|// close any reporters for this registry first
name|closeReporters
argument_list|(
name|registry
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// make sure we use a name with prefix, with overrides
name|registry
operator|=
name|overridableRegistryName
argument_list|(
name|registry
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSharedRegistry
argument_list|(
name|registry
argument_list|)
condition|)
block|{
name|SharedMetricRegistries
operator|.
name|remove
argument_list|(
name|registry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|swapLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|registries
operator|.
name|remove
argument_list|(
name|registry
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|swapLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Swap registries. This is useful eg. during    * {@link org.apache.solr.core.SolrCore} rename or swap operations. NOTE:    * this operation is not supported for shared registries.    * @param registry1 source registry    * @param registry2 target registry. Note: when used after core rename the target registry doesn't    *                  exist, so the swap operation will only rename the existing registry without creating    *                  an empty one under the previous name.    */
DECL|method|swapRegistries
specifier|public
name|void
name|swapRegistries
parameter_list|(
name|String
name|registry1
parameter_list|,
name|String
name|registry2
parameter_list|)
block|{
name|registry1
operator|=
name|overridableRegistryName
argument_list|(
name|registry1
argument_list|)
expr_stmt|;
name|registry2
operator|=
name|overridableRegistryName
argument_list|(
name|registry2
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSharedRegistry
argument_list|(
name|registry1
argument_list|)
operator|||
name|isSharedRegistry
argument_list|(
name|registry2
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot swap shared registry: "
operator|+
name|registry1
operator|+
literal|", "
operator|+
name|registry2
argument_list|)
throw|;
block|}
name|swapLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|MetricRegistry
name|from
init|=
name|registries
operator|.
name|get
argument_list|(
name|registry1
argument_list|)
decl_stmt|;
name|MetricRegistry
name|to
init|=
name|registries
operator|.
name|get
argument_list|(
name|registry2
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|to
condition|)
block|{
return|return;
block|}
name|MetricRegistry
name|reg1
init|=
name|registries
operator|.
name|remove
argument_list|(
name|registry1
argument_list|)
decl_stmt|;
name|MetricRegistry
name|reg2
init|=
name|registries
operator|.
name|remove
argument_list|(
name|registry2
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg2
operator|!=
literal|null
condition|)
block|{
name|registries
operator|.
name|put
argument_list|(
name|registry1
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg1
operator|!=
literal|null
condition|)
block|{
name|registries
operator|.
name|put
argument_list|(
name|registry2
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|swapLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Register all metrics in the provided {@link MetricSet}, optionally skipping those that    * already exist.    * @param registry registry name    * @param metrics metric set to register    * @param force if true then already existing metrics with the same name will be replaced.    *                     When false and a metric with the same name already exists an exception    *                     will be thrown.    * @param metricPath (optional) additional top-most metric name path elements    * @throws Exception if a metric with this name already exists.    */
DECL|method|registerAll
specifier|public
name|void
name|registerAll
parameter_list|(
name|String
name|registry
parameter_list|,
name|MetricSet
name|metrics
parameter_list|,
name|boolean
name|force
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
throws|throws
name|Exception
block|{
name|MetricRegistry
name|metricRegistry
init|=
name|registry
argument_list|(
name|registry
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|metricRegistry
init|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Metric
argument_list|>
name|existingMetrics
init|=
name|metricRegistry
operator|.
name|getMetrics
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Metric
argument_list|>
name|entry
range|:
name|metrics
operator|.
name|getMetrics
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|fullName
init|=
name|mkName
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|metricPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|force
operator|&&
name|existingMetrics
operator|.
name|containsKey
argument_list|(
name|fullName
argument_list|)
condition|)
block|{
name|metricRegistry
operator|.
name|remove
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
block|}
name|metricRegistry
operator|.
name|register
argument_list|(
name|fullName
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove all metrics from a specified registry.    * @param registry registry name    */
DECL|method|clearRegistry
specifier|public
name|void
name|clearRegistry
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|removeMatching
argument_list|(
name|MetricFilter
operator|.
name|ALL
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove some metrics from a named registry    * @param registry registry name    * @param metricPath (optional) top-most metric name path elements. If empty then    *        this is equivalent to calling {@link #clearRegistry(String)},    *        otherwise non-empty elements will be joined using dotted notation    *        to form a fully-qualified prefix. Metrics with names that start    *        with the prefix will be removed.    * @return set of metrics names that have been removed.    */
DECL|method|clearMetrics
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|clearMetrics
parameter_list|(
name|String
name|registry
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
name|PrefixFilter
name|filter
decl_stmt|;
if|if
condition|(
name|metricPath
operator|==
literal|null
operator|||
name|metricPath
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|filter
operator|=
operator|new
name|PrefixFilter
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|prefix
init|=
name|MetricRegistry
operator|.
name|name
argument_list|(
literal|""
argument_list|,
name|metricPath
argument_list|)
decl_stmt|;
name|filter
operator|=
operator|new
name|PrefixFilter
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|removeMatching
argument_list|(
name|filter
argument_list|)
expr_stmt|;
return|return
name|filter
operator|.
name|getMatched
argument_list|()
return|;
block|}
comment|/**    * Retrieve matching metrics and their names.    * @param registry registry name.    * @param metricFilter filter (null is equivalent to {@link MetricFilter#ALL}).    * @return map of matching names and metrics    */
DECL|method|getMetrics
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Metric
argument_list|>
name|getMetrics
parameter_list|(
name|String
name|registry
parameter_list|,
name|MetricFilter
name|metricFilter
parameter_list|)
block|{
if|if
condition|(
name|metricFilter
operator|==
literal|null
operator|||
name|metricFilter
operator|==
name|MetricFilter
operator|.
name|ALL
condition|)
block|{
return|return
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|getMetrics
argument_list|()
return|;
block|}
return|return
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|getMetrics
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|entry
lambda|->
name|metricFilter
operator|.
name|matches
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toMap
argument_list|(
name|entry
lambda|->
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
lambda|->
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create or get an existing named {@link Meter}    * @param registry registry name    * @param metricName metric name, either final name or a fully-qualified name    *                   using dotted notation    * @param metricPath (optional) additional top-most metric name path elements    * @return existing or a newly created {@link Meter}    */
DECL|method|meter
specifier|public
name|Meter
name|meter
parameter_list|(
name|SolrInfoBean
name|info
parameter_list|,
name|String
name|registry
parameter_list|,
name|String
name|metricName
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
specifier|final
name|String
name|name
init|=
name|mkName
argument_list|(
name|metricName
argument_list|,
name|metricPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|info
operator|.
name|registerMetricName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|meter
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * Create or get an existing named {@link Timer}    * @param registry registry name    * @param metricName metric name, either final name or a fully-qualified name    *                   using dotted notation    * @param metricPath (optional) additional top-most metric name path elements    * @return existing or a newly created {@link Timer}    */
DECL|method|timer
specifier|public
name|Timer
name|timer
parameter_list|(
name|SolrInfoBean
name|info
parameter_list|,
name|String
name|registry
parameter_list|,
name|String
name|metricName
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
specifier|final
name|String
name|name
init|=
name|mkName
argument_list|(
name|metricName
argument_list|,
name|metricPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|info
operator|.
name|registerMetricName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|timer
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * Create or get an existing named {@link Counter}    * @param registry registry name    * @param metricName metric name, either final name or a fully-qualified name    *                   using dotted notation    * @param metricPath (optional) additional top-most metric name path elements    * @return existing or a newly created {@link Counter}    */
DECL|method|counter
specifier|public
name|Counter
name|counter
parameter_list|(
name|SolrInfoBean
name|info
parameter_list|,
name|String
name|registry
parameter_list|,
name|String
name|metricName
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
specifier|final
name|String
name|name
init|=
name|mkName
argument_list|(
name|metricName
argument_list|,
name|metricPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|info
operator|.
name|registerMetricName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|counter
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * Create or get an existing named {@link Histogram}    * @param registry registry name    * @param metricName metric name, either final name or a fully-qualified name    *                   using dotted notation    * @param metricPath (optional) additional top-most metric name path elements    * @return existing or a newly created {@link Histogram}    */
DECL|method|histogram
specifier|public
name|Histogram
name|histogram
parameter_list|(
name|SolrInfoBean
name|info
parameter_list|,
name|String
name|registry
parameter_list|,
name|String
name|metricName
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
specifier|final
name|String
name|name
init|=
name|mkName
argument_list|(
name|metricName
argument_list|,
name|metricPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|info
operator|.
name|registerMetricName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|histogram
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * Register an instance of {@link Metric}.    * @param registry registry name    * @param metric metric instance    * @param force if true then an already existing metric with the same name will be replaced.    *                     When false and a metric with the same name already exists an exception    *                     will be thrown.    * @param metricName metric name, either final name or a fully-qualified name    *                   using dotted notation    * @param metricPath (optional) additional top-most metric name path elements    */
DECL|method|register
specifier|public
name|void
name|register
parameter_list|(
name|SolrInfoBean
name|info
parameter_list|,
name|String
name|registry
parameter_list|,
name|Metric
name|metric
parameter_list|,
name|boolean
name|force
parameter_list|,
name|String
name|metricName
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
name|MetricRegistry
name|metricRegistry
init|=
name|registry
argument_list|(
name|registry
argument_list|)
decl_stmt|;
name|String
name|fullName
init|=
name|mkName
argument_list|(
name|metricName
argument_list|,
name|metricPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|info
operator|.
name|registerMetricName
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|metricRegistry
init|)
block|{
if|if
condition|(
name|force
operator|&&
name|metricRegistry
operator|.
name|getMetrics
argument_list|()
operator|.
name|containsKey
argument_list|(
name|fullName
argument_list|)
condition|)
block|{
name|metricRegistry
operator|.
name|remove
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
block|}
name|metricRegistry
operator|.
name|register
argument_list|(
name|fullName
argument_list|,
name|metric
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|registerGauge
specifier|public
name|void
name|registerGauge
parameter_list|(
name|SolrInfoBean
name|info
parameter_list|,
name|String
name|registry
parameter_list|,
name|Gauge
argument_list|<
name|?
argument_list|>
name|gauge
parameter_list|,
name|boolean
name|force
parameter_list|,
name|String
name|metricName
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
name|register
argument_list|(
name|info
argument_list|,
name|registry
argument_list|,
name|gauge
argument_list|,
name|force
argument_list|,
name|metricName
argument_list|,
name|metricPath
argument_list|)
expr_stmt|;
block|}
comment|/**    * This method creates a hierarchical name with arbitrary levels of hierarchy    * @param name the final segment of the name, must not be null or empty.    * @param path optional path segments, starting from the top level. Empty or null    *             segments will be skipped.    * @return fully-qualified name using dotted notation, with all valid hierarchy    * segments prepended to the name.    */
DECL|method|mkName
specifier|public
specifier|static
name|String
name|mkName
parameter_list|(
name|String
name|name
parameter_list|,
name|String
modifier|...
name|path
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"name must not be empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|path
operator|==
literal|null
operator|||
name|path
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|name
return|;
block|}
else|else
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|path
control|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
operator|||
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Allows named registries to be renamed using System properties.    * This would be mostly be useful if you want to combine the metrics from a few registries for a single    * reporter.    *<p>For example, in order to collect metrics from related cores in a single registry you could specify    * the following system properties:</p>    *<pre>    *   ... -Dsolr.core.collection1=solr.core.allCollections -Dsolr.core.collection2=solr.core.allCollections    *</pre>    *<b>NOTE:</b> Once a registry is renamed in a way that its metrics are combined with another repository    * it is no longer possible to retrieve the original metrics until this renaming is removed and the Solr    * {@link org.apache.solr.core.SolrInfoBean.Group} of components that reported to that name is restarted.    * @param registry The name of the registry    * @return A potentially overridden (via System properties) registry name    */
DECL|method|overridableRegistryName
specifier|public
specifier|static
name|String
name|overridableRegistryName
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
name|String
name|fqRegistry
init|=
name|enforcePrefix
argument_list|(
name|registry
argument_list|)
decl_stmt|;
return|return
name|enforcePrefix
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|fqRegistry
argument_list|,
name|fqRegistry
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Enforces the leading {@link #REGISTRY_NAME_PREFIX} in a name.    * @param name input name, possibly without the prefix    * @return original name if it contained the prefix, or the    * input name with the prefix prepended.    */
DECL|method|enforcePrefix
specifier|public
specifier|static
name|String
name|enforcePrefix
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|REGISTRY_NAME_PREFIX
argument_list|)
condition|)
block|{
return|return
name|name
return|;
block|}
else|else
block|{
return|return
operator|new
name|StringBuilder
argument_list|(
name|REGISTRY_NAME_PREFIX
argument_list|)
operator|.
name|append
argument_list|(
name|name
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Helper method to construct a properly prefixed registry name based on the group.    * @param group reporting group    * @param names optional child elements of the registry name. If exactly one element is provided    *              and it already contains the required prefix and group name then this value will be used,    *              and the group parameter will be ignored.    * @return fully-qualified and prefixed registry name, with overrides applied.    */
DECL|method|getRegistryName
specifier|public
specifier|static
name|String
name|getRegistryName
parameter_list|(
name|SolrInfoBean
operator|.
name|Group
name|group
parameter_list|,
name|String
modifier|...
name|names
parameter_list|)
block|{
name|String
name|fullName
decl_stmt|;
name|String
name|prefix
init|=
name|REGISTRY_NAME_PREFIX
operator|+
name|group
operator|.
name|toString
argument_list|()
operator|+
literal|"."
decl_stmt|;
comment|// check for existing prefix and group
if|if
condition|(
name|names
operator|!=
literal|null
operator|&&
name|names
operator|.
name|length
operator|>
literal|0
operator|&&
name|names
index|[
literal|0
index|]
operator|!=
literal|null
operator|&&
name|names
index|[
literal|0
index|]
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
comment|// assume the first segment already was expanded
if|if
condition|(
name|names
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|String
index|[]
name|newNames
init|=
operator|new
name|String
index|[
name|names
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|names
argument_list|,
literal|1
argument_list|,
name|newNames
argument_list|,
literal|0
argument_list|,
name|newNames
operator|.
name|length
argument_list|)
expr_stmt|;
name|fullName
operator|=
name|MetricRegistry
operator|.
name|name
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|,
name|newNames
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fullName
operator|=
name|MetricRegistry
operator|.
name|name
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fullName
operator|=
name|MetricRegistry
operator|.
name|name
argument_list|(
name|group
operator|.
name|toString
argument_list|()
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
return|return
name|overridableRegistryName
argument_list|(
name|fullName
argument_list|)
return|;
block|}
comment|// reporter management
comment|/**    * Create and register {@link SolrMetricReporter}-s specific to a {@link org.apache.solr.core.SolrInfoBean.Group}.    * Note: reporters that specify neither "group" nor "registry" attributes are treated as universal -    * they will always be loaded for any group. These two attributes may also contain multiple comma- or    * whitespace-separated values, in which case the reporter will be loaded for any matching value from    * the list. If both attributes are present then only "group" attribute will be processed.    * @param pluginInfos plugin configurations    * @param loader resource loader    * @param tag optional tag for the reporters, to distinguish reporters logically created for different parent    *            component instances.    * @param group selected group, not null    * @param registryNames optional child registry name elements    */
DECL|method|loadReporters
specifier|public
name|void
name|loadReporters
parameter_list|(
name|PluginInfo
index|[]
name|pluginInfos
parameter_list|,
name|SolrResourceLoader
name|loader
parameter_list|,
name|String
name|tag
parameter_list|,
name|SolrInfoBean
operator|.
name|Group
name|group
parameter_list|,
name|String
modifier|...
name|registryNames
parameter_list|)
block|{
if|if
condition|(
name|pluginInfos
operator|==
literal|null
operator|||
name|pluginInfos
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|String
name|registryName
init|=
name|getRegistryName
argument_list|(
name|group
argument_list|,
name|registryNames
argument_list|)
decl_stmt|;
for|for
control|(
name|PluginInfo
name|info
range|:
name|pluginInfos
control|)
block|{
name|String
name|target
init|=
name|info
operator|.
name|attributes
operator|.
name|get
argument_list|(
literal|"group"
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|null
condition|)
block|{
comment|// no "group"
name|target
operator|=
name|info
operator|.
name|attributes
operator|.
name|get
argument_list|(
literal|"registry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|targets
init|=
name|target
operator|.
name|split
argument_list|(
literal|"[\\s,]+"
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|t
range|:
name|targets
control|)
block|{
name|t
operator|=
name|overridableRegistryName
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|registryName
operator|.
name|equals
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
comment|// neither group nor registry specified.
comment|// always register this plugin for all groups and registries
block|}
block|}
else|else
block|{
comment|// check groups
name|String
index|[]
name|targets
init|=
name|target
operator|.
name|split
argument_list|(
literal|"[\\s,]+"
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|t
range|:
name|targets
control|)
block|{
if|if
condition|(
name|group
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
continue|continue;
block|}
block|}
try|try
block|{
name|loadReporter
argument_list|(
name|registryName
argument_list|,
name|loader
argument_list|,
name|info
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Error loading metrics reporter, plugin info: "
operator|+
name|info
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Create and register an instance of {@link SolrMetricReporter}.    * @param registry reporter is associated with this registry    * @param loader loader to use when creating an instance of the reporter    * @param pluginInfo plugin configuration. Plugin "name" and "class" attributes are required.    * @param tag optional tag for the reporter, to distinguish reporters logically created for different parent    *            component instances.    * @return instance of newly created and registered reporter    * @throws Exception if any argument is missing or invalid    */
DECL|method|loadReporter
specifier|public
name|SolrMetricReporter
name|loadReporter
parameter_list|(
name|String
name|registry
parameter_list|,
name|SolrResourceLoader
name|loader
parameter_list|,
name|PluginInfo
name|pluginInfo
parameter_list|,
name|String
name|tag
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|registry
operator|==
literal|null
operator|||
name|pluginInfo
operator|==
literal|null
operator|||
name|pluginInfo
operator|.
name|name
operator|==
literal|null
operator|||
name|pluginInfo
operator|.
name|className
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"loadReporter called with missing arguments: "
operator|+
literal|"registry="
operator|+
name|registry
operator|+
literal|", loader="
operator|+
name|loader
operator|+
literal|", pluginInfo="
operator|+
name|pluginInfo
argument_list|)
throw|;
block|}
comment|// make sure we use a name with prefix, with overrides
name|registry
operator|=
name|overridableRegistryName
argument_list|(
name|registry
argument_list|)
expr_stmt|;
name|SolrMetricReporter
name|reporter
init|=
name|loader
operator|.
name|newInstance
argument_list|(
name|pluginInfo
operator|.
name|className
argument_list|,
name|SolrMetricReporter
operator|.
name|class
argument_list|,
operator|new
name|String
index|[
literal|0
index|]
argument_list|,
operator|new
name|Class
index|[]
block|{
name|SolrMetricManager
operator|.
name|class
block|,
name|String
operator|.
name|class
block|}
argument_list|,
operator|new
name|Object
index|[]
block|{
name|this
block|,
name|registry
block|}
argument_list|)
decl_stmt|;
try|try
block|{
name|reporter
operator|.
name|init
argument_list|(
name|pluginInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"reporter init failed: "
operator|+
name|pluginInfo
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|registerReporter
argument_list|(
name|registry
argument_list|,
name|pluginInfo
operator|.
name|name
argument_list|,
name|tag
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
return|return
name|reporter
return|;
block|}
DECL|method|registerReporter
specifier|private
name|void
name|registerReporter
parameter_list|(
name|String
name|registry
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|tag
parameter_list|,
name|SolrMetricReporter
name|reporter
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
if|if
condition|(
operator|!
name|reportersLock
operator|.
name|tryLock
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Could not obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Interrupted while trying to obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
throw|;
block|}
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|SolrMetricReporter
argument_list|>
name|perRegistry
init|=
name|reporters
operator|.
name|get
argument_list|(
name|registry
argument_list|)
decl_stmt|;
if|if
condition|(
name|perRegistry
operator|==
literal|null
condition|)
block|{
name|perRegistry
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|reporters
operator|.
name|put
argument_list|(
name|registry
argument_list|,
name|perRegistry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tag
operator|!=
literal|null
operator|&&
operator|!
name|tag
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|name
operator|=
name|name
operator|+
literal|"@"
operator|+
name|tag
expr_stmt|;
block|}
name|SolrMetricReporter
name|oldReporter
init|=
name|perRegistry
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldReporter
operator|!=
literal|null
condition|)
block|{
comment|// close it
name|log
operator|.
name|info
argument_list|(
literal|"Replacing existing reporter '"
operator|+
name|name
operator|+
literal|"' in registry '"
operator|+
name|registry
operator|+
literal|"': "
operator|+
name|oldReporter
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|oldReporter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|perRegistry
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reportersLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Close and unregister a named {@link SolrMetricReporter} for a registry.    * @param registry registry name    * @param name reporter name    * @param tag optional tag for the reporter, to distinguish reporters logically created for different parent    *            component instances.    * @return true if a named reporter existed and was closed.    */
DECL|method|closeReporter
specifier|public
name|boolean
name|closeReporter
parameter_list|(
name|String
name|registry
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|tag
parameter_list|)
block|{
comment|// make sure we use a name with prefix, with overrides
name|registry
operator|=
name|overridableRegistryName
argument_list|(
name|registry
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|reportersLock
operator|.
name|tryLock
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Could not obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Interrupted while trying to obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|SolrMetricReporter
argument_list|>
name|perRegistry
init|=
name|reporters
operator|.
name|get
argument_list|(
name|registry
argument_list|)
decl_stmt|;
if|if
condition|(
name|perRegistry
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|tag
operator|!=
literal|null
operator|&&
operator|!
name|tag
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|name
operator|=
name|name
operator|+
literal|"@"
operator|+
name|tag
expr_stmt|;
block|}
name|SolrMetricReporter
name|reporter
init|=
name|perRegistry
operator|.
name|remove
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|reporter
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
name|reporter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Error closing metric reporter, registry="
operator|+
name|registry
operator|+
literal|", name="
operator|+
name|name
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|reportersLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Close and unregister all {@link SolrMetricReporter}-s for a registry.    * @param registry registry name    * @return names of closed reporters    */
DECL|method|closeReporters
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|closeReporters
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
return|return
name|closeReporters
argument_list|(
name|registry
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Close and unregister all {@link SolrMetricReporter}-s for a registry.    * @param registry registry name    * @param tag optional tag for the reporter, to distinguish reporters logically created for different parent    *            component instances.    * @return names of closed reporters    */
DECL|method|closeReporters
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|closeReporters
parameter_list|(
name|String
name|registry
parameter_list|,
name|String
name|tag
parameter_list|)
block|{
comment|// make sure we use a name with prefix, with overrides
name|registry
operator|=
name|overridableRegistryName
argument_list|(
name|registry
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|reportersLock
operator|.
name|tryLock
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Could not obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Interrupted while trying to obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Closing metric reporters for registry="
operator|+
name|registry
operator|+
literal|", tag="
operator|+
name|tag
argument_list|)
expr_stmt|;
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|SolrMetricReporter
argument_list|>
name|perRegistry
init|=
name|reporters
operator|.
name|get
argument_list|(
name|registry
argument_list|)
decl_stmt|;
if|if
condition|(
name|perRegistry
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|perRegistry
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|removed
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|names
operator|.
name|forEach
argument_list|(
name|name
lambda|->
block|{
if|if
condition|(
name|tag
operator|!=
literal|null
operator|&&
operator|!
name|tag
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|name
operator|.
name|endsWith
argument_list|(
literal|"@"
operator|+
name|tag
argument_list|)
condition|)
block|{
return|return;
block|}
name|SolrMetricReporter
name|reporter
init|=
name|perRegistry
operator|.
name|remove
argument_list|(
name|name
argument_list|)
decl_stmt|;
try|try
block|{
name|reporter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception closing reporter "
operator|+
name|reporter
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
name|removed
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed
operator|.
name|size
argument_list|()
operator|==
name|names
operator|.
name|size
argument_list|()
condition|)
block|{
name|reporters
operator|.
name|remove
argument_list|(
name|registry
argument_list|)
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
else|else
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
block|}
finally|finally
block|{
name|reportersLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a map of reporters for a registry. Keys are reporter names, values are reporter instances.    * @param registry registry name    * @return map of reporters and their names, may be empty but never null    */
DECL|method|getReporters
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SolrMetricReporter
argument_list|>
name|getReporters
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
comment|// make sure we use a name with prefix, with overrides
name|registry
operator|=
name|overridableRegistryName
argument_list|(
name|registry
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|reportersLock
operator|.
name|tryLock
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Could not obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Interrupted while trying to obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|SolrMetricReporter
argument_list|>
name|perRegistry
init|=
name|reporters
operator|.
name|get
argument_list|(
name|registry
argument_list|)
decl_stmt|;
if|if
condition|(
name|perRegistry
operator|==
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
else|else
block|{
comment|// defensive copy - the original map may change after we release the lock
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|perRegistry
argument_list|)
argument_list|)
return|;
block|}
block|}
finally|finally
block|{
name|reportersLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|prepareCloudPlugins
specifier|private
name|List
argument_list|<
name|PluginInfo
argument_list|>
name|prepareCloudPlugins
parameter_list|(
name|PluginInfo
index|[]
name|pluginInfos
parameter_list|,
name|String
name|group
parameter_list|,
name|String
name|className
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|defaultAttributes
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|defaultInitArgs
parameter_list|,
name|PluginInfo
name|defaultPlugin
parameter_list|)
block|{
name|List
argument_list|<
name|PluginInfo
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|pluginInfos
operator|==
literal|null
condition|)
block|{
name|pluginInfos
operator|=
operator|new
name|PluginInfo
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
name|PluginInfo
name|info
range|:
name|pluginInfos
control|)
block|{
name|String
name|groupAttr
init|=
name|info
operator|.
name|attributes
operator|.
name|get
argument_list|(
literal|"group"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|group
operator|.
name|equals
argument_list|(
name|groupAttr
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|info
operator|=
name|preparePlugin
argument_list|(
name|info
argument_list|,
name|className
argument_list|,
name|defaultAttributes
argument_list|,
name|defaultInitArgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
operator|&&
name|defaultPlugin
operator|!=
literal|null
condition|)
block|{
name|defaultPlugin
operator|=
name|preparePlugin
argument_list|(
name|defaultPlugin
argument_list|,
name|className
argument_list|,
name|defaultAttributes
argument_list|,
name|defaultInitArgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultPlugin
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|defaultPlugin
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|preparePlugin
specifier|private
name|PluginInfo
name|preparePlugin
parameter_list|(
name|PluginInfo
name|info
parameter_list|,
name|String
name|className
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|defaultAttributes
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|defaultInitArgs
parameter_list|)
block|{
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|classNameAttr
init|=
name|info
operator|.
name|attributes
operator|.
name|get
argument_list|(
literal|"class"
argument_list|)
decl_stmt|;
if|if
condition|(
name|className
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|classNameAttr
operator|!=
literal|null
operator|&&
operator|!
name|className
operator|.
name|equals
argument_list|(
name|classNameAttr
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Conflicting class name attributes, expected "
operator|+
name|className
operator|+
literal|" but was "
operator|+
name|classNameAttr
operator|+
literal|", skipping "
operator|+
name|info
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|attrs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|info
operator|.
name|attributes
argument_list|)
decl_stmt|;
name|defaultAttributes
operator|.
name|forEach
argument_list|(
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{
if|if
condition|(
operator|!
name|attrs
operator|.
name|containsKey
argument_list|(
name|k
argument_list|)
condition|)
block|{
name|attrs
operator|.
name|put
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|put
argument_list|(
literal|"class"
argument_list|,
name|className
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|initArgs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|initArgs
operator|!=
literal|null
condition|)
block|{
name|initArgs
operator|.
name|putAll
argument_list|(
name|info
operator|.
name|initArgs
operator|.
name|asMap
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|defaultInitArgs
operator|.
name|forEach
argument_list|(
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{
if|if
condition|(
operator|!
name|initArgs
operator|.
name|containsKey
argument_list|(
name|k
argument_list|)
condition|)
block|{
name|initArgs
operator|.
name|put
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
operator|new
name|PluginInfo
argument_list|(
name|info
operator|.
name|type
argument_list|,
name|attrs
argument_list|,
operator|new
name|NamedList
argument_list|(
name|initArgs
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|loadShardReporters
specifier|public
name|void
name|loadShardReporters
parameter_list|(
name|PluginInfo
index|[]
name|pluginInfos
parameter_list|,
name|SolrCore
name|core
parameter_list|)
block|{
comment|// don't load for non-cloud cores
if|if
condition|(
name|core
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// prepare default plugin if none present in the config
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|attrs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|attrs
operator|.
name|put
argument_list|(
literal|"name"
argument_list|,
literal|"shardDefault"
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|put
argument_list|(
literal|"group"
argument_list|,
name|SolrInfoBean
operator|.
name|Group
operator|.
name|shard
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|initArgs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|initArgs
operator|.
name|put
argument_list|(
literal|"period"
argument_list|,
name|DEFAULT_CLOUD_REPORTER_PERIOD
argument_list|)
expr_stmt|;
name|String
name|registryName
init|=
name|core
operator|.
name|getCoreMetricManager
argument_list|()
operator|.
name|getRegistryName
argument_list|()
decl_stmt|;
comment|// collect infos and normalize
name|List
argument_list|<
name|PluginInfo
argument_list|>
name|infos
init|=
name|prepareCloudPlugins
argument_list|(
name|pluginInfos
argument_list|,
name|SolrInfoBean
operator|.
name|Group
operator|.
name|shard
operator|.
name|toString
argument_list|()
argument_list|,
name|SolrShardReporter
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|attrs
argument_list|,
name|initArgs
argument_list|,
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|PluginInfo
name|info
range|:
name|infos
control|)
block|{
try|try
block|{
name|SolrMetricReporter
name|reporter
init|=
name|loadReporter
argument_list|(
name|registryName
argument_list|,
name|core
operator|.
name|getResourceLoader
argument_list|()
argument_list|,
name|info
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|core
operator|.
name|hashCode
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
operator|(
operator|(
name|SolrShardReporter
operator|)
name|reporter
operator|)
operator|.
name|setCore
argument_list|(
name|core
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Could not load shard reporter, pluginInfo="
operator|+
name|info
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|loadClusterReporters
specifier|public
name|void
name|loadClusterReporters
parameter_list|(
name|PluginInfo
index|[]
name|pluginInfos
parameter_list|,
name|CoreContainer
name|cc
parameter_list|)
block|{
comment|// don't load for non-cloud instances
if|if
condition|(
operator|!
name|cc
operator|.
name|isZooKeeperAware
argument_list|()
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|attrs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|attrs
operator|.
name|put
argument_list|(
literal|"name"
argument_list|,
literal|"clusterDefault"
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|put
argument_list|(
literal|"group"
argument_list|,
name|SolrInfoBean
operator|.
name|Group
operator|.
name|cluster
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|initArgs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|initArgs
operator|.
name|put
argument_list|(
literal|"period"
argument_list|,
name|DEFAULT_CLOUD_REPORTER_PERIOD
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|PluginInfo
argument_list|>
name|infos
init|=
name|prepareCloudPlugins
argument_list|(
name|pluginInfos
argument_list|,
name|SolrInfoBean
operator|.
name|Group
operator|.
name|cluster
operator|.
name|toString
argument_list|()
argument_list|,
name|SolrClusterReporter
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|attrs
argument_list|,
name|initArgs
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|String
name|registryName
init|=
name|getRegistryName
argument_list|(
name|SolrInfoBean
operator|.
name|Group
operator|.
name|cluster
argument_list|)
decl_stmt|;
for|for
control|(
name|PluginInfo
name|info
range|:
name|infos
control|)
block|{
try|try
block|{
name|SolrMetricReporter
name|reporter
init|=
name|loadReporter
argument_list|(
name|registryName
argument_list|,
name|cc
operator|.
name|getResourceLoader
argument_list|()
argument_list|,
name|info
argument_list|,
literal|null
argument_list|)
decl_stmt|;
operator|(
operator|(
name|SolrClusterReporter
operator|)
name|reporter
operator|)
operator|.
name|setCoreContainer
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Could not load node reporter, pluginInfo="
operator|+
name|info
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

