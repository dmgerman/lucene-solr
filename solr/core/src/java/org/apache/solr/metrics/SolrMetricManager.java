begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.metrics
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|metrics
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|Counter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|Histogram
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|Meter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|Metric
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|MetricFilter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|MetricRegistry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|MetricSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|SharedMetricRegistries
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|Timer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|PluginInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrInfoMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrResourceLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This class maintains a repository of named {@link MetricRegistry} instances, and provides several  * helper methods for managing various aspects of metrics reporting:  *<ul>  *<li>registry creation, clearing and removal,</li>  *<li>creation of most common metric implementations,</li>  *<li>management of {@link SolrMetricReporter}-s specific to a named registry.</li>  *</ul>  * {@link MetricRegistry} instances are automatically created when first referenced by name. Similarly,  * instances of {@link Metric} implementations, such as {@link Meter}, {@link Counter}, {@link Timer} and  * {@link Histogram} are automatically created and registered under hierarchical names, in a specified  * registry, when {@link #meter(String, String, String...)} and other similar methods are called.  *<p>This class enforces a common prefix ({@link #REGISTRY_NAME_PREFIX}) in all registry  * names.</p>  *<p>Solr uses several different registries for collecting metrics belonging to different groups, using  * {@link org.apache.solr.core.SolrInfoMBean.Group} as the main name of the registry (plus the  * above-mentioned prefix). Instances of {@link SolrMetricManager} are created for each {@link org.apache.solr.core.CoreContainer},  * and most registries are local to each instance, with the exception of two global registries:  *<code>solr.jetty</code> and<code>solr.jvm</code>, which are shared between all {@link org.apache.solr.core.CoreContainer}-s</p>  */
end_comment

begin_class
DECL|class|SolrMetricManager
specifier|public
class|class
name|SolrMetricManager
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Common prefix for all registry names that Solr uses. */
DECL|field|REGISTRY_NAME_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|REGISTRY_NAME_PREFIX
init|=
literal|"solr."
decl_stmt|;
comment|/** Registry name for Jetty-specific metrics. This name is also subject to overrides controlled by    * system properties. This registry is shared between instances of {@link SolrMetricManager}. */
DECL|field|JETTY_REGISTRY
specifier|public
specifier|static
specifier|final
name|String
name|JETTY_REGISTRY
init|=
name|REGISTRY_NAME_PREFIX
operator|+
name|SolrInfoMBean
operator|.
name|Group
operator|.
name|jetty
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|/** Registry name for JVM-specific metrics. This name is also subject to overrides controlled by    * system properties. This registry is shared between instances of {@link SolrMetricManager}. */
DECL|field|JVM_REGISTRY
specifier|public
specifier|static
specifier|final
name|String
name|JVM_REGISTRY
init|=
name|REGISTRY_NAME_PREFIX
operator|+
name|SolrInfoMBean
operator|.
name|Group
operator|.
name|jvm
operator|.
name|toString
argument_list|()
decl_stmt|;
DECL|field|registries
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|MetricRegistry
argument_list|>
name|registries
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|reporters
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|SolrMetricReporter
argument_list|>
argument_list|>
name|reporters
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|reportersLock
specifier|private
specifier|final
name|Lock
name|reportersLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
DECL|field|swapLock
specifier|private
specifier|final
name|Lock
name|swapLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
DECL|method|SolrMetricManager
specifier|public
name|SolrMetricManager
parameter_list|()
block|{ }
comment|/**    * An implementation of {@link MetricFilter} that selects metrics    * with names that start with a prefix.    */
DECL|class|PrefixFilter
specifier|public
specifier|static
class|class
name|PrefixFilter
implements|implements
name|MetricFilter
block|{
DECL|field|prefixes
specifier|private
specifier|final
name|String
index|[]
name|prefixes
decl_stmt|;
DECL|field|matched
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|matched
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|allMatch
specifier|private
name|boolean
name|allMatch
init|=
literal|false
decl_stmt|;
comment|/**      * Create a filter that uses the provided prefix.      * @param prefixes prefixes to use, must not be null. If empty then any      *               name will match, if not empty then match on any prefix will      *                 succeed (logical OR).      */
DECL|method|PrefixFilter
specifier|public
name|PrefixFilter
parameter_list|(
name|String
modifier|...
name|prefixes
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|prefixes
argument_list|)
expr_stmt|;
name|this
operator|.
name|prefixes
operator|=
name|prefixes
expr_stmt|;
if|if
condition|(
name|prefixes
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|allMatch
operator|=
literal|true
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
name|String
name|name
parameter_list|,
name|Metric
name|metric
parameter_list|)
block|{
if|if
condition|(
name|allMatch
condition|)
block|{
name|matched
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
for|for
control|(
name|String
name|prefix
range|:
name|prefixes
control|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
name|matched
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Return the set of names that matched this filter.      * @return matching names      */
DECL|method|getMatched
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getMatched
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|matched
argument_list|)
return|;
block|}
comment|/**      * Clear the set of names that matched.      */
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|matched
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Return a set of existing registry names.    */
DECL|method|registryNames
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|registryNames
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|registries
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|SharedMetricRegistries
operator|.
name|names
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|set
argument_list|)
return|;
block|}
comment|/**    * Check for predefined shared registry names. This compares the input name    * with normalized and possibly overriden names of predefined shared registries -    * {@link #JVM_REGISTRY} and {@link #JETTY_REGISTRY}.    * @param registry already normalized and possibly overriden name    * @return true if the name matches one of shared registries    */
DECL|method|isSharedRegistry
specifier|private
specifier|static
name|boolean
name|isSharedRegistry
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
if|if
condition|(
name|overridableRegistryName
argument_list|(
name|JETTY_REGISTRY
argument_list|)
operator|.
name|equals
argument_list|(
name|registry
argument_list|)
operator|||
name|overridableRegistryName
argument_list|(
name|JVM_REGISTRY
argument_list|)
operator|.
name|equals
argument_list|(
name|registry
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Get (or create if not present) a named registry    * @param registry name of the registry    * @return existing or newly created registry    */
DECL|method|registry
specifier|public
name|MetricRegistry
name|registry
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
name|registry
operator|=
name|overridableRegistryName
argument_list|(
name|registry
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSharedRegistry
argument_list|(
name|registry
argument_list|)
condition|)
block|{
return|return
name|SharedMetricRegistries
operator|.
name|getOrCreate
argument_list|(
name|registry
argument_list|)
return|;
block|}
else|else
block|{
name|swapLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getOrCreate
argument_list|(
name|registries
argument_list|,
name|registry
argument_list|)
return|;
block|}
finally|finally
block|{
name|swapLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getOrCreate
specifier|private
specifier|static
name|MetricRegistry
name|getOrCreate
parameter_list|(
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|MetricRegistry
argument_list|>
name|map
parameter_list|,
name|String
name|registry
parameter_list|)
block|{
specifier|final
name|MetricRegistry
name|existing
init|=
name|map
operator|.
name|get
argument_list|(
name|registry
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|==
literal|null
condition|)
block|{
specifier|final
name|MetricRegistry
name|created
init|=
operator|new
name|MetricRegistry
argument_list|()
decl_stmt|;
specifier|final
name|MetricRegistry
name|raced
init|=
name|map
operator|.
name|putIfAbsent
argument_list|(
name|registry
argument_list|,
name|created
argument_list|)
decl_stmt|;
if|if
condition|(
name|raced
operator|==
literal|null
condition|)
block|{
return|return
name|created
return|;
block|}
else|else
block|{
return|return
name|raced
return|;
block|}
block|}
else|else
block|{
return|return
name|existing
return|;
block|}
block|}
comment|/**    * Remove a named registry.    * @param registry name of the registry to remove    */
DECL|method|removeRegistry
specifier|public
name|void
name|removeRegistry
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
comment|// close any reporters for this registry first
name|closeReporters
argument_list|(
name|registry
argument_list|)
expr_stmt|;
comment|// make sure we use a name with prefix, with overrides
name|registry
operator|=
name|overridableRegistryName
argument_list|(
name|registry
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSharedRegistry
argument_list|(
name|registry
argument_list|)
condition|)
block|{
name|SharedMetricRegistries
operator|.
name|remove
argument_list|(
name|registry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|swapLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|registries
operator|.
name|remove
argument_list|(
name|registry
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|swapLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Swap registries. This is useful eg. during    * {@link org.apache.solr.core.SolrCore} rename or swap operations. NOTE:    * this operation is not supported for shared registries.    * @param registry1 source registry    * @param registry2 target registry. Note: when used after core rename the target registry doesn't    *                  exist, so the swap operation will only rename the existing registry without creating    *                  an empty one under the previous name.    */
DECL|method|swapRegistries
specifier|public
name|void
name|swapRegistries
parameter_list|(
name|String
name|registry1
parameter_list|,
name|String
name|registry2
parameter_list|)
block|{
name|registry1
operator|=
name|overridableRegistryName
argument_list|(
name|registry1
argument_list|)
expr_stmt|;
name|registry2
operator|=
name|overridableRegistryName
argument_list|(
name|registry2
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSharedRegistry
argument_list|(
name|registry1
argument_list|)
operator|||
name|isSharedRegistry
argument_list|(
name|registry2
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot swap shared registry: "
operator|+
name|registry1
operator|+
literal|", "
operator|+
name|registry2
argument_list|)
throw|;
block|}
name|swapLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|MetricRegistry
name|from
init|=
name|registries
operator|.
name|get
argument_list|(
name|registry1
argument_list|)
decl_stmt|;
name|MetricRegistry
name|to
init|=
name|registries
operator|.
name|get
argument_list|(
name|registry2
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|to
condition|)
block|{
return|return;
block|}
name|MetricRegistry
name|reg1
init|=
name|registries
operator|.
name|remove
argument_list|(
name|registry1
argument_list|)
decl_stmt|;
name|MetricRegistry
name|reg2
init|=
name|registries
operator|.
name|remove
argument_list|(
name|registry2
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg2
operator|!=
literal|null
condition|)
block|{
name|registries
operator|.
name|put
argument_list|(
name|registry1
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg1
operator|!=
literal|null
condition|)
block|{
name|registries
operator|.
name|put
argument_list|(
name|registry2
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|swapLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Register all metrics in the provided {@link MetricSet}, optionally skipping those that    * already exist.    * @param registry registry name    * @param metrics metric set to register    * @param force if true then already existing metrics with the same name will be replaced.    *                     When false and a metric with the same name already exists an exception    *                     will be thrown.    * @param metricPath (optional) additional top-most metric name path elements    * @throws Exception if a metric with this name already exists.    */
DECL|method|registerAll
specifier|public
name|void
name|registerAll
parameter_list|(
name|String
name|registry
parameter_list|,
name|MetricSet
name|metrics
parameter_list|,
name|boolean
name|force
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
throws|throws
name|Exception
block|{
name|MetricRegistry
name|metricRegistry
init|=
name|registry
argument_list|(
name|registry
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|metricRegistry
init|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Metric
argument_list|>
name|existingMetrics
init|=
name|metricRegistry
operator|.
name|getMetrics
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Metric
argument_list|>
name|entry
range|:
name|metrics
operator|.
name|getMetrics
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|fullName
init|=
name|mkName
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|metricPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|force
operator|&&
name|existingMetrics
operator|.
name|containsKey
argument_list|(
name|fullName
argument_list|)
condition|)
block|{
name|metricRegistry
operator|.
name|remove
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
block|}
name|metricRegistry
operator|.
name|register
argument_list|(
name|fullName
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove all metrics from a specified registry.    * @param registry registry name    */
DECL|method|clearRegistry
specifier|public
name|void
name|clearRegistry
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|removeMatching
argument_list|(
name|MetricFilter
operator|.
name|ALL
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove some metrics from a named registry    * @param registry registry name    * @param metricPath (optional) top-most metric name path elements. If empty then    *        this is equivalent to calling {@link #clearRegistry(String)},    *        otherwise non-empty elements will be joined using dotted notation    *        to form a fully-qualified prefix. Metrics with names that start    *        with the prefix will be removed.    * @return set of metrics names that have been removed.    */
DECL|method|clearMetrics
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|clearMetrics
parameter_list|(
name|String
name|registry
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
name|PrefixFilter
name|filter
decl_stmt|;
if|if
condition|(
name|metricPath
operator|==
literal|null
operator|||
name|metricPath
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|filter
operator|=
operator|new
name|PrefixFilter
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|prefix
init|=
name|MetricRegistry
operator|.
name|name
argument_list|(
literal|""
argument_list|,
name|metricPath
argument_list|)
decl_stmt|;
name|filter
operator|=
operator|new
name|PrefixFilter
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|removeMatching
argument_list|(
name|filter
argument_list|)
expr_stmt|;
return|return
name|filter
operator|.
name|getMatched
argument_list|()
return|;
block|}
comment|/**    * Create or get an existing named {@link Meter}    * @param registry registry name    * @param metricName metric name, either final name or a fully-qualified name    *                   using dotted notation    * @param metricPath (optional) additional top-most metric name path elements    * @return existing or a newly created {@link Meter}    */
DECL|method|meter
specifier|public
name|Meter
name|meter
parameter_list|(
name|String
name|registry
parameter_list|,
name|String
name|metricName
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
return|return
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|meter
argument_list|(
name|mkName
argument_list|(
name|metricName
argument_list|,
name|metricPath
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create or get an existing named {@link Timer}    * @param registry registry name    * @param metricName metric name, either final name or a fully-qualified name    *                   using dotted notation    * @param metricPath (optional) additional top-most metric name path elements    * @return existing or a newly created {@link Timer}    */
DECL|method|timer
specifier|public
name|Timer
name|timer
parameter_list|(
name|String
name|registry
parameter_list|,
name|String
name|metricName
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
return|return
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|timer
argument_list|(
name|mkName
argument_list|(
name|metricName
argument_list|,
name|metricPath
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create or get an existing named {@link Counter}    * @param registry registry name    * @param metricName metric name, either final name or a fully-qualified name    *                   using dotted notation    * @param metricPath (optional) additional top-most metric name path elements    * @return existing or a newly created {@link Counter}    */
DECL|method|counter
specifier|public
name|Counter
name|counter
parameter_list|(
name|String
name|registry
parameter_list|,
name|String
name|metricName
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
return|return
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|counter
argument_list|(
name|mkName
argument_list|(
name|metricName
argument_list|,
name|metricPath
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create or get an existing named {@link Histogram}    * @param registry registry name    * @param metricName metric name, either final name or a fully-qualified name    *                   using dotted notation    * @param metricPath (optional) additional top-most metric name path elements    * @return existing or a newly created {@link Histogram}    */
DECL|method|histogram
specifier|public
name|Histogram
name|histogram
parameter_list|(
name|String
name|registry
parameter_list|,
name|String
name|metricName
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
return|return
name|registry
argument_list|(
name|registry
argument_list|)
operator|.
name|histogram
argument_list|(
name|mkName
argument_list|(
name|metricName
argument_list|,
name|metricPath
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Register an instance of {@link Metric}.    * @param registry registry name    * @param metric metric instance    * @param force if true then an already existing metric with the same name will be replaced.    *                     When false and a metric with the same name already exists an exception    *                     will be thrown.    * @param metricName metric name, either final name or a fully-qualified name    *                   using dotted notation    * @param metricPath (optional) additional top-most metric name path elements    */
DECL|method|register
specifier|public
name|void
name|register
parameter_list|(
name|String
name|registry
parameter_list|,
name|Metric
name|metric
parameter_list|,
name|boolean
name|force
parameter_list|,
name|String
name|metricName
parameter_list|,
name|String
modifier|...
name|metricPath
parameter_list|)
block|{
name|MetricRegistry
name|metricRegistry
init|=
name|registry
argument_list|(
name|registry
argument_list|)
decl_stmt|;
name|String
name|fullName
init|=
name|mkName
argument_list|(
name|metricName
argument_list|,
name|metricPath
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|metricRegistry
init|)
block|{
if|if
condition|(
name|force
operator|&&
name|metricRegistry
operator|.
name|getMetrics
argument_list|()
operator|.
name|containsKey
argument_list|(
name|fullName
argument_list|)
condition|)
block|{
name|metricRegistry
operator|.
name|remove
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
block|}
name|metricRegistry
operator|.
name|register
argument_list|(
name|fullName
argument_list|,
name|metric
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This method creates a hierarchical name with arbitrary levels of hierarchy    * @param name the final segment of the name, must not be null or empty.    * @param path optional path segments, starting from the top level. Empty or null    *             segments will be skipped.    * @return fully-qualified name using dotted notation, with all valid hierarchy    * segments prepended to the name.    */
DECL|method|mkName
specifier|public
specifier|static
name|String
name|mkName
parameter_list|(
name|String
name|name
parameter_list|,
name|String
modifier|...
name|path
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"name must not be empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|path
operator|==
literal|null
operator|||
name|path
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|name
return|;
block|}
else|else
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|path
control|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
operator|||
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Allows named registries to be renamed using System properties.    * This would be mostly be useful if you want to combine the metrics from a few registries for a single    * reporter.    *<p>For example, in order to collect metrics from related cores in a single registry you could specify    * the following system properties:</p>    *<pre>    *   ... -Dsolr.core.collection1=solr.core.allCollections -Dsolr.core.collection2=solr.core.allCollections    *</pre>    *<b>NOTE:</b> Once a registry is renamed in a way that its metrics are combined with another repository    * it is no longer possible to retrieve the original metrics until this renaming is removed and the Solr    * {@link org.apache.solr.core.SolrInfoMBean.Group} of components that reported to that name is restarted.    * @param registry The name of the registry    * @return A potentially overridden (via System properties) registry name    */
DECL|method|overridableRegistryName
specifier|public
specifier|static
name|String
name|overridableRegistryName
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
name|String
name|fqRegistry
init|=
name|enforcePrefix
argument_list|(
name|registry
argument_list|)
decl_stmt|;
return|return
name|enforcePrefix
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|fqRegistry
argument_list|,
name|fqRegistry
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Enforces the leading {@link #REGISTRY_NAME_PREFIX} in a name.    * @param name input name, possibly without the prefix    * @return original name if it contained the prefix, or the    * input name with the prefix prepended.    */
DECL|method|enforcePrefix
specifier|public
specifier|static
name|String
name|enforcePrefix
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|REGISTRY_NAME_PREFIX
argument_list|)
condition|)
block|{
return|return
name|name
return|;
block|}
else|else
block|{
return|return
operator|new
name|StringBuilder
argument_list|(
name|REGISTRY_NAME_PREFIX
argument_list|)
operator|.
name|append
argument_list|(
name|name
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Helper method to construct a properly prefixed registry name based on the group.    * @param group reporting group    * @param names optional child elements of the registry name. If exactly one element is provided    *              and it already contains the required prefix and group name then this value will be used,    *              and the group parameter will be ignored.    * @return fully-qualified and prefixed registry name, with overrides applied.    */
DECL|method|getRegistryName
specifier|public
specifier|static
name|String
name|getRegistryName
parameter_list|(
name|SolrInfoMBean
operator|.
name|Group
name|group
parameter_list|,
name|String
modifier|...
name|names
parameter_list|)
block|{
name|String
name|fullName
decl_stmt|;
name|String
name|prefix
init|=
name|REGISTRY_NAME_PREFIX
operator|+
name|group
operator|.
name|toString
argument_list|()
operator|+
literal|"."
decl_stmt|;
comment|// check for existing prefix and group
if|if
condition|(
name|names
operator|!=
literal|null
operator|&&
name|names
operator|.
name|length
operator|>
literal|0
operator|&&
name|names
index|[
literal|0
index|]
operator|!=
literal|null
operator|&&
name|names
index|[
literal|0
index|]
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
comment|// assume the first segment already was expanded
if|if
condition|(
name|names
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|String
index|[]
name|newNames
init|=
operator|new
name|String
index|[
name|names
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|names
argument_list|,
literal|1
argument_list|,
name|newNames
argument_list|,
literal|0
argument_list|,
name|newNames
operator|.
name|length
argument_list|)
expr_stmt|;
name|fullName
operator|=
name|MetricRegistry
operator|.
name|name
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|,
name|newNames
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fullName
operator|=
name|MetricRegistry
operator|.
name|name
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fullName
operator|=
name|MetricRegistry
operator|.
name|name
argument_list|(
name|group
operator|.
name|toString
argument_list|()
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
return|return
name|overridableRegistryName
argument_list|(
name|fullName
argument_list|)
return|;
block|}
comment|// reporter management
comment|/**    * Create and register {@link SolrMetricReporter}-s specific to a {@link org.apache.solr.core.SolrInfoMBean.Group}.    * Note: reporters that specify neither "group" nor "registry" attributes are treated as universal -    * they will always be loaded for any group. These two attributes may also contain multiple comma- or    * whitespace-separated values, in which case the reporter will be loaded for any matching value from    * the list. If both attributes are present then only "group" attribute will be processed.    * @param pluginInfos plugin configurations    * @param loader resource loader    * @param group selected group, not null    * @param registryNames optional child registry name elements    */
DECL|method|loadReporters
specifier|public
name|void
name|loadReporters
parameter_list|(
name|PluginInfo
index|[]
name|pluginInfos
parameter_list|,
name|SolrResourceLoader
name|loader
parameter_list|,
name|SolrInfoMBean
operator|.
name|Group
name|group
parameter_list|,
name|String
modifier|...
name|registryNames
parameter_list|)
block|{
if|if
condition|(
name|pluginInfos
operator|==
literal|null
operator|||
name|pluginInfos
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|String
name|registryName
init|=
name|getRegistryName
argument_list|(
name|group
argument_list|,
name|registryNames
argument_list|)
decl_stmt|;
for|for
control|(
name|PluginInfo
name|info
range|:
name|pluginInfos
control|)
block|{
name|String
name|target
init|=
name|info
operator|.
name|attributes
operator|.
name|get
argument_list|(
literal|"group"
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|null
condition|)
block|{
comment|// no "group"
name|target
operator|=
name|info
operator|.
name|attributes
operator|.
name|get
argument_list|(
literal|"registry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|targets
init|=
name|target
operator|.
name|split
argument_list|(
literal|"[\\s,]+"
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|t
range|:
name|targets
control|)
block|{
name|t
operator|=
name|overridableRegistryName
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|registryName
operator|.
name|equals
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
comment|// neither group nor registry specified.
comment|// always register this plugin for all groups and registries
block|}
block|}
else|else
block|{
comment|// check groups
name|String
index|[]
name|targets
init|=
name|target
operator|.
name|split
argument_list|(
literal|"[\\s,]+"
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|t
range|:
name|targets
control|)
block|{
if|if
condition|(
name|group
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
continue|continue;
block|}
block|}
try|try
block|{
name|loadReporter
argument_list|(
name|registryName
argument_list|,
name|loader
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Error loading metrics reporter, plugin info: "
operator|+
name|info
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Create and register an instance of {@link SolrMetricReporter}.    * @param registry reporter is associated with this registry    * @param loader loader to use when creating an instance of the reporter    * @param pluginInfo plugin configuration. Plugin "name" and "class" attributes are required.    * @throws Exception if any argument is missing or invalid    */
DECL|method|loadReporter
specifier|public
name|void
name|loadReporter
parameter_list|(
name|String
name|registry
parameter_list|,
name|SolrResourceLoader
name|loader
parameter_list|,
name|PluginInfo
name|pluginInfo
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|registry
operator|==
literal|null
operator|||
name|pluginInfo
operator|==
literal|null
operator|||
name|pluginInfo
operator|.
name|name
operator|==
literal|null
operator|||
name|pluginInfo
operator|.
name|className
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"loadReporter called with missing arguments: "
operator|+
literal|"registry="
operator|+
name|registry
operator|+
literal|", loader="
operator|+
name|loader
operator|+
literal|", pluginInfo="
operator|+
name|pluginInfo
argument_list|)
throw|;
block|}
comment|// make sure we use a name with prefix, with overrides
name|registry
operator|=
name|overridableRegistryName
argument_list|(
name|registry
argument_list|)
expr_stmt|;
name|SolrMetricReporter
name|reporter
init|=
name|loader
operator|.
name|newInstance
argument_list|(
name|pluginInfo
operator|.
name|className
argument_list|,
name|SolrMetricReporter
operator|.
name|class
argument_list|,
operator|new
name|String
index|[
literal|0
index|]
argument_list|,
operator|new
name|Class
index|[]
block|{
name|SolrMetricManager
operator|.
name|class
block|,
name|String
operator|.
name|class
block|}
argument_list|,
operator|new
name|Object
index|[]
block|{
name|this
block|,
name|registry
block|}
argument_list|)
decl_stmt|;
try|try
block|{
name|reporter
operator|.
name|init
argument_list|(
name|pluginInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"reporter init failed: "
operator|+
name|pluginInfo
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|reportersLock
operator|.
name|tryLock
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Could not obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Interrupted while trying to obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
throw|;
block|}
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|SolrMetricReporter
argument_list|>
name|perRegistry
init|=
name|reporters
operator|.
name|get
argument_list|(
name|registry
argument_list|)
decl_stmt|;
if|if
condition|(
name|perRegistry
operator|==
literal|null
condition|)
block|{
name|perRegistry
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|reporters
operator|.
name|put
argument_list|(
name|registry
argument_list|,
name|perRegistry
argument_list|)
expr_stmt|;
block|}
name|SolrMetricReporter
name|oldReporter
init|=
name|perRegistry
operator|.
name|get
argument_list|(
name|pluginInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldReporter
operator|!=
literal|null
condition|)
block|{
comment|// close it
name|log
operator|.
name|info
argument_list|(
literal|"Replacing existing reporter '"
operator|+
name|pluginInfo
operator|.
name|name
operator|+
literal|"' in registry '"
operator|+
name|registry
operator|+
literal|"': "
operator|+
name|oldReporter
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|oldReporter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|perRegistry
operator|.
name|put
argument_list|(
name|pluginInfo
operator|.
name|name
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reportersLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Close and unregister a named {@link SolrMetricReporter} for a registry.    * @param registry registry name    * @param name reporter name    * @return true if a named reporter existed and was closed.    */
DECL|method|closeReporter
specifier|public
name|boolean
name|closeReporter
parameter_list|(
name|String
name|registry
parameter_list|,
name|String
name|name
parameter_list|)
block|{
comment|// make sure we use a name with prefix, with overrides
name|registry
operator|=
name|overridableRegistryName
argument_list|(
name|registry
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|reportersLock
operator|.
name|tryLock
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Could not obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Interrupted while trying to obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|SolrMetricReporter
argument_list|>
name|perRegistry
init|=
name|reporters
operator|.
name|get
argument_list|(
name|registry
argument_list|)
decl_stmt|;
if|if
condition|(
name|perRegistry
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SolrMetricReporter
name|reporter
init|=
name|perRegistry
operator|.
name|remove
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|reporter
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
name|reporter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Error closing metric reporter, registry="
operator|+
name|registry
operator|+
literal|", name="
operator|+
name|name
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|reportersLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Close and unregister all {@link SolrMetricReporter}-s for a registry.    * @param registry registry name    * @return names of closed reporters    */
DECL|method|closeReporters
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|closeReporters
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
comment|// make sure we use a name with prefix, with overrides
name|registry
operator|=
name|overridableRegistryName
argument_list|(
name|registry
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|reportersLock
operator|.
name|tryLock
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Could not obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Interrupted while trying to obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Closing metric reporters for: "
operator|+
name|registry
argument_list|)
expr_stmt|;
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|SolrMetricReporter
argument_list|>
name|perRegistry
init|=
name|reporters
operator|.
name|remove
argument_list|(
name|registry
argument_list|)
decl_stmt|;
if|if
condition|(
name|perRegistry
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SolrMetricReporter
name|reporter
range|:
name|perRegistry
operator|.
name|values
argument_list|()
control|)
block|{
try|try
block|{
name|reporter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception closing reporter "
operator|+
name|reporter
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|perRegistry
operator|.
name|keySet
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
block|}
finally|finally
block|{
name|reportersLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a map of reporters for a registry. Keys are reporter names, values are reporter instances.    * @param registry registry name    * @return map of reporters and their names, may be empty but never null    */
DECL|method|getReporters
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SolrMetricReporter
argument_list|>
name|getReporters
parameter_list|(
name|String
name|registry
parameter_list|)
block|{
comment|// make sure we use a name with prefix, with overrides
name|registry
operator|=
name|overridableRegistryName
argument_list|(
name|registry
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|reportersLock
operator|.
name|tryLock
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Could not obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Interrupted while trying to obtain lock to modify reporters registry: "
operator|+
name|registry
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|SolrMetricReporter
argument_list|>
name|perRegistry
init|=
name|reporters
operator|.
name|get
argument_list|(
name|registry
argument_list|)
decl_stmt|;
if|if
condition|(
name|perRegistry
operator|==
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
else|else
block|{
comment|// defensive copy - the original map may change after we release the lock
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|perRegistry
argument_list|)
argument_list|)
return|;
block|}
block|}
finally|finally
block|{
name|reportersLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

