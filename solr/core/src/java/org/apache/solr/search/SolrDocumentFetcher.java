begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.search
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|DocumentStoredFieldVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|LazyDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|BinaryDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexableField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexableFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|NumericDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ReaderUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedNumericDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedSetDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StoredFieldVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|NumericUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocumentBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|BoolField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|EnumField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|NumberType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieDateField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieDoubleField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieFloatField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieIntField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A helper class of {@link org.apache.solr.search.SolrIndexSearcher} for stored Document related matters  * including DocValue substitutions.  */
end_comment

begin_class
DECL|class|SolrDocumentFetcher
specifier|public
class|class
name|SolrDocumentFetcher
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|searcher
specifier|private
specifier|final
name|SolrIndexSearcher
name|searcher
decl_stmt|;
DECL|field|enableLazyFieldLoading
specifier|private
specifier|final
name|boolean
name|enableLazyFieldLoading
decl_stmt|;
DECL|field|documentCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|Integer
argument_list|,
name|Document
argument_list|>
name|documentCache
decl_stmt|;
comment|/** Contains the names/patterns of all docValues=true,stored=false fields in the schema. */
DECL|field|allNonStoredDVs
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|allNonStoredDVs
decl_stmt|;
comment|/** Contains the names/patterns of all docValues=true,stored=false,useDocValuesAsStored=true fields in the schema. */
DECL|field|nonStoredDVsUsedAsStored
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|nonStoredDVsUsedAsStored
decl_stmt|;
comment|/** Contains the names/patterns of all docValues=true,stored=false fields, excluding those that are copyField targets in the schema. */
DECL|field|nonStoredDVsWithoutCopyTargets
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|nonStoredDVsWithoutCopyTargets
decl_stmt|;
DECL|field|largeValueLengthCacheThreshold
specifier|private
specifier|static
name|int
name|largeValueLengthCacheThreshold
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"solr.largeField.cacheThreshold"
argument_list|,
literal|512
operator|*
literal|1024
argument_list|)
decl_stmt|;
comment|// internal setting
DECL|field|largeFields
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|largeFields
decl_stmt|;
DECL|field|storedHighlightFieldNames
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|storedHighlightFieldNames
decl_stmt|;
comment|// lazy populated; use getter
DECL|method|SolrDocumentFetcher
name|SolrDocumentFetcher
parameter_list|(
name|SolrIndexSearcher
name|searcher
parameter_list|,
name|SolrConfig
name|solrConfig
parameter_list|,
name|boolean
name|cachingEnabled
parameter_list|)
block|{
name|this
operator|.
name|searcher
operator|=
name|searcher
expr_stmt|;
name|this
operator|.
name|enableLazyFieldLoading
operator|=
name|solrConfig
operator|.
name|enableLazyFieldLoading
expr_stmt|;
if|if
condition|(
name|cachingEnabled
condition|)
block|{
name|documentCache
operator|=
name|solrConfig
operator|.
name|documentCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|documentCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|documentCache
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|nonStoredDVsUsedAsStored
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|allNonStoredDVs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|nonStoredDVsWithoutCopyTargets
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|storedLargeFields
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fieldInfo
range|:
name|searcher
operator|.
name|getFieldInfos
argument_list|()
control|)
block|{
comment|// can find materialized dynamic fields, unlike using the Solr IndexSchema.
specifier|final
name|SchemaField
name|schemaField
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getFieldOrNull
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|schemaField
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|schemaField
operator|.
name|stored
argument_list|()
operator|&&
name|schemaField
operator|.
name|hasDocValues
argument_list|()
condition|)
block|{
if|if
condition|(
name|schemaField
operator|.
name|useDocValuesAsStored
argument_list|()
condition|)
block|{
name|nonStoredDVsUsedAsStored
operator|.
name|add
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|allNonStoredDVs
operator|.
name|add
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|isCopyFieldTarget
argument_list|(
name|schemaField
argument_list|)
condition|)
block|{
name|nonStoredDVsWithoutCopyTargets
operator|.
name|add
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|schemaField
operator|.
name|stored
argument_list|()
operator|&&
name|schemaField
operator|.
name|isLarge
argument_list|()
condition|)
block|{
name|storedLargeFields
operator|.
name|add
argument_list|(
name|schemaField
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|nonStoredDVsUsedAsStored
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|nonStoredDVsUsedAsStored
argument_list|)
expr_stmt|;
name|this
operator|.
name|allNonStoredDVs
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|allNonStoredDVs
argument_list|)
expr_stmt|;
name|this
operator|.
name|nonStoredDVsWithoutCopyTargets
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|nonStoredDVsWithoutCopyTargets
argument_list|)
expr_stmt|;
name|this
operator|.
name|largeFields
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|storedLargeFields
argument_list|)
expr_stmt|;
block|}
DECL|method|isLazyFieldLoadingEnabled
specifier|public
name|boolean
name|isLazyFieldLoadingEnabled
parameter_list|()
block|{
return|return
name|enableLazyFieldLoading
return|;
block|}
DECL|method|getDocumentCache
specifier|public
name|SolrCache
argument_list|<
name|Integer
argument_list|,
name|Document
argument_list|>
name|getDocumentCache
parameter_list|()
block|{
return|return
name|documentCache
return|;
block|}
comment|/**    * Returns a collection of the names of all stored fields which can be highlighted the index reader knows about.    */
DECL|method|getStoredHighlightFieldNames
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getStoredHighlightFieldNames
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|storedHighlightFieldNames
operator|==
literal|null
condition|)
block|{
name|storedHighlightFieldNames
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|FieldInfo
name|fieldInfo
range|:
name|searcher
operator|.
name|getFieldInfos
argument_list|()
control|)
block|{
specifier|final
name|String
name|fieldName
init|=
name|fieldInfo
operator|.
name|name
decl_stmt|;
try|try
block|{
name|SchemaField
name|field
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|stored
argument_list|()
operator|&&
operator|(
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TextField
operator|)
operator|||
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|StrField
operator|)
operator|)
condition|)
block|{
name|storedHighlightFieldNames
operator|.
name|add
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// getField() throws a SolrException, but it arrives as a RuntimeException
name|log
operator|.
name|warn
argument_list|(
literal|"Field [{}] found in index, but not defined in schema."
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|storedHighlightFieldNames
return|;
block|}
block|}
comment|/** @see SolrIndexSearcher#doc(int) */
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|docId
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|doc
argument_list|(
name|docId
argument_list|,
operator|(
name|Set
argument_list|<
name|String
argument_list|>
operator|)
literal|null
argument_list|)
return|;
block|}
comment|/**    * Retrieve the {@link Document} instance corresponding to the document id.    *<p>    *<b>NOTE</b>: the document will have all fields accessible, but if a field filter is provided, only the provided    * fields will be loaded (the remainder will be available lazily).    *    * @see SolrIndexSearcher#doc(int, Set)    */
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|i
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
name|d
decl_stmt|;
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
block|{
name|d
operator|=
name|documentCache
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
return|return
name|d
return|;
block|}
specifier|final
name|DirectoryReader
name|reader
init|=
name|searcher
operator|.
name|getIndexReader
argument_list|()
decl_stmt|;
if|if
condition|(
name|documentCache
operator|!=
literal|null
operator|&&
operator|!
name|enableLazyFieldLoading
condition|)
block|{
comment|// we do not filter the fields in this case because that would return an incomplete document which would
comment|// be eventually cached. The alternative would be to read the stored fields twice; once with the fields
comment|// and then without for caching leading to a performance hit
comment|// see SOLR-8858 for related discussion
name|fields
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|SolrDocumentStoredFieldVisitor
name|visitor
init|=
operator|new
name|SolrDocumentStoredFieldVisitor
argument_list|(
name|fields
argument_list|,
name|reader
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|reader
operator|.
name|document
argument_list|(
name|i
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
name|d
operator|=
name|visitor
operator|.
name|getDocument
argument_list|()
expr_stmt|;
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
block|{
name|documentCache
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
comment|/** {@link StoredFieldVisitor} which loads the specified fields eagerly (or all if null).    * If {@link #enableLazyFieldLoading} then the rest get special lazy field entries.  Designated "large"    * fields will always get a special field entry. */
DECL|class|SolrDocumentStoredFieldVisitor
specifier|private
class|class
name|SolrDocumentStoredFieldVisitor
extends|extends
name|DocumentStoredFieldVisitor
block|{
DECL|field|doc
specifier|private
specifier|final
name|Document
name|doc
decl_stmt|;
DECL|field|lazyFieldProducer
specifier|private
specifier|final
name|LazyDocument
name|lazyFieldProducer
decl_stmt|;
comment|// arguably a better name than LazyDocument; at least how we use it here
DECL|field|docId
specifier|private
specifier|final
name|int
name|docId
decl_stmt|;
DECL|field|addLargeFieldsLazily
specifier|private
specifier|final
name|boolean
name|addLargeFieldsLazily
decl_stmt|;
DECL|method|SolrDocumentStoredFieldVisitor
name|SolrDocumentStoredFieldVisitor
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|toLoad
parameter_list|,
name|IndexReader
name|reader
parameter_list|,
name|int
name|docId
parameter_list|)
block|{
name|super
argument_list|(
name|toLoad
argument_list|)
expr_stmt|;
name|this
operator|.
name|docId
operator|=
name|docId
expr_stmt|;
name|this
operator|.
name|doc
operator|=
name|getDocument
argument_list|()
expr_stmt|;
name|this
operator|.
name|lazyFieldProducer
operator|=
name|toLoad
operator|!=
literal|null
operator|&&
name|enableLazyFieldLoading
condition|?
operator|new
name|LazyDocument
argument_list|(
name|reader
argument_list|,
name|docId
argument_list|)
else|:
literal|null
expr_stmt|;
name|this
operator|.
name|addLargeFieldsLazily
operator|=
operator|(
name|documentCache
operator|!=
literal|null
operator|&&
operator|!
name|largeFields
operator|.
name|isEmpty
argument_list|()
operator|)
expr_stmt|;
comment|//TODO can we return Status.STOP after a val is loaded and we know there are no other fields of interest?
comment|//    When: toLoad is one single-valued field, no lazyFieldProducer
block|}
annotation|@
name|Override
DECL|method|needsField
specifier|public
name|Status
name|needsField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|Status
name|status
init|=
name|super
operator|.
name|needsField
argument_list|(
name|fieldInfo
argument_list|)
decl_stmt|;
assert|assert
name|status
operator|!=
name|Status
operator|.
name|STOP
operator|:
literal|"Status.STOP not supported or expected"
assert|;
if|if
condition|(
name|addLargeFieldsLazily
operator|&&
name|largeFields
operator|.
name|contains
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
condition|)
block|{
comment|// load "large" fields using this lazy mechanism
if|if
condition|(
name|lazyFieldProducer
operator|!=
literal|null
operator|||
name|status
operator|==
name|Status
operator|.
name|YES
condition|)
block|{
name|doc
operator|.
name|add
argument_list|(
operator|new
name|LargeLazyField
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|docId
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Status
operator|.
name|NO
return|;
block|}
if|if
condition|(
name|status
operator|==
name|Status
operator|.
name|NO
operator|&&
name|lazyFieldProducer
operator|!=
literal|null
condition|)
block|{
comment|// lazy
name|doc
operator|.
name|add
argument_list|(
name|lazyFieldProducer
operator|.
name|getField
argument_list|(
name|fieldInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
block|}
comment|/** @see SolrIndexSearcher#doc(int, StoredFieldVisitor) */
DECL|method|doc
specifier|public
name|void
name|doc
parameter_list|(
name|int
name|docId
parameter_list|,
name|StoredFieldVisitor
name|visitor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
block|{
name|Document
name|cached
init|=
name|documentCache
operator|.
name|get
argument_list|(
name|docId
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
block|{
name|visitFromCached
argument_list|(
name|cached
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|document
argument_list|(
name|docId
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
block|}
comment|/** Executes a stored field visitor against a hit from the document cache */
DECL|method|visitFromCached
specifier|private
name|void
name|visitFromCached
parameter_list|(
name|Document
name|document
parameter_list|,
name|StoredFieldVisitor
name|visitor
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|IndexableField
name|f
range|:
name|document
control|)
block|{
specifier|final
name|FieldInfo
name|info
init|=
name|searcher
operator|.
name|getFieldInfos
argument_list|()
operator|.
name|fieldInfo
argument_list|(
name|f
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|StoredFieldVisitor
operator|.
name|Status
name|needsField
init|=
name|visitor
operator|.
name|needsField
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|needsField
operator|==
name|StoredFieldVisitor
operator|.
name|Status
operator|.
name|STOP
condition|)
return|return;
if|if
condition|(
name|needsField
operator|==
name|StoredFieldVisitor
operator|.
name|Status
operator|.
name|NO
condition|)
continue|continue;
name|BytesRef
name|binaryValue
init|=
name|f
operator|.
name|binaryValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|binaryValue
operator|!=
literal|null
condition|)
block|{
name|visitor
operator|.
name|binaryField
argument_list|(
name|info
argument_list|,
name|toByteArrayUnwrapIfPossible
argument_list|(
name|binaryValue
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Number
name|numericValue
init|=
name|f
operator|.
name|numericValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|numericValue
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|numericValue
operator|instanceof
name|Double
condition|)
block|{
name|visitor
operator|.
name|doubleField
argument_list|(
name|info
argument_list|,
name|numericValue
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numericValue
operator|instanceof
name|Integer
condition|)
block|{
name|visitor
operator|.
name|intField
argument_list|(
name|info
argument_list|,
name|numericValue
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numericValue
operator|instanceof
name|Float
condition|)
block|{
name|visitor
operator|.
name|floatField
argument_list|(
name|info
argument_list|,
name|numericValue
operator|.
name|floatValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numericValue
operator|instanceof
name|Long
condition|)
block|{
name|visitor
operator|.
name|longField
argument_list|(
name|info
argument_list|,
name|numericValue
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
continue|continue;
block|}
comment|// must be String
if|if
condition|(
name|f
operator|instanceof
name|LargeLazyField
condition|)
block|{
comment|// optimization to avoid premature string conversion
name|visitor
operator|.
name|stringField
argument_list|(
name|info
argument_list|,
name|toByteArrayUnwrapIfPossible
argument_list|(
operator|(
operator|(
name|LargeLazyField
operator|)
name|f
operator|)
operator|.
name|readBytes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|visitor
operator|.
name|stringField
argument_list|(
name|info
argument_list|,
name|f
operator|.
name|stringValue
argument_list|()
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|toByteArrayUnwrapIfPossible
specifier|private
name|byte
index|[]
name|toByteArrayUnwrapIfPossible
parameter_list|(
name|BytesRef
name|bytesRef
parameter_list|)
block|{
if|if
condition|(
name|bytesRef
operator|.
name|offset
operator|==
literal|0
operator|&&
name|bytesRef
operator|.
name|bytes
operator|.
name|length
operator|==
name|bytesRef
operator|.
name|length
condition|)
block|{
return|return
name|bytesRef
operator|.
name|bytes
return|;
block|}
else|else
block|{
return|return
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|bytesRef
operator|.
name|bytes
argument_list|,
name|bytesRef
operator|.
name|offset
argument_list|,
name|bytesRef
operator|.
name|offset
operator|+
name|bytesRef
operator|.
name|length
argument_list|)
return|;
block|}
block|}
comment|/** Unlike LazyDocument.LazyField, we (a) don't cache large values, and (b) provide access to the byte[]. */
DECL|class|LargeLazyField
class|class
name|LargeLazyField
implements|implements
name|IndexableField
block|{
DECL|field|name
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|docId
specifier|final
name|int
name|docId
decl_stmt|;
comment|// synchronize on 'this' to access:
DECL|field|cachedBytes
name|BytesRef
name|cachedBytes
decl_stmt|;
comment|// we only conditionally populate this if it's big enough
DECL|method|LargeLazyField
specifier|private
name|LargeLazyField
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|docId
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|docId
operator|=
name|docId
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|fieldType
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"<"
operator|+
name|name
argument_list|()
operator|+
literal|">"
return|;
comment|// mimic Field.java
block|}
annotation|@
name|Override
DECL|method|name
specifier|public
name|String
name|name
parameter_list|()
block|{
return|return
name|name
return|;
block|}
annotation|@
name|Override
DECL|method|fieldType
specifier|public
name|IndexableFieldType
name|fieldType
parameter_list|()
block|{
return|return
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|name
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tokenStream
specifier|public
name|TokenStream
name|tokenStream
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|,
name|TokenStream
name|reuse
parameter_list|)
block|{
return|return
name|analyzer
operator|.
name|tokenStream
argument_list|(
name|name
argument_list|()
argument_list|,
name|stringValue
argument_list|()
argument_list|)
return|;
comment|// or we could throw unsupported exception?
block|}
comment|/** (for tests) */
DECL|method|hasBeenLoaded
specifier|synchronized
name|boolean
name|hasBeenLoaded
parameter_list|()
block|{
return|return
name|cachedBytes
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|stringValue
specifier|public
specifier|synchronized
name|String
name|stringValue
parameter_list|()
block|{
try|try
block|{
return|return
name|readBytes
argument_list|()
operator|.
name|utf8ToString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readBytes
specifier|synchronized
name|BytesRef
name|readBytes
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cachedBytes
operator|!=
literal|null
condition|)
block|{
return|return
name|cachedBytes
return|;
block|}
else|else
block|{
name|BytesRef
name|bytesRef
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|document
argument_list|(
name|docId
argument_list|,
operator|new
name|StoredFieldVisitor
argument_list|()
block|{
name|boolean
name|done
init|=
literal|false
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Status
name|needsField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|done
condition|)
block|{
return|return
name|Status
operator|.
name|STOP
return|;
block|}
return|return
name|fieldInfo
operator|.
name|name
operator|.
name|equals
argument_list|(
name|name
argument_list|()
argument_list|)
condition|?
name|Status
operator|.
name|YES
else|:
name|Status
operator|.
name|NO
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stringField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|bytesRef
operator|.
name|bytes
operator|=
name|value
expr_stmt|;
name|bytesRef
operator|.
name|length
operator|=
name|value
operator|.
name|length
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|binaryField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"'large' binary fields are not (yet) supported"
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytesRef
operator|.
name|length
operator|<
name|largeValueLengthCacheThreshold
condition|)
block|{
return|return
name|cachedBytes
operator|=
name|bytesRef
return|;
block|}
else|else
block|{
return|return
name|bytesRef
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|binaryValue
specifier|public
name|BytesRef
name|binaryValue
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|readerValue
specifier|public
name|Reader
name|readerValue
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|numericValue
specifier|public
name|Number
name|numericValue
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument    *    * @param doc    *          A SolrDocument or SolrInputDocument instance where docValues will be added    * @param docid    *          The lucene docid of the document to be populated    * @param fields    *          The list of docValues fields to be decorated    */
DECL|method|decorateDocValueFields
specifier|public
name|void
name|decorateDocValueFields
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
name|SolrDocumentBase
name|doc
parameter_list|,
name|int
name|docid
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|LeafReaderContext
argument_list|>
name|leafContexts
init|=
name|searcher
operator|.
name|getLeafContexts
argument_list|()
decl_stmt|;
specifier|final
name|int
name|subIndex
init|=
name|ReaderUtil
operator|.
name|subIndex
argument_list|(
name|docid
argument_list|,
name|leafContexts
argument_list|)
decl_stmt|;
specifier|final
name|int
name|localId
init|=
name|docid
operator|-
name|leafContexts
operator|.
name|get
argument_list|(
name|subIndex
argument_list|)
operator|.
name|docBase
decl_stmt|;
specifier|final
name|LeafReader
name|leafReader
init|=
name|leafContexts
operator|.
name|get
argument_list|(
name|subIndex
argument_list|)
operator|.
name|reader
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fields
control|)
block|{
specifier|final
name|SchemaField
name|schemaField
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getFieldOrNull
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|schemaField
operator|==
literal|null
operator|||
operator|!
name|schemaField
operator|.
name|hasDocValues
argument_list|()
operator|||
name|doc
operator|.
name|containsKey
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Couldn't decorate docValues for field: [{}], schemaField: [{}]"
argument_list|,
name|fieldName
argument_list|,
name|schemaField
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|FieldInfo
name|fi
init|=
name|searcher
operator|.
name|getFieldInfos
argument_list|()
operator|.
name|fieldInfo
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|==
literal|null
condition|)
block|{
continue|continue;
comment|// Searcher doesn't have info about this field, hence ignore it.
block|}
specifier|final
name|DocValuesType
name|dvType
init|=
name|fi
operator|.
name|getDocValuesType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|dvType
condition|)
block|{
case|case
name|NUMERIC
case|:
specifier|final
name|NumericDocValues
name|ndv
init|=
name|leafReader
operator|.
name|getNumericDocValues
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|ndv
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|Long
name|val
decl_stmt|;
if|if
condition|(
name|ndv
operator|.
name|advanceExact
argument_list|(
name|localId
argument_list|)
condition|)
block|{
name|val
operator|=
name|ndv
operator|.
name|longValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
name|Object
name|newVal
init|=
name|val
decl_stmt|;
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|isPointField
argument_list|()
condition|)
block|{
comment|// TODO: Maybe merge PointField with TrieFields here
name|NumberType
name|type
init|=
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|getNumberType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|INTEGER
case|:
name|newVal
operator|=
name|val
operator|.
name|intValue
argument_list|()
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|newVal
operator|=
name|val
operator|.
name|longValue
argument_list|()
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|newVal
operator|=
name|Float
operator|.
name|intBitsToFloat
argument_list|(
name|val
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|newVal
operator|=
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATE
case|:
name|newVal
operator|=
operator|new
name|Date
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected PointType: "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|TrieIntField
condition|)
block|{
name|newVal
operator|=
name|val
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|TrieFloatField
condition|)
block|{
name|newVal
operator|=
name|Float
operator|.
name|intBitsToFloat
argument_list|(
name|val
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|TrieDoubleField
condition|)
block|{
name|newVal
operator|=
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|TrieDateField
condition|)
block|{
name|newVal
operator|=
operator|new
name|Date
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|EnumField
condition|)
block|{
name|newVal
operator|=
operator|(
operator|(
name|EnumField
operator|)
name|schemaField
operator|.
name|getType
argument_list|()
operator|)
operator|.
name|intValueToStringValue
argument_list|(
name|val
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|doc
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINARY
case|:
name|BinaryDocValues
name|bdv
init|=
name|leafReader
operator|.
name|getBinaryDocValues
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|bdv
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|BytesRef
name|value
decl_stmt|;
if|if
condition|(
name|bdv
operator|.
name|advanceExact
argument_list|(
name|localId
argument_list|)
condition|)
block|{
name|value
operator|=
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|bdv
operator|.
name|binaryValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
name|doc
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SORTED
case|:
name|SortedDocValues
name|sdv
init|=
name|leafReader
operator|.
name|getSortedDocValues
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sdv
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sdv
operator|.
name|advanceExact
argument_list|(
name|localId
argument_list|)
condition|)
block|{
specifier|final
name|BytesRef
name|bRef
init|=
name|sdv
operator|.
name|binaryValue
argument_list|()
decl_stmt|;
comment|// Special handling for Boolean fields since they're stored as 'T' and 'F'.
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|BoolField
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|bRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|bRef
operator|.
name|utf8ToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SORTED_NUMERIC
case|:
specifier|final
name|SortedNumericDocValues
name|numericDv
init|=
name|leafReader
operator|.
name|getSortedNumericDocValues
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|NumberType
name|type
init|=
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|getNumberType
argument_list|()
decl_stmt|;
if|if
condition|(
name|numericDv
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|numericDv
operator|.
name|advance
argument_list|(
name|localId
argument_list|)
operator|==
name|localId
condition|)
block|{
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|outValues
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|numericDv
operator|.
name|docValueCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numericDv
operator|.
name|docValueCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|long
name|number
init|=
name|numericDv
operator|.
name|nextValue
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|INTEGER
case|:
name|outValues
operator|.
name|add
argument_list|(
operator|(
name|int
operator|)
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|outValues
operator|.
name|add
argument_list|(
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|outValues
operator|.
name|add
argument_list|(
name|NumericUtils
operator|.
name|sortableIntToFloat
argument_list|(
operator|(
name|int
operator|)
name|number
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|outValues
operator|.
name|add
argument_list|(
name|NumericUtils
operator|.
name|sortableLongToDouble
argument_list|(
name|number
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATE
case|:
name|outValues
operator|.
name|add
argument_list|(
operator|new
name|Date
argument_list|(
name|number
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected PointType: "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
assert|assert
name|outValues
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
name|doc
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|outValues
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|SORTED_SET
case|:
specifier|final
name|SortedSetDocValues
name|values
init|=
name|leafReader
operator|.
name|getSortedSetDocValues
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|!=
literal|null
operator|&&
name|values
operator|.
name|getValueCount
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|values
operator|.
name|advance
argument_list|(
name|localId
argument_list|)
operator|==
name|localId
condition|)
block|{
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|outValues
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|long
name|ord
init|=
name|values
operator|.
name|nextOrd
argument_list|()
init|;
name|ord
operator|!=
name|SortedSetDocValues
operator|.
name|NO_MORE_ORDS
condition|;
name|ord
operator|=
name|values
operator|.
name|nextOrd
argument_list|()
control|)
block|{
name|value
operator|=
name|values
operator|.
name|lookupOrd
argument_list|(
name|ord
argument_list|)
expr_stmt|;
name|outValues
operator|.
name|add
argument_list|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|outValues
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
name|doc
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|outValues
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|NONE
case|:
break|break;
block|}
block|}
block|}
comment|/**    * Returns an unmodifiable set of non-stored docValues field names.    *    * @param onlyUseDocValuesAsStored    *          If false, returns all non-stored docValues. If true, returns only those non-stored docValues which have    *          the {@link SchemaField#useDocValuesAsStored()} flag true.    */
DECL|method|getNonStoredDVs
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getNonStoredDVs
parameter_list|(
name|boolean
name|onlyUseDocValuesAsStored
parameter_list|)
block|{
return|return
name|onlyUseDocValuesAsStored
condition|?
name|nonStoredDVsUsedAsStored
else|:
name|allNonStoredDVs
return|;
block|}
comment|/**    * Returns an unmodifiable set of names of non-stored docValues fields, except those that are targets of a copy field.    */
DECL|method|getNonStoredDVsWithoutCopyTargets
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getNonStoredDVsWithoutCopyTargets
parameter_list|()
block|{
return|return
name|nonStoredDVsWithoutCopyTargets
return|;
block|}
block|}
end_class

end_unit

