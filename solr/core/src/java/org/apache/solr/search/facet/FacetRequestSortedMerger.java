begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.apache.solr.search.facet
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|facet
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import

begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|// base class for facets that create a list of buckets that can be sorted
end_comment

begin_class
DECL|class|FacetRequestSortedMerger
specifier|abstract
class|class
name|FacetRequestSortedMerger
parameter_list|<
name|FacetRequestT
extends|extends
name|FacetRequestSorted
parameter_list|>
extends|extends
name|FacetBucketMerger
argument_list|<
name|FacetRequestT
argument_list|>
block|{
DECL|field|buckets
name|LinkedHashMap
argument_list|<
name|Object
argument_list|,
name|FacetBucket
argument_list|>
name|buckets
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|sortedBuckets
name|List
argument_list|<
name|FacetBucket
argument_list|>
name|sortedBuckets
decl_stmt|;
DECL|method|FacetRequestSortedMerger
specifier|public
name|FacetRequestSortedMerger
parameter_list|(
name|FacetRequestT
name|freq
parameter_list|)
block|{
name|super
argument_list|(
name|freq
argument_list|)
expr_stmt|;
block|}
DECL|class|SortVal
specifier|private
specifier|static
class|class
name|SortVal
implements|implements
name|Comparable
argument_list|<
name|SortVal
argument_list|>
block|{
DECL|field|bucket
name|FacetBucket
name|bucket
decl_stmt|;
DECL|field|merger
name|FacetSortableMerger
name|merger
decl_stmt|;
comment|// make this class inner and access merger , direction in parent?
DECL|field|direction
name|FacetRequest
operator|.
name|SortDirection
name|direction
decl_stmt|;
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|SortVal
name|o
parameter_list|)
block|{
name|int
name|c
init|=
operator|-
name|merger
operator|.
name|compareTo
argument_list|(
name|o
operator|.
name|merger
argument_list|,
name|direction
argument_list|)
operator|*
name|direction
operator|.
name|getMultiplier
argument_list|()
decl_stmt|;
return|return
name|c
operator|==
literal|0
condition|?
name|bucket
operator|.
name|bucketValue
operator|.
name|compareTo
argument_list|(
name|o
operator|.
name|bucket
operator|.
name|bucketValue
argument_list|)
else|:
name|c
return|;
block|}
block|}
DECL|method|mergeBucketList
specifier|public
name|void
name|mergeBucketList
parameter_list|(
name|List
argument_list|<
name|SimpleOrderedMap
argument_list|>
name|bucketList
parameter_list|,
name|Context
name|mcontext
parameter_list|)
block|{
for|for
control|(
name|SimpleOrderedMap
name|bucketRes
range|:
name|bucketList
control|)
block|{
name|Comparable
name|bucketVal
init|=
operator|(
name|Comparable
operator|)
name|bucketRes
operator|.
name|get
argument_list|(
literal|"val"
argument_list|)
decl_stmt|;
name|FacetBucket
name|bucket
init|=
name|buckets
operator|.
name|get
argument_list|(
name|bucketVal
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucket
operator|==
literal|null
condition|)
block|{
name|bucket
operator|=
name|newBucket
argument_list|(
name|bucketVal
argument_list|,
name|mcontext
argument_list|)
expr_stmt|;
name|buckets
operator|.
name|put
argument_list|(
name|bucketVal
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
block|}
name|bucket
operator|.
name|mergeBucket
argument_list|(
name|bucketRes
argument_list|,
name|mcontext
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sortBuckets
specifier|public
name|void
name|sortBuckets
parameter_list|()
block|{
name|sortedBuckets
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|buckets
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|Comparator
argument_list|<
name|FacetBucket
argument_list|>
name|comparator
init|=
literal|null
decl_stmt|;
specifier|final
name|FacetRequest
operator|.
name|SortDirection
name|direction
init|=
name|freq
operator|.
name|sortDirection
decl_stmt|;
specifier|final
name|int
name|sortMul
init|=
name|direction
operator|.
name|getMultiplier
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"count"
operator|.
name|equals
argument_list|(
name|freq
operator|.
name|sortVariable
argument_list|)
condition|)
block|{
name|comparator
operator|=
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
block|{
name|int
name|v
init|=
operator|-
name|Long
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|count
argument_list|,
name|o2
operator|.
name|count
argument_list|)
operator|*
name|sortMul
decl_stmt|;
return|return
name|v
operator|==
literal|0
condition|?
name|o1
operator|.
name|bucketValue
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|bucketValue
argument_list|)
else|:
name|v
return|;
block|}
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sortedBuckets
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"index"
operator|.
name|equals
argument_list|(
name|freq
operator|.
name|sortVariable
argument_list|)
condition|)
block|{
name|comparator
operator|=
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
operator|-
name|o1
operator|.
name|bucketValue
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|bucketValue
argument_list|)
operator|*
name|sortMul
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sortedBuckets
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|String
name|key
init|=
name|freq
operator|.
name|sortVariable
decl_stmt|;
comment|/**        final FacetSortableMerger[] arr = new FacetSortableMerger[buckets.size()];        final int[] index = new int[arr.length];        int start = 0;        int nullStart = index.length;        int i=0;        for (FacetBucket bucket : buckets.values()) {        FacetMerger merger = bucket.getExistingMerger(key);        if (merger == null) {        index[--nullStart] = i;        }        if (merger != null) {        arr[start] = (FacetSortableMerger)merger;        index[start] = i;        start++;        }        i++;        }         PrimUtils.sort(0, nullStart, index, new PrimUtils.IntComparator() {       @Override       public int compare(int a, int b) {       return arr[index[a]].compareTo(arr[index[b]], direction);       }       });        **/
name|List
argument_list|<
name|SortVal
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|buckets
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FacetBucket
argument_list|>
name|nulls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|buckets
operator|.
name|size
argument_list|()
operator|>>
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedBuckets
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|FacetBucket
name|bucket
init|=
name|sortedBuckets
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|FacetMerger
name|merger
init|=
name|bucket
operator|.
name|getExistingMerger
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|merger
operator|==
literal|null
condition|)
block|{
name|nulls
operator|.
name|add
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merger
operator|!=
literal|null
condition|)
block|{
name|SortVal
name|sv
init|=
operator|new
name|SortVal
argument_list|()
decl_stmt|;
name|sv
operator|.
name|bucket
operator|=
name|bucket
expr_stmt|;
name|sv
operator|.
name|merger
operator|=
operator|(
name|FacetSortableMerger
operator|)
name|merger
expr_stmt|;
name|sv
operator|.
name|direction
operator|=
name|direction
expr_stmt|;
comment|// sv.pos = i;  // if we need position in the future...
name|lst
operator|.
name|add
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|lst
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|nulls
argument_list|,
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
name|o1
operator|.
name|bucketValue
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|bucketValue
argument_list|)
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|FacetBucket
argument_list|>
name|out
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|buckets
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|SortVal
name|sv
range|:
name|lst
control|)
block|{
name|out
operator|.
name|add
argument_list|(
name|sv
operator|.
name|bucket
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|addAll
argument_list|(
name|nulls
argument_list|)
expr_stmt|;
name|sortedBuckets
operator|=
name|out
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getRefinement
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getRefinement
parameter_list|(
name|Context
name|mcontext
parameter_list|)
block|{
comment|// step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.
comment|// step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.
comment|// A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|refinement
init|=
literal|null
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|tags
init|=
name|mcontext
operator|.
name|getSubsWithRefinement
argument_list|(
name|freq
argument_list|)
decl_stmt|;
if|if
condition|(
name|tags
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|freq
operator|.
name|doRefine
argument_list|()
condition|)
block|{
comment|// we don't have refining, and neither do our subs
return|return
literal|null
return|;
block|}
comment|// Tags for sub facets that have partial facets somewhere in their children.
comment|// If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.
name|Collection
argument_list|<
name|String
argument_list|>
name|tagsWithPartial
init|=
name|mcontext
operator|.
name|getSubsWithPartial
argument_list|(
name|freq
argument_list|)
decl_stmt|;
name|boolean
name|thisMissing
init|=
name|mcontext
operator|.
name|bucketWasMissing
argument_list|()
decl_stmt|;
name|int
name|num
init|=
call|(
name|int
call|)
argument_list|(
name|freq
operator|.
name|offset
operator|+
name|freq
operator|.
name|limit
argument_list|)
decl_stmt|;
name|int
name|numBucketsToCheck
init|=
name|Math
operator|.
name|min
argument_list|(
name|buckets
operator|.
name|size
argument_list|()
argument_list|,
name|num
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|FacetBucket
argument_list|>
name|bucketList
decl_stmt|;
if|if
condition|(
name|buckets
operator|.
name|size
argument_list|()
operator|<
name|num
condition|)
block|{
comment|// no need to sort
comment|// todo: but we may need to filter.... simplify by always sorting?
name|bucketList
operator|=
name|buckets
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// only sort once
if|if
condition|(
name|sortedBuckets
operator|==
literal|null
condition|)
block|{
name|sortBuckets
argument_list|()
expr_stmt|;
comment|// todo: make sure this filters buckets as well
block|}
name|bucketList
operator|=
name|sortedBuckets
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|leafBuckets
init|=
literal|null
decl_stmt|;
comment|// "_l" missing buckets specified by bucket value only (no need to specify anything further)
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|missingBuckets
init|=
literal|null
decl_stmt|;
comment|// "_m" missing buckets that need to specify values for partial facets
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|skipBuckets
init|=
literal|null
decl_stmt|;
comment|// "_s" present buckets that we need to recurse into because children facets have refinement requirements
for|for
control|(
name|FacetBucket
name|bucket
range|:
name|bucketList
control|)
block|{
if|if
condition|(
name|numBucketsToCheck
operator|--
operator|<=
literal|0
condition|)
break|break;
comment|// if this bucket is missing,
assert|assert
name|thisMissing
operator|==
literal|false
operator|||
name|thisMissing
operator|==
literal|true
operator|&&
name|mcontext
operator|.
name|getShardFlag
argument_list|(
name|bucket
operator|.
name|bucketNumber
argument_list|)
operator|==
literal|false
assert|;
name|boolean
name|saw
init|=
operator|!
name|thisMissing
operator|&&
name|mcontext
operator|.
name|getShardFlag
argument_list|(
name|bucket
operator|.
name|bucketNumber
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|saw
condition|)
block|{
comment|// we didn't see the bucket for this shard
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|bucketRefinement
init|=
literal|null
decl_stmt|;
comment|// find facets that we need to fill in buckets for
if|if
condition|(
operator|!
name|tagsWithPartial
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|boolean
name|prev
init|=
name|mcontext
operator|.
name|setBucketWasMissing
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|bucketRefinement
operator|=
name|bucket
operator|.
name|getRefinement
argument_list|(
name|mcontext
argument_list|,
name|tagsWithPartial
argument_list|)
expr_stmt|;
name|mcontext
operator|.
name|setBucketWasMissing
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucketRefinement
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|missingBuckets
operator|==
literal|null
condition|)
name|missingBuckets
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|missingBuckets
operator|.
name|add
argument_list|(
name|bucketRefinement
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if we didn't add to "_m" (missing), then we should add to "_l" (leaf missing)
if|if
condition|(
name|bucketRefinement
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|leafBuckets
operator|==
literal|null
condition|)
name|leafBuckets
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|leafBuckets
operator|.
name|add
argument_list|(
name|bucket
operator|.
name|bucketValue
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|tags
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// we had this bucket, but we need to recurse to certain children that have refinements
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|bucketRefinement
init|=
name|bucket
operator|.
name|getRefinement
argument_list|(
name|mcontext
argument_list|,
name|tagsWithPartial
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketRefinement
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|skipBuckets
operator|==
literal|null
condition|)
name|skipBuckets
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|skipBuckets
operator|.
name|add
argument_list|(
name|bucketRefinement
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...
comment|// because we were "missing".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)
comment|// TODO: test with a sub-facet with a limit of 0 and something like a missing bucket
if|if
condition|(
name|leafBuckets
operator|!=
literal|null
operator|||
name|missingBuckets
operator|!=
literal|null
operator|||
name|skipBuckets
operator|!=
literal|null
condition|)
block|{
name|refinement
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|leafBuckets
operator|!=
literal|null
condition|)
name|refinement
operator|.
name|put
argument_list|(
literal|"_l"
argument_list|,
name|leafBuckets
argument_list|)
expr_stmt|;
if|if
condition|(
name|missingBuckets
operator|!=
literal|null
condition|)
name|refinement
operator|.
name|put
argument_list|(
literal|"_m"
argument_list|,
name|missingBuckets
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipBuckets
operator|!=
literal|null
condition|)
name|refinement
operator|.
name|put
argument_list|(
literal|"_s"
argument_list|,
name|skipBuckets
argument_list|)
expr_stmt|;
block|}
return|return
name|refinement
return|;
block|}
block|}
end_class

end_unit

