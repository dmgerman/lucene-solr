begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.search.facet
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|facet
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|IntFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|NumericDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SimpleCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BitUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LongValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSetUtil
import|;
end_import

begin_comment
comment|/**  * Facets numbers into a hash table.  The number is either a raw numeric DocValues value, or  * a term global ordinal integer.  * Limitations:  *<ul>  *<li>doesn't handle multiValued, but could easily be added</li>  *<li>doesn't handle prefix, but could easily be added</li>  *<li>doesn't handle mincount==0 -- you're better off with an array alg</li>  *</ul>  */
end_comment

begin_class
DECL|class|FacetFieldProcessorByHashDV
class|class
name|FacetFieldProcessorByHashDV
extends|extends
name|FacetFieldProcessor
block|{
DECL|field|MAXIMUM_STARTING_TABLE_SIZE
specifier|static
name|int
name|MAXIMUM_STARTING_TABLE_SIZE
init|=
literal|1024
decl_stmt|;
comment|// must be a power of two, non-final to support setting by tests
comment|/** a hash table with long keys (what we're counting) and integer values (counts) */
DECL|class|LongCounts
specifier|private
specifier|static
class|class
name|LongCounts
block|{
DECL|field|LOAD_FACTOR
specifier|static
specifier|final
name|float
name|LOAD_FACTOR
init|=
literal|0.7f
decl_stmt|;
DECL|field|vals
name|long
index|[]
name|vals
decl_stmt|;
DECL|field|counts
name|int
index|[]
name|counts
decl_stmt|;
comment|// maintain the counts here since we need them to tell if there was actually a value anyway
DECL|field|oldToNewMapping
name|int
index|[]
name|oldToNewMapping
decl_stmt|;
DECL|field|cardinality
name|int
name|cardinality
decl_stmt|;
DECL|field|threshold
name|int
name|threshold
decl_stmt|;
comment|/** sz must be a power of two */
DECL|method|LongCounts
name|LongCounts
parameter_list|(
name|int
name|sz
parameter_list|)
block|{
name|vals
operator|=
operator|new
name|long
index|[
name|sz
index|]
expr_stmt|;
name|counts
operator|=
operator|new
name|int
index|[
name|sz
index|]
expr_stmt|;
name|threshold
operator|=
call|(
name|int
call|)
argument_list|(
name|sz
operator|*
name|LOAD_FACTOR
argument_list|)
expr_stmt|;
block|}
comment|/** Current number of slots in the hash table */
DECL|method|numSlots
name|int
name|numSlots
parameter_list|()
block|{
return|return
name|vals
operator|.
name|length
return|;
block|}
DECL|method|hash
specifier|private
name|int
name|hash
parameter_list|(
name|long
name|val
parameter_list|)
block|{
comment|// For floats: exponent bits start at bit 23 for single precision,
comment|// and bit 52 for double precision.
comment|// Many values will only have significant bits just to the right of that,
comment|// and the leftmost bits will all be zero.
comment|// For now, lets just settle to get first 8 significant mantissa bits of double or float in the lowest bits of our hash
comment|// The upper bits of our hash will be irrelevant.
name|int
name|h
init|=
call|(
name|int
call|)
argument_list|(
name|val
operator|+
operator|(
name|val
operator|>>>
literal|44
operator|)
operator|+
operator|(
name|val
operator|>>>
literal|15
operator|)
argument_list|)
decl_stmt|;
return|return
name|h
return|;
block|}
comment|/** returns the slot */
DECL|method|add
name|int
name|add
parameter_list|(
name|long
name|val
parameter_list|)
block|{
if|if
condition|(
name|cardinality
operator|>=
name|threshold
condition|)
block|{
name|rehash
argument_list|()
expr_stmt|;
block|}
name|int
name|h
init|=
name|hash
argument_list|(
name|val
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|slot
init|=
name|h
operator|&
operator|(
name|vals
operator|.
name|length
operator|-
literal|1
operator|)
init|;
condition|;
name|slot
operator|=
operator|(
name|slot
operator|+
operator|(
operator|(
name|h
operator|>>
literal|7
operator|)
operator||
literal|1
operator|)
operator|)
operator|&
operator|(
name|vals
operator|.
name|length
operator|-
literal|1
operator|)
control|)
block|{
name|int
name|count
init|=
name|counts
index|[
name|slot
index|]
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|counts
index|[
name|slot
index|]
operator|=
literal|1
expr_stmt|;
name|vals
index|[
name|slot
index|]
operator|=
name|val
expr_stmt|;
name|cardinality
operator|++
expr_stmt|;
return|return
name|slot
return|;
block|}
elseif|else
if|if
condition|(
name|vals
index|[
name|slot
index|]
operator|==
name|val
condition|)
block|{
comment|// val is already in the set
name|counts
index|[
name|slot
index|]
operator|=
name|count
operator|+
literal|1
expr_stmt|;
return|return
name|slot
return|;
block|}
block|}
block|}
DECL|method|rehash
specifier|protected
name|void
name|rehash
parameter_list|()
block|{
name|long
index|[]
name|oldVals
init|=
name|vals
decl_stmt|;
name|int
index|[]
name|oldCounts
init|=
name|counts
decl_stmt|;
comment|// after retrieving the count, this array is reused as a mapping to new array
name|int
name|newCapacity
init|=
name|vals
operator|.
name|length
operator|<<
literal|1
decl_stmt|;
name|vals
operator|=
operator|new
name|long
index|[
name|newCapacity
index|]
expr_stmt|;
name|counts
operator|=
operator|new
name|int
index|[
name|newCapacity
index|]
expr_stmt|;
name|threshold
operator|=
call|(
name|int
call|)
argument_list|(
name|newCapacity
operator|*
name|LOAD_FACTOR
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|count
init|=
name|oldCounts
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|oldCounts
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|long
name|val
init|=
name|oldVals
index|[
name|i
index|]
decl_stmt|;
name|int
name|h
init|=
name|hash
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|int
name|slot
init|=
name|h
operator|&
operator|(
name|vals
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|counts
index|[
name|slot
index|]
operator|!=
literal|0
condition|)
block|{
name|slot
operator|=
operator|(
name|slot
operator|+
operator|(
operator|(
name|h
operator|>>
literal|7
operator|)
operator||
literal|1
operator|)
operator|)
operator|&
operator|(
name|vals
operator|.
name|length
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|counts
index|[
name|slot
index|]
operator|=
name|count
expr_stmt|;
name|vals
index|[
name|slot
index|]
operator|=
name|val
expr_stmt|;
name|oldCounts
index|[
name|i
index|]
operator|=
name|slot
expr_stmt|;
block|}
name|oldToNewMapping
operator|=
name|oldCounts
expr_stmt|;
block|}
DECL|method|cardinality
name|int
name|cardinality
parameter_list|()
block|{
return|return
name|cardinality
return|;
block|}
block|}
comment|/** A hack instance of Calc for Term ordinals in DocValues. */
comment|// TODO consider making FacetRangeProcessor.Calc facet top level; then less of a hack?
DECL|class|TermOrdCalc
specifier|private
class|class
name|TermOrdCalc
extends|extends
name|FacetRangeProcessor
operator|.
name|Calc
block|{
DECL|field|lookupOrdFunction
name|IntFunction
argument_list|<
name|BytesRef
argument_list|>
name|lookupOrdFunction
decl_stmt|;
comment|// set in collectDocs()!
DECL|method|TermOrdCalc
name|TermOrdCalc
parameter_list|()
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|bitsToSortableBits
specifier|public
name|long
name|bitsToSortableBits
parameter_list|(
name|long
name|globalOrd
parameter_list|)
block|{
return|return
name|globalOrd
return|;
block|}
comment|/** To be returned in "buckets"/"val" */
annotation|@
name|Override
DECL|method|bitsToValue
specifier|public
name|Comparable
name|bitsToValue
parameter_list|(
name|long
name|globalOrd
parameter_list|)
block|{
name|BytesRef
name|bytesRef
init|=
name|lookupOrdFunction
operator|.
name|apply
argument_list|(
operator|(
name|int
operator|)
name|globalOrd
argument_list|)
decl_stmt|;
comment|// note FacetFieldProcessorByArray.findTopSlots also calls SchemaFieldType.toObject
return|return
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|sf
argument_list|,
name|bytesRef
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|formatValue
specifier|public
name|String
name|formatValue
parameter_list|(
name|Comparable
name|val
parameter_list|)
block|{
return|return
operator|(
name|String
operator|)
name|val
return|;
block|}
annotation|@
name|Override
DECL|method|parseStr
specifier|protected
name|Comparable
name|parseStr
parameter_list|(
name|String
name|rawval
parameter_list|)
throws|throws
name|ParseException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|parseAndAddGap
specifier|protected
name|Comparable
name|parseAndAddGap
parameter_list|(
name|Comparable
name|value
parameter_list|,
name|String
name|gap
parameter_list|)
throws|throws
name|ParseException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
DECL|field|calc
name|FacetRangeProcessor
operator|.
name|Calc
name|calc
decl_stmt|;
DECL|field|table
name|LongCounts
name|table
decl_stmt|;
DECL|field|allBucketsSlot
name|int
name|allBucketsSlot
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|FacetFieldProcessorByHashDV
name|FacetFieldProcessorByHashDV
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|,
name|FacetField
name|freq
parameter_list|,
name|SchemaField
name|sf
parameter_list|)
block|{
name|super
argument_list|(
name|fcontext
argument_list|,
name|freq
argument_list|,
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|.
name|mincount
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|getClass
argument_list|()
operator|+
literal|" doesn't support mincount=0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|freq
operator|.
name|prefix
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|getClass
argument_list|()
operator|+
literal|" doesn't support prefix"
argument_list|)
throw|;
comment|// yet, but it could
block|}
name|FieldInfo
name|fieldInfo
init|=
name|fcontext
operator|.
name|searcher
operator|.
name|getSlowAtomicReader
argument_list|()
operator|.
name|getFieldInfos
argument_list|()
operator|.
name|fieldInfo
argument_list|(
name|sf
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldInfo
operator|!=
literal|null
operator|&&
name|fieldInfo
operator|.
name|getDocValuesType
argument_list|()
operator|!=
name|DocValuesType
operator|.
name|NUMERIC
operator|&&
name|fieldInfo
operator|.
name|getDocValuesType
argument_list|()
operator|!=
name|DocValuesType
operator|.
name|SORTED
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|getClass
argument_list|()
operator|+
literal|" only support single valued number/string with docValues"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|process
argument_list|()
expr_stmt|;
name|response
operator|=
name|calcFacets
argument_list|()
expr_stmt|;
name|table
operator|=
literal|null
expr_stmt|;
comment|//gc
block|}
DECL|method|calcFacets
specifier|private
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|calcFacets
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|getNumberType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|calc
operator|=
name|FacetRangeProcessor
operator|.
name|getNumericCalc
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|calc
operator|=
operator|new
name|TermOrdCalc
argument_list|()
expr_stmt|;
comment|// kind of a hack
block|}
comment|// TODO: Use the number of indexed terms, if present, as an estimate!
comment|//    Even for NumericDocValues, we could check for a terms index for an estimate.
comment|//    Our estimation should aim high to avoid expensive rehashes.
name|int
name|possibleValues
init|=
name|fcontext
operator|.
name|base
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// size smaller tables so that no resize will be necessary
name|int
name|currHashSize
init|=
name|BitUtil
operator|.
name|nextHighestPowerOfTwo
argument_list|(
call|(
name|int
call|)
argument_list|(
name|possibleValues
operator|*
operator|(
literal|1
operator|/
name|LongCounts
operator|.
name|LOAD_FACTOR
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|currHashSize
operator|=
name|Math
operator|.
name|min
argument_list|(
name|currHashSize
argument_list|,
name|MAXIMUM_STARTING_TABLE_SIZE
argument_list|)
expr_stmt|;
name|table
operator|=
operator|new
name|LongCounts
argument_list|(
name|currHashSize
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|rehash
parameter_list|()
block|{
name|super
operator|.
name|rehash
argument_list|()
expr_stmt|;
name|doRehash
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|oldToNewMapping
operator|=
literal|null
expr_stmt|;
comment|// allow for gc
block|}
block|}
expr_stmt|;
comment|// note: these methods/phases align with FacetFieldProcessorByArray's
name|createCollectAcc
argument_list|()
expr_stmt|;
name|collectDocs
argument_list|()
expr_stmt|;
return|return
name|super
operator|.
name|findTopSlots
argument_list|(
name|table
operator|.
name|numSlots
argument_list|()
argument_list|,
name|table
operator|.
name|cardinality
argument_list|()
argument_list|,
name|slotNum
lambda|->
name|calc
operator|.
name|bitsToValue
argument_list|(
name|table
operator|.
name|vals
index|[
name|slotNum
index|]
argument_list|)
argument_list|,
comment|// getBucketValFromSlotNum
name|val
lambda|->
name|calc
operator|.
name|formatValue
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
comment|// getFieldQueryVal
block|}
DECL|method|createCollectAcc
specifier|private
name|void
name|createCollectAcc
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|numSlots
init|=
name|table
operator|.
name|numSlots
argument_list|()
decl_stmt|;
if|if
condition|(
name|freq
operator|.
name|allBuckets
condition|)
block|{
name|allBucketsSlot
operator|=
name|numSlots
operator|++
expr_stmt|;
block|}
name|indexOrderAcc
operator|=
operator|new
name|SlotAcc
argument_list|(
name|fcontext
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|int
name|slot
parameter_list|)
throws|throws
name|IOException
block|{       }
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|int
name|slotA
parameter_list|,
name|int
name|slotB
parameter_list|)
block|{
name|long
name|s1
init|=
name|calc
operator|.
name|bitsToSortableBits
argument_list|(
name|table
operator|.
name|vals
index|[
name|slotA
index|]
argument_list|)
decl_stmt|;
name|long
name|s2
init|=
name|calc
operator|.
name|bitsToSortableBits
argument_list|(
name|table
operator|.
name|vals
index|[
name|slotB
index|]
argument_list|)
decl_stmt|;
return|return
name|Long
operator|.
name|compare
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getValue
parameter_list|(
name|int
name|slotNum
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{       }
annotation|@
name|Override
specifier|public
name|void
name|resize
parameter_list|(
name|Resizer
name|resizer
parameter_list|)
block|{       }
block|}
expr_stmt|;
name|countAcc
operator|=
operator|new
name|CountSlotAcc
argument_list|(
name|fcontext
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|incrementCount
parameter_list|(
name|int
name|slot
parameter_list|,
name|int
name|count
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getCount
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
return|return
name|table
operator|.
name|counts
index|[
name|slot
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getValue
parameter_list|(
name|int
name|slotNum
parameter_list|)
block|{
return|return
name|getCount
argument_list|(
name|slotNum
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|int
name|slot
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|int
name|slotA
parameter_list|,
name|int
name|slotB
parameter_list|)
block|{
return|return
name|Integer
operator|.
name|compare
argument_list|(
name|table
operator|.
name|counts
index|[
name|slotA
index|]
argument_list|,
name|table
operator|.
name|counts
index|[
name|slotB
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|resize
parameter_list|(
name|Resizer
name|resizer
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
expr_stmt|;
comment|// we set the countAcc& indexAcc first so generic ones won't be created for us.
name|super
operator|.
name|createCollectAcc
argument_list|(
name|fcontext
operator|.
name|base
operator|.
name|size
argument_list|()
argument_list|,
name|numSlots
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|.
name|allBuckets
condition|)
block|{
name|allBucketsAcc
operator|=
operator|new
name|SpecialSlotAcc
argument_list|(
name|fcontext
argument_list|,
name|collectAcc
argument_list|,
name|allBucketsSlot
argument_list|,
name|otherAccs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|collectDocs
specifier|private
name|void
name|collectDocs
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|calc
operator|instanceof
name|TermOrdCalc
condition|)
block|{
comment|// Strings
comment|// TODO support SortedSetDocValues
name|SortedDocValues
name|globalDocValues
init|=
name|FieldUtil
operator|.
name|getSortedDocValues
argument_list|(
name|fcontext
operator|.
name|qcontext
argument_list|,
name|sf
argument_list|,
literal|null
argument_list|)
decl_stmt|;
operator|(
operator|(
name|TermOrdCalc
operator|)
name|calc
operator|)
operator|.
name|lookupOrdFunction
operator|=
name|ord
lambda|->
block|{
try|try
block|{
return|return
name|globalDocValues
operator|.
name|lookupOrd
argument_list|(
name|ord
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
expr_stmt|;
name|DocSetUtil
operator|.
name|collectSortedDocSet
argument_list|(
name|fcontext
operator|.
name|base
argument_list|,
name|fcontext
operator|.
name|searcher
operator|.
name|getIndexReader
argument_list|()
argument_list|,
operator|new
name|SimpleCollector
argument_list|()
block|{
name|SortedDocValues
name|docValues
init|=
name|globalDocValues
decl_stmt|;
comment|// this segment/leaf. NN
name|LongValues
name|toGlobal
init|=
name|LongValues
operator|.
name|IDENTITY
decl_stmt|;
comment|// this segment to global ordinal. NN
annotation|@
name|Override
specifier|public
name|boolean
name|needsScores
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doSetNextReader
parameter_list|(
name|LeafReaderContext
name|ctx
parameter_list|)
throws|throws
name|IOException
block|{
name|setNextReaderFirstPhase
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|globalDocValues
operator|instanceof
name|MultiDocValues
operator|.
name|MultiSortedDocValues
condition|)
block|{
name|MultiDocValues
operator|.
name|MultiSortedDocValues
name|multiDocValues
init|=
operator|(
name|MultiDocValues
operator|.
name|MultiSortedDocValues
operator|)
name|globalDocValues
decl_stmt|;
name|docValues
operator|=
name|multiDocValues
operator|.
name|values
index|[
name|ctx
operator|.
name|ord
index|]
expr_stmt|;
name|toGlobal
operator|=
name|multiDocValues
operator|.
name|mapping
operator|.
name|getGlobalOrds
argument_list|(
name|ctx
operator|.
name|ord
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|segDoc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|segDoc
operator|>
name|docValues
operator|.
name|docID
argument_list|()
condition|)
block|{
name|docValues
operator|.
name|advance
argument_list|(
name|segDoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|segDoc
operator|==
name|docValues
operator|.
name|docID
argument_list|()
condition|)
block|{
name|long
name|val
init|=
name|toGlobal
operator|.
name|get
argument_list|(
name|docValues
operator|.
name|ordValue
argument_list|()
argument_list|)
decl_stmt|;
name|collectValFirstPhase
argument_list|(
name|segDoc
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Numeric:
comment|// TODO support SortedNumericDocValues
name|DocSetUtil
operator|.
name|collectSortedDocSet
argument_list|(
name|fcontext
operator|.
name|base
argument_list|,
name|fcontext
operator|.
name|searcher
operator|.
name|getIndexReader
argument_list|()
argument_list|,
operator|new
name|SimpleCollector
argument_list|()
block|{
name|NumericDocValues
name|values
init|=
literal|null
decl_stmt|;
comment|//NN
annotation|@
name|Override
specifier|public
name|boolean
name|needsScores
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doSetNextReader
parameter_list|(
name|LeafReaderContext
name|ctx
parameter_list|)
throws|throws
name|IOException
block|{
name|setNextReaderFirstPhase
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|values
operator|=
name|DocValues
operator|.
name|getNumeric
argument_list|(
name|ctx
operator|.
name|reader
argument_list|()
argument_list|,
name|sf
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|segDoc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|segDoc
operator|>
name|values
operator|.
name|docID
argument_list|()
condition|)
block|{
name|values
operator|.
name|advance
argument_list|(
name|segDoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|segDoc
operator|==
name|values
operator|.
name|docID
argument_list|()
condition|)
block|{
name|collectValFirstPhase
argument_list|(
name|segDoc
argument_list|,
name|values
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|collectValFirstPhase
specifier|private
name|void
name|collectValFirstPhase
parameter_list|(
name|int
name|segDoc
parameter_list|,
name|long
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|slot
init|=
name|table
operator|.
name|add
argument_list|(
name|val
argument_list|)
decl_stmt|;
comment|// this can trigger a rehash
comment|// Our countAcc is virtual, so this is not needed:
comment|// countAcc.incrementCount(slot, 1);
name|super
operator|.
name|collectFirstPhase
argument_list|(
name|segDoc
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
DECL|method|doRehash
specifier|private
name|void
name|doRehash
parameter_list|(
name|LongCounts
name|table
parameter_list|)
block|{
if|if
condition|(
name|collectAcc
operator|==
literal|null
operator|&&
name|allBucketsAcc
operator|==
literal|null
condition|)
return|return;
comment|// Our "count" acc is backed by the hash table and will already be rehashed
comment|// otherAccs don't need to be rehashed
name|int
name|newTableSize
init|=
name|table
operator|.
name|numSlots
argument_list|()
decl_stmt|;
name|int
name|numSlots
init|=
name|newTableSize
decl_stmt|;
specifier|final
name|int
name|oldAllBucketsSlot
init|=
name|allBucketsSlot
decl_stmt|;
if|if
condition|(
name|oldAllBucketsSlot
operator|>=
literal|0
condition|)
block|{
name|allBucketsSlot
operator|=
name|numSlots
operator|++
expr_stmt|;
block|}
specifier|final
name|int
name|finalNumSlots
init|=
name|numSlots
decl_stmt|;
specifier|final
name|int
index|[]
name|mapping
init|=
name|table
operator|.
name|oldToNewMapping
decl_stmt|;
name|SlotAcc
operator|.
name|Resizer
name|resizer
init|=
operator|new
name|SlotAcc
operator|.
name|Resizer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|getNewSize
parameter_list|()
block|{
return|return
name|finalNumSlots
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getNewSlot
parameter_list|(
name|int
name|oldSlot
parameter_list|)
block|{
if|if
condition|(
name|oldSlot
operator|<
name|mapping
operator|.
name|length
condition|)
block|{
return|return
name|mapping
index|[
name|oldSlot
index|]
return|;
block|}
if|if
condition|(
name|oldSlot
operator|==
name|oldAllBucketsSlot
condition|)
block|{
return|return
name|allBucketsSlot
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
decl_stmt|;
comment|// NOTE: resizing isn't strictly necessary for missing/allBuckets... we could just set the new slot directly
if|if
condition|(
name|collectAcc
operator|!=
literal|null
condition|)
block|{
name|collectAcc
operator|.
name|resize
argument_list|(
name|resizer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allBucketsAcc
operator|!=
literal|null
condition|)
block|{
name|allBucketsAcc
operator|.
name|resize
argument_list|(
name|resizer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

