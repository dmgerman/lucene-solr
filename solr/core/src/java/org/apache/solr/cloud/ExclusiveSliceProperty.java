begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|overseer
operator|.
name|ClusterStateMutator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|overseer
operator|.
name|CollectionMutator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|overseer
operator|.
name|SliceMutator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkNodeProps
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|OverseerCollectionMessageHandler
operator|.
name|ONLY_ACTIVE_NODES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|OverseerCollectionMessageHandler
operator|.
name|SHARD_UNIQUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CollectionParams
operator|.
name|CollectionAction
operator|.
name|BALANCESHARDUNIQUE
import|;
end_import

begin_comment
comment|// Class to encapsulate processing replica properties that have at most one replica hosting a property per slice.
end_comment

begin_class
DECL|class|ExclusiveSliceProperty
class|class
name|ExclusiveSliceProperty
block|{
DECL|field|clusterState
specifier|private
name|ClusterState
name|clusterState
decl_stmt|;
DECL|field|onlyActiveNodes
specifier|private
specifier|final
name|boolean
name|onlyActiveNodes
decl_stmt|;
DECL|field|property
specifier|private
specifier|final
name|String
name|property
decl_stmt|;
DECL|field|collection
specifier|private
specifier|final
name|DocCollection
name|collection
decl_stmt|;
DECL|field|collectionName
specifier|private
specifier|final
name|String
name|collectionName
decl_stmt|;
comment|// Key structure. For each node, list all replicas on it regardless of whether they have the property or not.
DECL|field|nodesHostingReplicas
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|nodesHostingReplicas
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Key structure. For each node, a list of the replicas _currently_ hosting the property.
DECL|field|nodesHostingProp
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|nodesHostingProp
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|shardsNeedingHosts
name|Set
argument_list|<
name|String
argument_list|>
name|shardsNeedingHosts
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|changedSlices
name|Map
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|changedSlices
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Work on copies rather than the underlying cluster state.
DECL|field|origMaxPropPerNode
specifier|private
name|int
name|origMaxPropPerNode
init|=
literal|0
decl_stmt|;
DECL|field|origModulo
specifier|private
name|int
name|origModulo
init|=
literal|0
decl_stmt|;
DECL|field|tmpMaxPropPerNode
specifier|private
name|int
name|tmpMaxPropPerNode
init|=
literal|0
decl_stmt|;
DECL|field|tmpModulo
specifier|private
name|int
name|tmpModulo
init|=
literal|0
decl_stmt|;
DECL|field|rand
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
DECL|field|assigned
specifier|private
name|int
name|assigned
init|=
literal|0
decl_stmt|;
DECL|method|ExclusiveSliceProperty
name|ExclusiveSliceProperty
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|,
name|ZkNodeProps
name|message
parameter_list|)
block|{
name|this
operator|.
name|clusterState
operator|=
name|clusterState
expr_stmt|;
name|String
name|tmp
init|=
name|message
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|PROPERTY_PROP
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|startsWith
argument_list|(
name|tmp
argument_list|,
name|OverseerCollectionMessageHandler
operator|.
name|COLL_PROP_PREFIX
argument_list|)
operator|==
literal|false
condition|)
block|{
name|tmp
operator|=
name|OverseerCollectionMessageHandler
operator|.
name|COLL_PROP_PREFIX
operator|+
name|tmp
expr_stmt|;
block|}
name|this
operator|.
name|property
operator|=
name|tmp
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
expr_stmt|;
name|collectionName
operator|=
name|message
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|COLLECTION_PROP
argument_list|)
expr_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|collectionName
argument_list|)
operator|||
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|property
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Overseer '"
operator|+
name|message
operator|.
name|getStr
argument_list|(
name|Overseer
operator|.
name|QUEUE_OPERATION
argument_list|)
operator|+
literal|"'  requires both the '"
operator|+
name|ZkStateReader
operator|.
name|COLLECTION_PROP
operator|+
literal|"' and '"
operator|+
name|ZkStateReader
operator|.
name|PROPERTY_PROP
operator|+
literal|"' parameters. No action taken "
argument_list|)
throw|;
block|}
name|Boolean
name|shardUnique
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|message
operator|.
name|getStr
argument_list|(
name|SHARD_UNIQUE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|shardUnique
operator|==
literal|false
operator|&&
name|SliceMutator
operator|.
name|SLICE_UNIQUE_BOOLEAN_PROPERTIES
operator|.
name|contains
argument_list|(
name|this
operator|.
name|property
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Balancing properties amongst replicas in a slice requires that"
operator|+
literal|" the property be a pre-defined property (e.g. 'preferredLeader') or that 'shardUnique' be set to 'true' "
operator|+
literal|" Property: "
operator|+
name|this
operator|.
name|property
operator|+
literal|" shardUnique: "
operator|+
name|Boolean
operator|.
name|toString
argument_list|(
name|shardUnique
argument_list|)
argument_list|)
throw|;
block|}
name|collection
operator|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|collectionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Could not find collection ' "
operator|+
name|collectionName
operator|+
literal|"' for overseer operation '"
operator|+
name|message
operator|.
name|getStr
argument_list|(
name|Overseer
operator|.
name|QUEUE_OPERATION
argument_list|)
operator|+
literal|"'. No action taken."
argument_list|)
throw|;
block|}
name|onlyActiveNodes
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|message
operator|.
name|getStr
argument_list|(
name|ONLY_ACTIVE_NODES
argument_list|,
literal|"true"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getDocCollection
name|DocCollection
name|getDocCollection
parameter_list|()
block|{
return|return
name|collection
return|;
block|}
DECL|method|isActive
specifier|private
name|boolean
name|isActive
parameter_list|(
name|Replica
name|replica
parameter_list|)
block|{
return|return
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|Replica
operator|.
name|State
operator|.
name|ACTIVE
return|;
block|}
comment|// Collect a list of all the nodes that _can_ host the indicated property. Along the way, also collect any of
comment|// the replicas on that node that _already_ host the property as well as any slices that do _not_ have the
comment|// property hosted.
comment|//
comment|// Return true if anything node needs it's property reassigned. False if the property is already balanced for
comment|// the collection.
DECL|method|collectCurrentPropStats
specifier|private
name|boolean
name|collectCurrentPropStats
parameter_list|()
block|{
name|int
name|maxAssigned
init|=
literal|0
decl_stmt|;
comment|// Get a list of potential replicas that can host the property _and_ their counts
comment|// Move any obvious entries to a list of replicas to change the property on
name|Set
argument_list|<
name|String
argument_list|>
name|allHosts
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Slice
name|slice
range|:
name|collection
operator|.
name|getSlices
argument_list|()
control|)
block|{
name|boolean
name|sliceHasProp
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Replica
name|replica
range|:
name|slice
operator|.
name|getReplicas
argument_list|()
control|)
block|{
if|if
condition|(
name|onlyActiveNodes
operator|&&
name|isActive
argument_list|(
name|replica
argument_list|)
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isNotBlank
argument_list|(
name|replica
operator|.
name|getStr
argument_list|(
name|property
argument_list|)
argument_list|)
condition|)
block|{
name|removeProp
argument_list|(
name|slice
argument_list|,
name|replica
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Note, we won't be committing this to ZK until later.
block|}
continue|continue;
block|}
name|allHosts
operator|.
name|add
argument_list|(
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|nodeName
init|=
name|replica
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isNotBlank
argument_list|(
name|replica
operator|.
name|getStr
argument_list|(
name|property
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|sliceHasProp
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"'"
operator|+
name|BALANCESHARDUNIQUE
operator|+
literal|"' should only be called for properties that have at most one member "
operator|+
literal|"in any slice with the property set. No action taken."
argument_list|)
throw|;
block|}
if|if
condition|(
name|nodesHostingProp
operator|.
name|containsKey
argument_list|(
name|nodeName
argument_list|)
operator|==
literal|false
condition|)
block|{
name|nodesHostingProp
operator|.
name|put
argument_list|(
name|nodeName
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodesHostingProp
operator|.
name|get
argument_list|(
name|nodeName
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|SliceReplica
argument_list|(
name|slice
argument_list|,
name|replica
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|assigned
expr_stmt|;
name|maxAssigned
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxAssigned
argument_list|,
name|nodesHostingProp
operator|.
name|get
argument_list|(
name|nodeName
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|sliceHasProp
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|nodesHostingReplicas
operator|.
name|containsKey
argument_list|(
name|nodeName
argument_list|)
operator|==
literal|false
condition|)
block|{
name|nodesHostingReplicas
operator|.
name|put
argument_list|(
name|nodeName
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodesHostingReplicas
operator|.
name|get
argument_list|(
name|nodeName
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|SliceReplica
argument_list|(
name|slice
argument_list|,
name|replica
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If the total number of already-hosted properties assigned to nodes
comment|// that have potential to host leaders is equal to the slice count _AND_ none of the current nodes has more than
comment|// the max number of properties, there's nothing to do.
name|origMaxPropPerNode
operator|=
name|collection
operator|.
name|getSlices
argument_list|()
operator|.
name|size
argument_list|()
operator|/
name|allHosts
operator|.
name|size
argument_list|()
expr_stmt|;
comment|// Some nodes can have one more of the proeprty if the numbers aren't exactly even.
name|origModulo
operator|=
name|collection
operator|.
name|getSlices
argument_list|()
operator|.
name|size
argument_list|()
operator|%
name|allHosts
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|origModulo
operator|>
literal|0
condition|)
block|{
name|origMaxPropPerNode
operator|++
expr_stmt|;
comment|// have to have some nodes with 1 more property.
block|}
comment|// We can say for sure that we need to rebalance if we don't have as many assigned properties as slices.
if|if
condition|(
name|assigned
operator|!=
name|collection
operator|.
name|getSlices
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Make sure there are no more slices at the limit than the "leftovers"
comment|// Let's say there's 7 slices and 3 nodes. We need to distribute the property as 3 on node1, 2 on node2 and 2 on node3
comment|// (3, 2, 2) We need to be careful to not distribute them as 3, 3, 1. that's what this check is all about.
name|int
name|counter
init|=
name|origModulo
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|SliceReplica
argument_list|>
name|list
range|:
name|nodesHostingProp
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
name|origMaxPropPerNode
condition|)
operator|--
name|counter
expr_stmt|;
block|}
if|if
condition|(
name|counter
operator|==
literal|0
condition|)
return|return
literal|false
return|;
comment|// nodes with 1 extra leader are exactly the needed number
return|return
literal|true
return|;
block|}
DECL|method|removeSliceAlreadyHostedFromPossibles
specifier|private
name|void
name|removeSliceAlreadyHostedFromPossibles
parameter_list|(
name|String
name|sliceName
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|entReplica
range|:
name|nodesHostingReplicas
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ListIterator
argument_list|<
name|SliceReplica
argument_list|>
name|iter
init|=
name|entReplica
operator|.
name|getValue
argument_list|()
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SliceReplica
name|sr
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|sr
operator|.
name|slice
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|sliceName
argument_list|)
condition|)
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|balanceUnassignedReplicas
specifier|private
name|void
name|balanceUnassignedReplicas
parameter_list|()
block|{
name|tmpMaxPropPerNode
operator|=
name|origMaxPropPerNode
expr_stmt|;
comment|// A bit clumsy, but don't want to duplicate code.
name|tmpModulo
operator|=
name|origModulo
expr_stmt|;
comment|// Get the nodeName and shardName for the node that has the least room for this
while|while
condition|(
name|shardsNeedingHosts
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|nodeName
init|=
literal|""
decl_stmt|;
name|int
name|minSize
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|SliceReplica
name|srToChange
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|slice
range|:
name|shardsNeedingHosts
control|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|ent
range|:
name|nodesHostingReplicas
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// A little tricky. If we don't set this to something below, then it means all possible places to
comment|// put this property are full up, so just put it somewhere.
if|if
condition|(
name|srToChange
operator|==
literal|null
operator|&&
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|srToChange
operator|=
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ListIterator
argument_list|<
name|SliceReplica
argument_list|>
name|iter
init|=
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SliceReplica
name|sr
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|equals
argument_list|(
name|slice
argument_list|,
name|sr
operator|.
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|nodesHostingProp
operator|.
name|containsKey
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
name|nodesHostingProp
operator|.
name|put
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|SliceReplica
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minSize
operator|>
name|nodesHostingReplicas
operator|.
name|get
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
operator|&&
name|nodesHostingProp
operator|.
name|get
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
operator|<
name|tmpMaxPropPerNode
condition|)
block|{
name|minSize
operator|=
name|nodesHostingReplicas
operator|.
name|get
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
name|srToChange
operator|=
name|sr
expr_stmt|;
name|nodeName
operator|=
name|ent
operator|.
name|getKey
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Now, you have a slice and node to put it on
name|shardsNeedingHosts
operator|.
name|remove
argument_list|(
name|srToChange
operator|.
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodesHostingProp
operator|.
name|containsKey
argument_list|(
name|nodeName
argument_list|)
operator|==
literal|false
condition|)
block|{
name|nodesHostingProp
operator|.
name|put
argument_list|(
name|nodeName
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|SliceReplica
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodesHostingProp
operator|.
name|get
argument_list|(
name|nodeName
argument_list|)
operator|.
name|add
argument_list|(
name|srToChange
argument_list|)
expr_stmt|;
name|adjustLimits
argument_list|(
name|nodesHostingProp
operator|.
name|get
argument_list|(
name|nodeName
argument_list|)
argument_list|)
expr_stmt|;
name|removeSliceAlreadyHostedFromPossibles
argument_list|(
name|srToChange
operator|.
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|addProp
argument_list|(
name|srToChange
operator|.
name|slice
argument_list|,
name|srToChange
operator|.
name|replica
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Adjust the min/max counts per allowed per node. Special handling here for dealing with the fact
comment|// that no node should have more than 1 more replica with this property than any other.
DECL|method|adjustLimits
specifier|private
name|void
name|adjustLimits
parameter_list|(
name|List
argument_list|<
name|SliceReplica
argument_list|>
name|changeList
parameter_list|)
block|{
if|if
condition|(
name|changeList
operator|.
name|size
argument_list|()
operator|==
name|tmpMaxPropPerNode
condition|)
block|{
if|if
condition|(
name|tmpModulo
operator|<
literal|0
condition|)
return|return;
operator|--
name|tmpModulo
expr_stmt|;
if|if
condition|(
name|tmpModulo
operator|==
literal|0
condition|)
block|{
operator|--
name|tmpMaxPropPerNode
expr_stmt|;
operator|--
name|tmpModulo
expr_stmt|;
comment|// Prevent dropping tmpMaxPropPerNode again.
block|}
block|}
block|}
comment|// Go through the list of presently-hosted properties and remove any that have too many replicas that host the property
DECL|method|removeOverallocatedReplicas
specifier|private
name|void
name|removeOverallocatedReplicas
parameter_list|()
block|{
name|tmpMaxPropPerNode
operator|=
name|origMaxPropPerNode
expr_stmt|;
comment|// A bit clumsy, but don't want to duplicate code.
name|tmpModulo
operator|=
name|origModulo
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|ent
range|:
name|nodesHostingProp
operator|.
name|entrySet
argument_list|()
control|)
block|{
while|while
condition|(
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
operator|>
name|tmpMaxPropPerNode
condition|)
block|{
comment|// remove delta nodes
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|remove
argument_list|(
name|rand
operator|.
name|nextInt
argument_list|(
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|adjustLimits
argument_list|(
name|ent
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeProp
specifier|private
name|void
name|removeProp
parameter_list|(
name|Slice
name|origSlice
parameter_list|,
name|String
name|replicaName
parameter_list|)
block|{
name|getReplicaFromChanged
argument_list|(
name|origSlice
argument_list|,
name|replicaName
argument_list|)
operator|.
name|getProperties
argument_list|()
operator|.
name|remove
argument_list|(
name|property
argument_list|)
expr_stmt|;
block|}
DECL|method|addProp
specifier|private
name|void
name|addProp
parameter_list|(
name|Slice
name|origSlice
parameter_list|,
name|String
name|replicaName
parameter_list|)
block|{
name|getReplicaFromChanged
argument_list|(
name|origSlice
argument_list|,
name|replicaName
argument_list|)
operator|.
name|getProperties
argument_list|()
operator|.
name|put
argument_list|(
name|property
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
comment|// Just a place to encapsulate the fact that we need to have new slices (copy) to update before we
comment|// put this all in the cluster state.
DECL|method|getReplicaFromChanged
specifier|private
name|Replica
name|getReplicaFromChanged
parameter_list|(
name|Slice
name|origSlice
parameter_list|,
name|String
name|replicaName
parameter_list|)
block|{
name|Slice
name|newSlice
init|=
name|changedSlices
operator|.
name|get
argument_list|(
name|origSlice
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Replica
name|replica
decl_stmt|;
if|if
condition|(
name|newSlice
operator|!=
literal|null
condition|)
block|{
name|replica
operator|=
name|newSlice
operator|.
name|getReplica
argument_list|(
name|replicaName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newSlice
operator|=
operator|new
name|Slice
argument_list|(
name|origSlice
operator|.
name|getName
argument_list|()
argument_list|,
name|origSlice
operator|.
name|getReplicasCopy
argument_list|()
argument_list|,
name|origSlice
operator|.
name|shallowCopy
argument_list|()
argument_list|)
expr_stmt|;
name|changedSlices
operator|.
name|put
argument_list|(
name|origSlice
operator|.
name|getName
argument_list|()
argument_list|,
name|newSlice
argument_list|)
expr_stmt|;
name|replica
operator|=
name|newSlice
operator|.
name|getReplica
argument_list|(
name|replicaName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|INVALID_STATE
argument_list|,
literal|"Should have been able to find replica '"
operator|+
name|replicaName
operator|+
literal|"' in slice '"
operator|+
name|origSlice
operator|.
name|getName
argument_list|()
operator|+
literal|"'. No action taken"
argument_list|)
throw|;
block|}
return|return
name|replica
return|;
block|}
comment|// Main entry point for carrying out the action. Returns "true" if we have actually moved properties around.
DECL|method|balanceProperty
name|boolean
name|balanceProperty
parameter_list|()
block|{
if|if
condition|(
name|collectCurrentPropStats
argument_list|()
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// we have two lists based on nodeName
comment|// 1> all the nodes that _could_ host a property for the slice
comment|// 2> all the nodes that _currently_ host a property for the slice.
comment|// So, remove a replica from the nodes that have too many
name|removeOverallocatedReplicas
argument_list|()
expr_stmt|;
comment|// prune replicas belonging to a slice that have the property currently assigned from the list of replicas
comment|// that could host the property.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|entProp
range|:
name|nodesHostingProp
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|SliceReplica
name|srHosting
range|:
name|entProp
operator|.
name|getValue
argument_list|()
control|)
block|{
name|removeSliceAlreadyHostedFromPossibles
argument_list|(
name|srHosting
operator|.
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Assemble the list of slices that do not have any replica hosting the property:
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|ent
range|:
name|nodesHostingReplicas
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ListIterator
argument_list|<
name|SliceReplica
argument_list|>
name|iter
init|=
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SliceReplica
name|sr
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|shardsNeedingHosts
operator|.
name|add
argument_list|(
name|sr
operator|.
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// At this point, nodesHostingProp should contain _only_ lists of replicas that belong to slices that do _not_
comment|// have any replica hosting the property. So let's assign them.
name|balanceUnassignedReplicas
argument_list|()
expr_stmt|;
for|for
control|(
name|Slice
name|newSlice
range|:
name|changedSlices
operator|.
name|values
argument_list|()
control|)
block|{
name|DocCollection
name|docCollection
init|=
name|CollectionMutator
operator|.
name|updateSlice
argument_list|(
name|collectionName
argument_list|,
name|clusterState
operator|.
name|getCollection
argument_list|(
name|collectionName
argument_list|)
argument_list|,
name|newSlice
argument_list|)
decl_stmt|;
name|clusterState
operator|=
name|ClusterStateMutator
operator|.
name|newState
argument_list|(
name|clusterState
argument_list|,
name|collectionName
argument_list|,
name|docCollection
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|class|SliceReplica
specifier|private
specifier|static
class|class
name|SliceReplica
block|{
DECL|field|slice
name|Slice
name|slice
decl_stmt|;
DECL|field|replica
name|Replica
name|replica
decl_stmt|;
DECL|method|SliceReplica
name|SliceReplica
parameter_list|(
name|Slice
name|slice
parameter_list|,
name|Replica
name|replica
parameter_list|)
block|{
name|this
operator|.
name|slice
operator|=
name|slice
expr_stmt|;
name|this
operator|.
name|replica
operator|=
name|replica
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

