begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.update.processor
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|RealTimeGetComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|CopyField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|NumericValueFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|AddUpdateCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RefCounted
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * @lucene.experimental  */
end_comment

begin_class
DECL|class|AtomicUpdateDocumentMerger
specifier|public
class|class
name|AtomicUpdateDocumentMerger
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|schema
specifier|protected
specifier|final
name|IndexSchema
name|schema
decl_stmt|;
DECL|field|idField
specifier|protected
specifier|final
name|SchemaField
name|idField
decl_stmt|;
DECL|method|AtomicUpdateDocumentMerger
specifier|public
name|AtomicUpdateDocumentMerger
parameter_list|(
name|SolrQueryRequest
name|queryReq
parameter_list|)
block|{
name|schema
operator|=
name|queryReq
operator|.
name|getSchema
argument_list|()
expr_stmt|;
name|idField
operator|=
name|schema
operator|.
name|getUniqueKeyField
argument_list|()
expr_stmt|;
block|}
comment|/**    * Utility method that examines the SolrInputDocument in an AddUpdateCommand    * and returns true if the documents contains atomic update instructions.    */
DECL|method|isAtomicUpdate
specifier|public
specifier|static
name|boolean
name|isAtomicUpdate
parameter_list|(
specifier|final
name|AddUpdateCommand
name|cmd
parameter_list|)
block|{
name|SolrInputDocument
name|sdoc
init|=
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
decl_stmt|;
for|for
control|(
name|SolrInputField
name|sif
range|:
name|sdoc
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|sif
operator|.
name|getValue
argument_list|()
operator|instanceof
name|Map
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Merges the fromDoc into the toDoc using the atomic update syntax.    *     * @param fromDoc SolrInputDocument which will merged into the toDoc    * @param toDoc the final SolrInputDocument that will be mutated with the values from the fromDoc atomic commands    * @return toDoc with mutated values    */
DECL|method|merge
specifier|public
name|SolrInputDocument
name|merge
parameter_list|(
specifier|final
name|SolrInputDocument
name|fromDoc
parameter_list|,
name|SolrInputDocument
name|toDoc
parameter_list|)
block|{
for|for
control|(
name|SolrInputField
name|sif
range|:
name|fromDoc
operator|.
name|values
argument_list|()
control|)
block|{
name|Object
name|val
init|=
name|sif
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|val
operator|instanceof
name|Map
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
operator|(
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|val
operator|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|fieldVal
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|boolean
name|updateField
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|"add"
case|:
name|updateField
operator|=
literal|true
expr_stmt|;
name|doAdd
argument_list|(
name|toDoc
argument_list|,
name|sif
argument_list|,
name|fieldVal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"set"
case|:
name|updateField
operator|=
literal|true
expr_stmt|;
name|doSet
argument_list|(
name|toDoc
argument_list|,
name|sif
argument_list|,
name|fieldVal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"remove"
case|:
name|updateField
operator|=
literal|true
expr_stmt|;
name|doRemove
argument_list|(
name|toDoc
argument_list|,
name|sif
argument_list|,
name|fieldVal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"removeregex"
case|:
name|updateField
operator|=
literal|true
expr_stmt|;
name|doRemoveRegex
argument_list|(
name|toDoc
argument_list|,
name|sif
argument_list|,
name|fieldVal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"inc"
case|:
name|updateField
operator|=
literal|true
expr_stmt|;
name|doInc
argument_list|(
name|toDoc
argument_list|,
name|sif
argument_list|,
name|fieldVal
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|//Perhaps throw an error here instead?
name|log
operator|.
name|warn
argument_list|(
literal|"Unknown operation for the an atomic update, operation ignored: "
operator|+
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// validate that the field being modified is not the id field.
if|if
condition|(
name|updateField
operator|&&
name|idField
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Invalid update of id field: "
operator|+
name|sif
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
comment|// normal fields are treated as a "set"
name|toDoc
operator|.
name|put
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|,
name|sif
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|toDoc
return|;
block|}
comment|/**    * Given a schema field, return whether or not such a field is supported for an in-place update.    * Note: If an update command has updates to only supported fields (and _version_ is also supported),    * only then is such an update command executed as an in-place update.    */
DECL|method|isSupportedFieldForInPlaceUpdate
specifier|private
specifier|static
name|boolean
name|isSupportedFieldForInPlaceUpdate
parameter_list|(
name|SchemaField
name|schemaField
parameter_list|)
block|{
return|return
operator|!
operator|(
name|schemaField
operator|.
name|indexed
argument_list|()
operator|||
name|schemaField
operator|.
name|stored
argument_list|()
operator|||
operator|!
name|schemaField
operator|.
name|hasDocValues
argument_list|()
operator|||
name|schemaField
operator|.
name|multiValued
argument_list|()
operator|||
operator|!
operator|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|NumericValueFieldType
operator|)
operator|)
return|;
block|}
comment|/**    * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single    * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set    * will be returned in that case).    *     * @return Return a set of fields that can be in-place updated.    */
DECL|method|computeInPlaceUpdatableFields
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|computeInPlaceUpdatableFields
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|SolrInputDocument
name|sdoc
init|=
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
decl_stmt|;
name|IndexSchema
name|schema
init|=
name|cmd
operator|.
name|getReq
argument_list|()
operator|.
name|getSchema
argument_list|()
decl_stmt|;
specifier|final
name|SchemaField
name|uniqueKeyField
init|=
name|schema
operator|.
name|getUniqueKeyField
argument_list|()
decl_stmt|;
specifier|final
name|String
name|uniqueKeyFieldName
init|=
literal|null
operator|==
name|uniqueKeyField
condition|?
literal|null
else|:
name|uniqueKeyField
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|candidateFields
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// if _version_ field is not supported for in-place update, bail out early
name|SchemaField
name|versionField
init|=
name|schema
operator|.
name|getFieldOrNull
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|VERSION_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|versionField
operator|==
literal|null
operator|||
operator|!
name|isSupportedFieldForInPlaceUpdate
argument_list|(
name|versionField
argument_list|)
condition|)
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
comment|// first pass, check the things that are virtually free,
comment|// and bail out early if anything is obviously not a valid in-place update
for|for
control|(
name|String
name|fieldName
range|:
name|sdoc
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
name|uniqueKeyFieldName
argument_list|)
operator|||
name|fieldName
operator|.
name|equals
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|VERSION_FIELD
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Object
name|fieldValue
init|=
name|sdoc
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fieldValue
operator|instanceof
name|Map
operator|)
condition|)
block|{
comment|// not an in-place update if there are fields that are not maps
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
comment|// else it's a atomic update map...
for|for
control|(
name|String
name|op
range|:
operator|(
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|fieldValue
operator|)
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|op
operator|.
name|equals
argument_list|(
literal|"set"
argument_list|)
operator|&&
operator|!
name|op
operator|.
name|equals
argument_list|(
literal|"inc"
argument_list|)
condition|)
block|{
comment|// not a supported in-place update op
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
block|}
name|candidateFields
operator|.
name|add
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|candidateFields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
comment|// second pass over the candidates for in-place updates
comment|// this time more expensive checks involving schema/config settings
for|for
control|(
name|String
name|fieldName
range|:
name|candidateFields
control|)
block|{
name|SchemaField
name|schemaField
init|=
name|schema
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isSupportedFieldForInPlaceUpdate
argument_list|(
name|schemaField
argument_list|)
condition|)
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
comment|// if this field has copy target which is not supported for in place, then empty
for|for
control|(
name|CopyField
name|copyField
range|:
name|schema
operator|.
name|getCopyFieldsList
argument_list|(
name|fieldName
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|isSupportedFieldForInPlaceUpdate
argument_list|(
name|copyField
operator|.
name|getDestination
argument_list|()
argument_list|)
condition|)
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
block|}
comment|// third pass: requiring checks against the actual IndexWriter due to internal DV update limitations
name|SolrCore
name|core
init|=
name|cmd
operator|.
name|getReq
argument_list|()
operator|.
name|getCore
argument_list|()
decl_stmt|;
name|RefCounted
argument_list|<
name|IndexWriter
argument_list|>
name|holder
init|=
name|core
operator|.
name|getSolrCoreState
argument_list|()
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|fieldNamesFromIndexWriter
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|segmentSortingFields
init|=
literal|null
decl_stmt|;
try|try
block|{
name|IndexWriter
name|iw
init|=
name|holder
operator|.
name|get
argument_list|()
decl_stmt|;
name|fieldNamesFromIndexWriter
operator|=
name|iw
operator|.
name|getFieldNames
argument_list|()
expr_stmt|;
comment|// This shouldn't be needed once LUCENE-7659 is resolved
name|segmentSortingFields
operator|=
name|iw
operator|.
name|getConfig
argument_list|()
operator|.
name|getIndexSortFields
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|holder
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|String
name|fieldName
range|:
name|candidateFields
control|)
block|{
if|if
condition|(
operator|!
name|fieldNamesFromIndexWriter
operator|.
name|contains
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
comment|// if this field doesn't exist, DV update can't work
block|}
if|if
condition|(
name|segmentSortingFields
operator|.
name|contains
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
comment|// if this is used for segment sorting, DV updates can't work
block|}
block|}
return|return
name|candidateFields
return|;
block|}
comment|/**    * Given an AddUpdateCommand containing update operations (e.g. set, inc), merge and resolve the operations into    * a partial document that can be used for indexing the in-place updates. The AddUpdateCommand is modified to contain    * the partial document (instead of the original document which contained the update operations) and also    * the prevVersion that this in-place update depends on.    * Note: updatedFields passed into the method can be changed, i.e. the version field can be added to the set.    * @return If in-place update cannot succeed, e.g. if the old document is deleted recently, then false is returned. A false    *        return indicates that this update can be re-tried as a full atomic update. Returns true if the in-place update    *        succeeds.    */
DECL|method|doInPlaceUpdateMerge
specifier|public
name|boolean
name|doInPlaceUpdateMerge
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|updatedFields
parameter_list|)
throws|throws
name|IOException
block|{
name|SolrInputDocument
name|inputDoc
init|=
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
decl_stmt|;
name|BytesRef
name|idBytes
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
name|updatedFields
operator|.
name|add
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|VERSION_FIELD
argument_list|)
expr_stmt|;
comment|// add the version field so that it is fetched too
name|SolrInputDocument
name|oldDocument
init|=
name|RealTimeGetComponent
operator|.
name|getInputDocument
argument_list|(
name|cmd
operator|.
name|getReq
argument_list|()
operator|.
name|getCore
argument_list|()
argument_list|,
name|idBytes
argument_list|,
literal|null
argument_list|,
comment|// don't want the version to be returned
literal|true
argument_list|,
comment|// avoid stored fields from index
name|updatedFields
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// resolve the full document
if|if
condition|(
name|oldDocument
operator|==
name|RealTimeGetComponent
operator|.
name|DELETED
operator|||
name|oldDocument
operator|==
literal|null
condition|)
block|{
comment|// This doc was deleted recently. In-place update cannot work, hence a full atomic update should be tried.
return|return
literal|false
return|;
block|}
if|if
condition|(
name|oldDocument
operator|.
name|containsKey
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|VERSION_FIELD
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|INVALID_STATE
argument_list|,
literal|"There is no _version_ in previous document. id="
operator|+
name|cmd
operator|.
name|getPrintableId
argument_list|()
argument_list|)
throw|;
block|}
name|Long
name|oldVersion
init|=
operator|(
name|Long
operator|)
name|oldDocument
operator|.
name|remove
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|VERSION_FIELD
argument_list|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// If the oldDocument contains any other field apart from updatedFields (or id/version field), then remove them.
comment|// This can happen, despite requesting for these fields in the call to RTGC.getInputDocument, if the document was
comment|// fetched from the tlog and had all these fields (possibly because it was a full document ADD operation).
if|if
condition|(
name|updatedFields
operator|!=
literal|null
condition|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|oldDocument
operator|.
name|getFieldNames
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|names
control|)
block|{
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|VERSION_FIELD
argument_list|)
operator|==
literal|false
operator|&&
name|fieldName
operator|.
name|equals
argument_list|(
literal|"id"
argument_list|)
operator|==
literal|false
operator|&&
name|updatedFields
operator|.
name|contains
argument_list|(
name|fieldName
argument_list|)
operator|==
literal|false
condition|)
block|{
name|oldDocument
operator|.
name|remove
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Copy over all supported DVs from oldDocument to partialDoc
comment|//
comment|// Assuming multiple updates to the same doc: field 'dv1' in one update, then field 'dv2' in a second
comment|// update, and then again 'dv1' in a third update (without commits in between), the last update would
comment|// fetch from the tlog the partial doc for the 2nd (dv2) update. If that doc doesn't copy over the
comment|// previous updates to dv1 as well, then a full resolution (by following previous pointers) would
comment|// need to be done to calculate the dv1 value -- so instead copy all the potentially affected DV fields.
name|SolrInputDocument
name|partialDoc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
name|String
name|uniqueKeyField
init|=
name|schema
operator|.
name|getUniqueKeyField
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|oldDocument
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
name|SchemaField
name|schemaField
init|=
name|schema
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
name|uniqueKeyField
argument_list|)
operator|||
name|isSupportedFieldForInPlaceUpdate
argument_list|(
name|schemaField
argument_list|)
condition|)
block|{
name|partialDoc
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|oldDocument
operator|.
name|getFieldValue
argument_list|(
name|fieldName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|merge
argument_list|(
name|inputDoc
argument_list|,
name|partialDoc
argument_list|)
expr_stmt|;
comment|// Populate the id field if not already populated (this can happen since stored fields were avoided during fetch from RTGC)
if|if
condition|(
operator|!
name|partialDoc
operator|.
name|containsKey
argument_list|(
name|schema
operator|.
name|getUniqueKeyField
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|partialDoc
operator|.
name|addField
argument_list|(
name|idField
operator|.
name|getName
argument_list|()
argument_list|,
name|inputDoc
operator|.
name|getField
argument_list|(
name|schema
operator|.
name|getUniqueKeyField
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|getFirstValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|.
name|prevVersion
operator|=
name|oldVersion
expr_stmt|;
name|cmd
operator|.
name|solrDoc
operator|=
name|partialDoc
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|doSet
specifier|protected
name|void
name|doSet
parameter_list|(
name|SolrInputDocument
name|toDoc
parameter_list|,
name|SolrInputField
name|sif
parameter_list|,
name|Object
name|fieldVal
parameter_list|)
block|{
name|SchemaField
name|sf
init|=
name|schema
operator|.
name|getField
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|toDoc
operator|.
name|setField
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|,
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toNativeType
argument_list|(
name|fieldVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|doAdd
specifier|protected
name|void
name|doAdd
parameter_list|(
name|SolrInputDocument
name|toDoc
parameter_list|,
name|SolrInputField
name|sif
parameter_list|,
name|Object
name|fieldVal
parameter_list|)
block|{
name|SchemaField
name|sf
init|=
name|schema
operator|.
name|getField
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|toDoc
operator|.
name|addField
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|,
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toNativeType
argument_list|(
name|fieldVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|doInc
specifier|protected
name|void
name|doInc
parameter_list|(
name|SolrInputDocument
name|toDoc
parameter_list|,
name|SolrInputField
name|sif
parameter_list|,
name|Object
name|fieldVal
parameter_list|)
block|{
name|SolrInputField
name|numericField
init|=
name|toDoc
operator|.
name|get
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|numericField
operator|==
literal|null
condition|)
block|{
name|toDoc
operator|.
name|setField
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|,
name|fieldVal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: fieldtype needs externalToObject?
name|String
name|oldValS
init|=
name|numericField
operator|.
name|getFirstValue
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|SchemaField
name|sf
init|=
name|schema
operator|.
name|getField
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|BytesRefBuilder
name|term
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|readableToIndexed
argument_list|(
name|oldValS
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|Object
name|oldVal
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|sf
argument_list|,
name|term
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|fieldValS
init|=
name|fieldVal
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Number
name|result
decl_stmt|;
if|if
condition|(
name|oldVal
operator|instanceof
name|Long
condition|)
block|{
name|result
operator|=
operator|(
operator|(
name|Long
operator|)
name|oldVal
operator|)
operator|.
name|longValue
argument_list|()
operator|+
name|Long
operator|.
name|parseLong
argument_list|(
name|fieldValS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldVal
operator|instanceof
name|Float
condition|)
block|{
name|result
operator|=
operator|(
operator|(
name|Float
operator|)
name|oldVal
operator|)
operator|.
name|floatValue
argument_list|()
operator|+
name|Float
operator|.
name|parseFloat
argument_list|(
name|fieldValS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldVal
operator|instanceof
name|Double
condition|)
block|{
name|result
operator|=
operator|(
operator|(
name|Double
operator|)
name|oldVal
operator|)
operator|.
name|doubleValue
argument_list|()
operator|+
name|Double
operator|.
name|parseDouble
argument_list|(
name|fieldValS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// int, short, byte
name|result
operator|=
operator|(
operator|(
name|Integer
operator|)
name|oldVal
operator|)
operator|.
name|intValue
argument_list|()
operator|+
name|Integer
operator|.
name|parseInt
argument_list|(
name|fieldValS
argument_list|)
expr_stmt|;
block|}
name|toDoc
operator|.
name|setField
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doRemove
specifier|protected
name|void
name|doRemove
parameter_list|(
name|SolrInputDocument
name|toDoc
parameter_list|,
name|SolrInputField
name|sif
parameter_list|,
name|Object
name|fieldVal
parameter_list|)
block|{
specifier|final
name|String
name|name
init|=
name|sif
operator|.
name|getName
argument_list|()
decl_stmt|;
name|SolrInputField
name|existingField
init|=
name|toDoc
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingField
operator|==
literal|null
condition|)
return|return;
name|SchemaField
name|sf
init|=
name|schema
operator|.
name|getField
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Collection
argument_list|<
name|Object
argument_list|>
name|original
init|=
name|existingField
operator|.
name|getValues
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldVal
operator|instanceof
name|Collection
condition|)
block|{
for|for
control|(
name|Object
name|object
range|:
operator|(
name|Collection
operator|)
name|fieldVal
control|)
block|{
name|Object
name|o
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toNativeType
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|original
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|original
operator|.
name|remove
argument_list|(
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toNativeType
argument_list|(
name|fieldVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|toDoc
operator|.
name|setField
argument_list|(
name|name
argument_list|,
name|original
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doRemoveRegex
specifier|protected
name|void
name|doRemoveRegex
parameter_list|(
name|SolrInputDocument
name|toDoc
parameter_list|,
name|SolrInputField
name|sif
parameter_list|,
name|Object
name|valuePatterns
parameter_list|)
block|{
specifier|final
name|String
name|name
init|=
name|sif
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|SolrInputField
name|existingField
init|=
name|toDoc
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingField
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Collection
argument_list|<
name|Object
argument_list|>
name|valueToRemove
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|Object
argument_list|>
name|original
init|=
name|existingField
operator|.
name|getValues
argument_list|()
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|Pattern
argument_list|>
name|patterns
init|=
name|preparePatterns
argument_list|(
name|valuePatterns
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|value
range|:
name|original
control|)
block|{
for|for
control|(
name|Pattern
name|pattern
range|:
name|patterns
control|)
block|{
specifier|final
name|Matcher
name|m
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|matches
argument_list|()
condition|)
block|{
name|valueToRemove
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|original
operator|.
name|removeAll
argument_list|(
name|valueToRemove
argument_list|)
expr_stmt|;
name|toDoc
operator|.
name|setField
argument_list|(
name|name
argument_list|,
name|original
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|preparePatterns
specifier|private
name|Collection
argument_list|<
name|Pattern
argument_list|>
name|preparePatterns
parameter_list|(
name|Object
name|fieldVal
parameter_list|)
block|{
specifier|final
name|Collection
argument_list|<
name|Pattern
argument_list|>
name|patterns
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldVal
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|patternVals
init|=
operator|(
name|Collection
argument_list|<
name|String
argument_list|>
operator|)
name|fieldVal
decl_stmt|;
for|for
control|(
name|String
name|patternVal
range|:
name|patternVals
control|)
block|{
name|patterns
operator|.
name|add
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|patternVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|patterns
operator|.
name|add
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|fieldVal
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|patterns
return|;
block|}
block|}
end_class

end_unit

