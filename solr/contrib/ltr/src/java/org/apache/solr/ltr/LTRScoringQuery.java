begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.ltr
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|ltr
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureTask
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RunnableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DisiPriorityQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DisiWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DisjunctionDISIApproximation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Explanation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Scorer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Weight
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|ltr
operator|.
name|feature
operator|.
name|Feature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|ltr
operator|.
name|model
operator|.
name|LTRScoringModel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * The ranking query that is run, reranking results using the  * LTRScoringModel algorithm  */
end_comment

begin_class
DECL|class|LTRScoringQuery
specifier|public
class|class
name|LTRScoringQuery
extends|extends
name|Query
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
comment|// contains a description of the model
DECL|field|ltrScoringModel
specifier|final
specifier|private
name|LTRScoringModel
name|ltrScoringModel
decl_stmt|;
DECL|field|extractAllFeatures
specifier|final
specifier|private
name|boolean
name|extractAllFeatures
decl_stmt|;
DECL|field|ltrThreadMgr
specifier|final
specifier|private
name|LTRThreadModule
name|ltrThreadMgr
decl_stmt|;
DECL|field|querySemaphore
specifier|final
specifier|private
name|Semaphore
name|querySemaphore
decl_stmt|;
comment|// limits the number of threads per query, so that multiple requests can be serviced simultaneously
comment|// feature logger to output the features.
DECL|field|fl
specifier|private
name|FeatureLogger
name|fl
decl_stmt|;
comment|// Map of external parameters, such as query intent, that can be used by
comment|// features
DECL|field|efi
specifier|final
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|efi
decl_stmt|;
comment|// Original solr query used to fetch matching documents
DECL|field|originalQuery
specifier|private
name|Query
name|originalQuery
decl_stmt|;
comment|// Original solr request
DECL|field|request
specifier|private
name|SolrQueryRequest
name|request
decl_stmt|;
DECL|method|LTRScoringQuery
specifier|public
name|LTRScoringQuery
parameter_list|(
name|LTRScoringModel
name|ltrScoringModel
parameter_list|)
block|{
name|this
argument_list|(
name|ltrScoringModel
argument_list|,
name|Collections
operator|.
expr|<
name|String
argument_list|,
name|String
index|[]
operator|>
name|emptyMap
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|LTRScoringQuery
specifier|public
name|LTRScoringQuery
parameter_list|(
name|LTRScoringModel
name|ltrScoringModel
parameter_list|,
name|boolean
name|extractAllFeatures
parameter_list|)
block|{
name|this
argument_list|(
name|ltrScoringModel
argument_list|,
name|Collections
operator|.
expr|<
name|String
argument_list|,
name|String
index|[]
operator|>
name|emptyMap
argument_list|()
argument_list|,
name|extractAllFeatures
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|LTRScoringQuery
specifier|public
name|LTRScoringQuery
parameter_list|(
name|LTRScoringModel
name|ltrScoringModel
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|externalFeatureInfo
parameter_list|,
name|boolean
name|extractAllFeatures
parameter_list|,
name|LTRThreadModule
name|ltrThreadMgr
parameter_list|)
block|{
name|this
operator|.
name|ltrScoringModel
operator|=
name|ltrScoringModel
expr_stmt|;
name|this
operator|.
name|efi
operator|=
name|externalFeatureInfo
expr_stmt|;
name|this
operator|.
name|extractAllFeatures
operator|=
name|extractAllFeatures
expr_stmt|;
name|this
operator|.
name|ltrThreadMgr
operator|=
name|ltrThreadMgr
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|ltrThreadMgr
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|querySemaphore
operator|=
name|this
operator|.
name|ltrThreadMgr
operator|.
name|createQuerySemaphore
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|querySemaphore
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|getScoringModel
specifier|public
name|LTRScoringModel
name|getScoringModel
parameter_list|()
block|{
return|return
name|ltrScoringModel
return|;
block|}
DECL|method|setFeatureLogger
specifier|public
name|void
name|setFeatureLogger
parameter_list|(
name|FeatureLogger
name|fl
parameter_list|)
block|{
name|this
operator|.
name|fl
operator|=
name|fl
expr_stmt|;
block|}
DECL|method|getFeatureLogger
specifier|public
name|FeatureLogger
name|getFeatureLogger
parameter_list|()
block|{
return|return
name|fl
return|;
block|}
DECL|method|setOriginalQuery
specifier|public
name|void
name|setOriginalQuery
parameter_list|(
name|Query
name|originalQuery
parameter_list|)
block|{
name|this
operator|.
name|originalQuery
operator|=
name|originalQuery
expr_stmt|;
block|}
DECL|method|getOriginalQuery
specifier|public
name|Query
name|getOriginalQuery
parameter_list|()
block|{
return|return
name|originalQuery
return|;
block|}
DECL|method|getExternalFeatureInfo
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|getExternalFeatureInfo
parameter_list|()
block|{
return|return
name|efi
return|;
block|}
DECL|method|setRequest
specifier|public
name|void
name|setRequest
parameter_list|(
name|SolrQueryRequest
name|request
parameter_list|)
block|{
name|this
operator|.
name|request
operator|=
name|request
expr_stmt|;
block|}
DECL|method|getRequest
specifier|public
name|SolrQueryRequest
name|getRequest
parameter_list|()
block|{
return|return
name|request
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
name|classHash
argument_list|()
decl_stmt|;
name|result
operator|=
operator|(
name|prime
operator|*
name|result
operator|)
operator|+
operator|(
operator|(
name|ltrScoringModel
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|ltrScoringModel
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|prime
operator|*
name|result
operator|)
operator|+
operator|(
operator|(
name|originalQuery
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|originalQuery
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|efi
operator|==
literal|null
condition|)
block|{
name|result
operator|=
operator|(
name|prime
operator|*
name|result
operator|)
operator|+
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|entry
range|:
name|efi
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|String
index|[]
name|values
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|result
operator|=
operator|(
name|prime
operator|*
name|result
operator|)
operator|+
name|key
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|result
operator|=
operator|(
name|prime
operator|*
name|result
operator|)
operator|+
name|Arrays
operator|.
name|hashCode
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
operator|(
name|prime
operator|*
name|result
operator|)
operator|+
name|this
operator|.
name|toString
argument_list|()
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|sameClassAs
argument_list|(
name|o
argument_list|)
operator|&&
name|equalsTo
argument_list|(
name|getClass
argument_list|()
operator|.
name|cast
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
DECL|method|equalsTo
specifier|private
name|boolean
name|equalsTo
parameter_list|(
name|LTRScoringQuery
name|other
parameter_list|)
block|{
if|if
condition|(
name|ltrScoringModel
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|ltrScoringModel
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ltrScoringModel
operator|.
name|equals
argument_list|(
name|other
operator|.
name|ltrScoringModel
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|originalQuery
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|originalQuery
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|originalQuery
operator|.
name|equals
argument_list|(
name|other
operator|.
name|originalQuery
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|efi
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|efi
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|other
operator|.
name|efi
operator|==
literal|null
operator|||
name|efi
operator|.
name|size
argument_list|()
operator|!=
name|other
operator|.
name|efi
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|entry
range|:
name|efi
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|String
index|[]
name|otherValues
init|=
name|other
operator|.
name|efi
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|otherValues
operator|==
literal|null
operator|||
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|otherValues
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|createWeight
specifier|public
name|ModelWeight
name|createWeight
parameter_list|(
name|IndexSearcher
name|searcher
parameter_list|,
name|boolean
name|needsScores
parameter_list|,
name|float
name|boost
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Collection
argument_list|<
name|Feature
argument_list|>
name|modelFeatures
init|=
name|ltrScoringModel
operator|.
name|getFeatures
argument_list|()
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|Feature
argument_list|>
name|allFeatures
init|=
name|ltrScoringModel
operator|.
name|getAllFeatures
argument_list|()
decl_stmt|;
name|int
name|modelFeatSize
init|=
name|modelFeatures
operator|.
name|size
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Feature
argument_list|>
name|features
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|extractAllFeatures
condition|)
block|{
name|features
operator|=
name|allFeatures
expr_stmt|;
block|}
else|else
block|{
name|features
operator|=
name|modelFeatures
expr_stmt|;
block|}
specifier|final
name|Feature
operator|.
name|FeatureWeight
index|[]
name|extractedFeatureWeights
init|=
operator|new
name|Feature
operator|.
name|FeatureWeight
index|[
name|features
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|final
name|Feature
operator|.
name|FeatureWeight
index|[]
name|modelFeaturesWeights
init|=
operator|new
name|Feature
operator|.
name|FeatureWeight
index|[
name|modelFeatSize
index|]
decl_stmt|;
name|List
argument_list|<
name|Feature
operator|.
name|FeatureWeight
argument_list|>
name|featureWeights
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|features
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|querySemaphore
operator|==
literal|null
condition|)
block|{
name|createWeights
argument_list|(
name|searcher
argument_list|,
name|needsScores
argument_list|,
name|featureWeights
argument_list|,
name|features
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|createWeightsParallel
argument_list|(
name|searcher
argument_list|,
name|needsScores
argument_list|,
name|featureWeights
argument_list|,
name|features
argument_list|)
expr_stmt|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|extractAllFeatures
condition|)
block|{
for|for
control|(
specifier|final
name|Feature
operator|.
name|FeatureWeight
name|fw
range|:
name|featureWeights
control|)
block|{
name|extractedFeatureWeights
index|[
name|i
operator|++
index|]
operator|=
name|fw
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|Feature
name|f
range|:
name|modelFeatures
control|)
block|{
name|modelFeaturesWeights
index|[
name|j
operator|++
index|]
operator|=
name|extractedFeatureWeights
index|[
name|f
operator|.
name|getIndex
argument_list|()
index|]
expr_stmt|;
comment|// we can lookup by featureid because all features will be extracted when this.extractAllFeatures is set
block|}
block|}
else|else
block|{
for|for
control|(
specifier|final
name|Feature
operator|.
name|FeatureWeight
name|fw
range|:
name|featureWeights
control|)
block|{
name|extractedFeatureWeights
index|[
name|i
operator|++
index|]
operator|=
name|fw
expr_stmt|;
name|modelFeaturesWeights
index|[
name|j
operator|++
index|]
operator|=
name|fw
expr_stmt|;
block|}
block|}
return|return
operator|new
name|ModelWeight
argument_list|(
name|modelFeaturesWeights
argument_list|,
name|extractedFeatureWeights
argument_list|,
name|allFeatures
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
DECL|method|createWeights
specifier|private
name|void
name|createWeights
parameter_list|(
name|IndexSearcher
name|searcher
parameter_list|,
name|boolean
name|needsScores
parameter_list|,
name|List
argument_list|<
name|Feature
operator|.
name|FeatureWeight
argument_list|>
name|featureWeights
parameter_list|,
name|Collection
argument_list|<
name|Feature
argument_list|>
name|features
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|SolrQueryRequest
name|req
init|=
name|getRequest
argument_list|()
decl_stmt|;
comment|// since the feature store is a linkedhashmap order is preserved
for|for
control|(
specifier|final
name|Feature
name|f
range|:
name|features
control|)
block|{
try|try
block|{
name|Feature
operator|.
name|FeatureWeight
name|fw
init|=
name|f
operator|.
name|createWeight
argument_list|(
name|searcher
argument_list|,
name|needsScores
argument_list|,
name|req
argument_list|,
name|originalQuery
argument_list|,
name|efi
argument_list|)
decl_stmt|;
name|featureWeights
operator|.
name|add
argument_list|(
name|fw
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Exception from createWeight for "
operator|+
name|f
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|class|CreateWeightCallable
specifier|private
class|class
name|CreateWeightCallable
implements|implements
name|Callable
argument_list|<
name|Feature
operator|.
name|FeatureWeight
argument_list|>
block|{
DECL|field|f
specifier|final
specifier|private
name|Feature
name|f
decl_stmt|;
DECL|field|searcher
specifier|final
specifier|private
name|IndexSearcher
name|searcher
decl_stmt|;
DECL|field|needsScores
specifier|final
specifier|private
name|boolean
name|needsScores
decl_stmt|;
DECL|field|req
specifier|final
specifier|private
name|SolrQueryRequest
name|req
decl_stmt|;
DECL|method|CreateWeightCallable
specifier|public
name|CreateWeightCallable
parameter_list|(
name|Feature
name|f
parameter_list|,
name|IndexSearcher
name|searcher
parameter_list|,
name|boolean
name|needsScores
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|)
block|{
name|this
operator|.
name|f
operator|=
name|f
expr_stmt|;
name|this
operator|.
name|searcher
operator|=
name|searcher
expr_stmt|;
name|this
operator|.
name|needsScores
operator|=
name|needsScores
expr_stmt|;
name|this
operator|.
name|req
operator|=
name|req
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call
specifier|public
name|Feature
operator|.
name|FeatureWeight
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|Feature
operator|.
name|FeatureWeight
name|fw
init|=
name|f
operator|.
name|createWeight
argument_list|(
name|searcher
argument_list|,
name|needsScores
argument_list|,
name|req
argument_list|,
name|originalQuery
argument_list|,
name|efi
argument_list|)
decl_stmt|;
return|return
name|fw
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Exception from createWeight for "
operator|+
name|f
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|querySemaphore
operator|.
name|release
argument_list|()
expr_stmt|;
name|ltrThreadMgr
operator|.
name|releaseLTRSemaphore
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// end of call CreateWeightCallable
DECL|method|createWeightsParallel
specifier|private
name|void
name|createWeightsParallel
parameter_list|(
name|IndexSearcher
name|searcher
parameter_list|,
name|boolean
name|needsScores
parameter_list|,
name|List
argument_list|<
name|Feature
operator|.
name|FeatureWeight
argument_list|>
name|featureWeights
parameter_list|,
name|Collection
argument_list|<
name|Feature
argument_list|>
name|features
parameter_list|)
throws|throws
name|RuntimeException
block|{
specifier|final
name|SolrQueryRequest
name|req
init|=
name|getRequest
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Future
argument_list|<
name|Feature
operator|.
name|FeatureWeight
argument_list|>
argument_list|>
name|futures
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|features
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
specifier|final
name|Feature
name|f
range|:
name|features
control|)
block|{
name|CreateWeightCallable
name|callable
init|=
operator|new
name|CreateWeightCallable
argument_list|(
name|f
argument_list|,
name|searcher
argument_list|,
name|needsScores
argument_list|,
name|req
argument_list|)
decl_stmt|;
name|RunnableFuture
argument_list|<
name|Feature
operator|.
name|FeatureWeight
argument_list|>
name|runnableFuture
init|=
operator|new
name|FutureTask
argument_list|<>
argument_list|(
name|callable
argument_list|)
decl_stmt|;
name|querySemaphore
operator|.
name|acquire
argument_list|()
expr_stmt|;
comment|// always acquire before the ltrSemaphore is acquired, to guarantee a that the current query is within the limit for max. threads
name|ltrThreadMgr
operator|.
name|acquireLTRSemaphore
argument_list|()
expr_stmt|;
comment|//may block and/or interrupt
name|ltrThreadMgr
operator|.
name|execute
argument_list|(
name|runnableFuture
argument_list|)
expr_stmt|;
comment|//releases semaphore when done
name|futures
operator|.
name|add
argument_list|(
name|runnableFuture
argument_list|)
expr_stmt|;
block|}
comment|//Loop over futures to get the feature weight objects
for|for
control|(
specifier|final
name|Future
argument_list|<
name|Feature
operator|.
name|FeatureWeight
argument_list|>
name|future
range|:
name|futures
control|)
block|{
name|featureWeights
operator|.
name|add
argument_list|(
name|future
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
comment|// future.get() will block if the job is still running
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// To catch InterruptedException and ExecutionException
name|log
operator|.
name|info
argument_list|(
literal|"Error while creating weights in LTR: InterruptedException"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error while creating weights in LTR: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
name|field
return|;
block|}
DECL|class|FeatureInfo
specifier|public
class|class
name|FeatureInfo
block|{
DECL|field|name
specifier|final
specifier|private
name|String
name|name
decl_stmt|;
DECL|field|value
specifier|private
name|float
name|value
decl_stmt|;
DECL|field|used
specifier|private
name|boolean
name|used
decl_stmt|;
DECL|method|FeatureInfo
name|FeatureInfo
parameter_list|(
name|String
name|n
parameter_list|,
name|float
name|v
parameter_list|,
name|boolean
name|u
parameter_list|)
block|{
name|name
operator|=
name|n
expr_stmt|;
name|value
operator|=
name|v
expr_stmt|;
name|used
operator|=
name|u
expr_stmt|;
block|}
DECL|method|setValue
specifier|public
name|void
name|setValue
parameter_list|(
name|float
name|value
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getValue
specifier|public
name|float
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
DECL|method|isUsed
specifier|public
name|boolean
name|isUsed
parameter_list|()
block|{
return|return
name|used
return|;
block|}
DECL|method|setUsed
specifier|public
name|void
name|setUsed
parameter_list|(
name|boolean
name|used
parameter_list|)
block|{
name|this
operator|.
name|used
operator|=
name|used
expr_stmt|;
block|}
block|}
DECL|class|ModelWeight
specifier|public
class|class
name|ModelWeight
extends|extends
name|Weight
block|{
comment|// List of the model's features used for scoring. This is a subset of the
comment|// features used for logging.
DECL|field|modelFeatureWeights
specifier|final
specifier|private
name|Feature
operator|.
name|FeatureWeight
index|[]
name|modelFeatureWeights
decl_stmt|;
DECL|field|modelFeatureValuesNormalized
specifier|final
specifier|private
name|float
index|[]
name|modelFeatureValuesNormalized
decl_stmt|;
DECL|field|extractedFeatureWeights
specifier|final
specifier|private
name|Feature
operator|.
name|FeatureWeight
index|[]
name|extractedFeatureWeights
decl_stmt|;
comment|// List of all the feature names, values - used for both scoring and logging
comment|/*      *  What is the advantage of using a hashmap here instead of an array of objects?      *     A set of arrays was used earlier and the elements were accessed using the featureId.      *     With the updated logic to create weights selectively,      *     the number of elements in the array can be fewer than the total number of features.      *     When [features] are not requested, only the model features are extracted.      *     In this case, the indexing by featureId, fails. For this reason,      *     we need a map which holds just the features that were triggered by the documents in the result set.      *      */
DECL|field|featuresInfo
specifier|final
specifier|private
name|FeatureInfo
index|[]
name|featuresInfo
decl_stmt|;
comment|/*      * @param modelFeatureWeights      *     - should be the same size as the number of features used by the model      * @param extractedFeatureWeights      *     - if features are requested from the same store as model feature store,      *       this will be the size of total number of features in the model feature store      *       else, this will be the size of the modelFeatureWeights      * @param allFeaturesSize      *     - total number of feature in the feature store used by this model      */
DECL|method|ModelWeight
specifier|public
name|ModelWeight
parameter_list|(
name|Feature
operator|.
name|FeatureWeight
index|[]
name|modelFeatureWeights
parameter_list|,
name|Feature
operator|.
name|FeatureWeight
index|[]
name|extractedFeatureWeights
parameter_list|,
name|int
name|allFeaturesSize
parameter_list|)
block|{
name|super
argument_list|(
name|LTRScoringQuery
operator|.
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|extractedFeatureWeights
operator|=
name|extractedFeatureWeights
expr_stmt|;
name|this
operator|.
name|modelFeatureWeights
operator|=
name|modelFeatureWeights
expr_stmt|;
name|this
operator|.
name|modelFeatureValuesNormalized
operator|=
operator|new
name|float
index|[
name|modelFeatureWeights
operator|.
name|length
index|]
expr_stmt|;
name|this
operator|.
name|featuresInfo
operator|=
operator|new
name|FeatureInfo
index|[
name|allFeaturesSize
index|]
expr_stmt|;
name|setFeaturesInfo
argument_list|()
expr_stmt|;
block|}
DECL|method|setFeaturesInfo
specifier|private
name|void
name|setFeaturesInfo
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|extractedFeatureWeights
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|String
name|featName
init|=
name|extractedFeatureWeights
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
decl_stmt|;
name|int
name|featId
init|=
name|extractedFeatureWeights
index|[
name|i
index|]
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|float
name|value
init|=
name|extractedFeatureWeights
index|[
name|i
index|]
operator|.
name|getDefaultValue
argument_list|()
decl_stmt|;
name|featuresInfo
index|[
name|featId
index|]
operator|=
operator|new
name|FeatureInfo
argument_list|(
name|featName
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getFeaturesInfo
specifier|public
name|FeatureInfo
index|[]
name|getFeaturesInfo
parameter_list|()
block|{
return|return
name|featuresInfo
return|;
block|}
comment|// for test use
DECL|method|getModelFeatureWeights
name|Feature
operator|.
name|FeatureWeight
index|[]
name|getModelFeatureWeights
parameter_list|()
block|{
return|return
name|modelFeatureWeights
return|;
block|}
comment|// for test use
DECL|method|getModelFeatureValuesNormalized
name|float
index|[]
name|getModelFeatureValuesNormalized
parameter_list|()
block|{
return|return
name|modelFeatureValuesNormalized
return|;
block|}
comment|// for test use
DECL|method|getExtractedFeatureWeights
name|Feature
operator|.
name|FeatureWeight
index|[]
name|getExtractedFeatureWeights
parameter_list|()
block|{
return|return
name|extractedFeatureWeights
return|;
block|}
comment|/**      * Goes through all the stored feature values, and calculates the normalized      * values for all the features that will be used for scoring.      * Then calculate and return the model's score.      */
DECL|method|makeNormalizedFeaturesAndScore
specifier|private
name|float
name|makeNormalizedFeaturesAndScore
parameter_list|()
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|Feature
operator|.
name|FeatureWeight
name|feature
range|:
name|modelFeatureWeights
control|)
block|{
specifier|final
name|int
name|featureId
init|=
name|feature
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|FeatureInfo
name|fInfo
init|=
name|featuresInfo
index|[
name|featureId
index|]
decl_stmt|;
if|if
condition|(
name|fInfo
operator|.
name|isUsed
argument_list|()
condition|)
block|{
comment|// not checking for finfo == null as that would be a bug we should catch
name|modelFeatureValuesNormalized
index|[
name|pos
index|]
operator|=
name|fInfo
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|modelFeatureValuesNormalized
index|[
name|pos
index|]
operator|=
name|feature
operator|.
name|getDefaultValue
argument_list|()
expr_stmt|;
block|}
name|pos
operator|++
expr_stmt|;
block|}
name|ltrScoringModel
operator|.
name|normalizeFeaturesInPlace
argument_list|(
name|modelFeatureValuesNormalized
argument_list|)
expr_stmt|;
return|return
name|ltrScoringModel
operator|.
name|score
argument_list|(
name|modelFeatureValuesNormalized
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|explain
specifier|public
name|Explanation
name|explain
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Explanation
index|[]
name|explanations
init|=
operator|new
name|Explanation
index|[
name|this
operator|.
name|featuresInfo
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
specifier|final
name|Feature
operator|.
name|FeatureWeight
name|feature
range|:
name|extractedFeatureWeights
control|)
block|{
name|explanations
index|[
name|feature
operator|.
name|getIndex
argument_list|()
index|]
operator|=
name|feature
operator|.
name|explain
argument_list|(
name|context
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|Explanation
argument_list|>
name|featureExplanations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|modelFeatureWeights
operator|.
name|length
condition|;
operator|++
name|idx
control|)
block|{
specifier|final
name|Feature
operator|.
name|FeatureWeight
name|f
init|=
name|modelFeatureWeights
index|[
name|idx
index|]
decl_stmt|;
name|Explanation
name|e
init|=
name|ltrScoringModel
operator|.
name|getNormalizerExplanation
argument_list|(
name|explanations
index|[
name|f
operator|.
name|getIndex
argument_list|()
index|]
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|featureExplanations
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ModelScorer
name|bs
init|=
name|scorer
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|bs
operator|.
name|iterator
argument_list|()
operator|.
name|advance
argument_list|(
name|doc
argument_list|)
expr_stmt|;
specifier|final
name|float
name|finalScore
init|=
name|bs
operator|.
name|score
argument_list|()
decl_stmt|;
return|return
name|ltrScoringModel
operator|.
name|explain
argument_list|(
name|context
argument_list|,
name|doc
argument_list|,
name|finalScore
argument_list|,
name|featureExplanations
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|extractTerms
specifier|public
name|void
name|extractTerms
parameter_list|(
name|Set
argument_list|<
name|Term
argument_list|>
name|terms
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Feature
operator|.
name|FeatureWeight
name|feature
range|:
name|extractedFeatureWeights
control|)
block|{
name|feature
operator|.
name|extractTerms
argument_list|(
name|terms
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|reset
specifier|protected
name|void
name|reset
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|extractedFeatureWeights
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|int
name|featId
init|=
name|extractedFeatureWeights
index|[
name|i
index|]
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|float
name|value
init|=
name|extractedFeatureWeights
index|[
name|i
index|]
operator|.
name|getDefaultValue
argument_list|()
decl_stmt|;
name|featuresInfo
index|[
name|featId
index|]
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|// need to set default value everytime as the default value is used in 'dense' mode even if used=false
name|featuresInfo
index|[
name|featId
index|]
operator|.
name|setUsed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|scorer
specifier|public
name|ModelScorer
name|scorer
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|Feature
operator|.
name|FeatureWeight
operator|.
name|FeatureScorer
argument_list|>
name|featureScorers
init|=
operator|new
name|ArrayList
argument_list|<
name|Feature
operator|.
name|FeatureWeight
operator|.
name|FeatureScorer
argument_list|>
argument_list|(
name|extractedFeatureWeights
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Feature
operator|.
name|FeatureWeight
name|featureWeight
range|:
name|extractedFeatureWeights
control|)
block|{
specifier|final
name|Feature
operator|.
name|FeatureWeight
operator|.
name|FeatureScorer
name|scorer
init|=
name|featureWeight
operator|.
name|scorer
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|scorer
operator|!=
literal|null
condition|)
block|{
name|featureScorers
operator|.
name|add
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Always return a ModelScorer, even if no features match, because we
comment|// always need to call
comment|// score on the model for every document, since 0 features matching could
comment|// return a
comment|// non 0 score for a given model.
name|ModelScorer
name|mscorer
init|=
operator|new
name|ModelScorer
argument_list|(
name|this
argument_list|,
name|featureScorers
argument_list|)
decl_stmt|;
return|return
name|mscorer
return|;
block|}
DECL|class|ModelScorer
specifier|public
class|class
name|ModelScorer
extends|extends
name|Scorer
block|{
DECL|field|docInfo
specifier|final
specifier|private
name|DocInfo
name|docInfo
decl_stmt|;
DECL|field|featureTraversalScorer
specifier|final
specifier|private
name|Scorer
name|featureTraversalScorer
decl_stmt|;
DECL|method|getDocInfo
specifier|public
name|DocInfo
name|getDocInfo
parameter_list|()
block|{
return|return
name|docInfo
return|;
block|}
DECL|method|ModelScorer
specifier|public
name|ModelScorer
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|List
argument_list|<
name|Feature
operator|.
name|FeatureWeight
operator|.
name|FeatureScorer
argument_list|>
name|featureScorers
parameter_list|)
block|{
name|super
argument_list|(
name|weight
argument_list|)
expr_stmt|;
name|docInfo
operator|=
operator|new
name|DocInfo
argument_list|()
expr_stmt|;
for|for
control|(
specifier|final
name|Feature
operator|.
name|FeatureWeight
operator|.
name|FeatureScorer
name|subSocer
range|:
name|featureScorers
control|)
block|{
name|subSocer
operator|.
name|setDocInfo
argument_list|(
name|docInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|featureScorers
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
comment|// future enhancement: allow the use of dense features in other cases
name|featureTraversalScorer
operator|=
operator|new
name|DenseModelScorer
argument_list|(
name|weight
argument_list|,
name|featureScorers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|featureTraversalScorer
operator|=
operator|new
name|SparseModelScorer
argument_list|(
name|weight
argument_list|,
name|featureScorers
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getChildren
specifier|public
name|Collection
argument_list|<
name|ChildScorer
argument_list|>
name|getChildren
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|featureTraversalScorer
operator|.
name|getChildren
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|featureTraversalScorer
operator|.
name|docID
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|score
specifier|public
name|float
name|score
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|featureTraversalScorer
operator|.
name|score
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|featureTraversalScorer
operator|.
name|freq
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|DocIdSetIterator
name|iterator
parameter_list|()
block|{
return|return
name|featureTraversalScorer
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|class|SparseModelScorer
specifier|private
class|class
name|SparseModelScorer
extends|extends
name|Scorer
block|{
DECL|field|subScorers
specifier|final
specifier|private
name|DisiPriorityQueue
name|subScorers
decl_stmt|;
DECL|field|itr
specifier|final
specifier|private
name|ScoringQuerySparseIterator
name|itr
decl_stmt|;
DECL|field|targetDoc
specifier|private
name|int
name|targetDoc
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|activeDoc
specifier|private
name|int
name|activeDoc
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|SparseModelScorer
specifier|private
name|SparseModelScorer
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|List
argument_list|<
name|Feature
operator|.
name|FeatureWeight
operator|.
name|FeatureScorer
argument_list|>
name|featureScorers
parameter_list|)
block|{
name|super
argument_list|(
name|weight
argument_list|)
expr_stmt|;
if|if
condition|(
name|featureScorers
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"There must be at least 2 subScorers"
argument_list|)
throw|;
block|}
name|subScorers
operator|=
operator|new
name|DisiPriorityQueue
argument_list|(
name|featureScorers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|Scorer
name|scorer
range|:
name|featureScorers
control|)
block|{
specifier|final
name|DisiWrapper
name|w
init|=
operator|new
name|DisiWrapper
argument_list|(
name|scorer
argument_list|)
decl_stmt|;
name|subScorers
operator|.
name|add
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|itr
operator|=
operator|new
name|ScoringQuerySparseIterator
argument_list|(
name|subScorers
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|itr
operator|.
name|docID
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|score
specifier|public
name|float
name|score
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|DisiWrapper
name|topList
init|=
name|subScorers
operator|.
name|topList
argument_list|()
decl_stmt|;
comment|// If target doc we wanted to advance to matches the actual doc
comment|// the underlying features advanced to, perform the feature
comment|// calculations,
comment|// otherwise just continue with the model's scoring process with empty
comment|// features.
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|activeDoc
operator|==
name|targetDoc
condition|)
block|{
for|for
control|(
name|DisiWrapper
name|w
init|=
name|topList
init|;
name|w
operator|!=
literal|null
condition|;
name|w
operator|=
name|w
operator|.
name|next
control|)
block|{
specifier|final
name|Scorer
name|subScorer
init|=
name|w
operator|.
name|scorer
decl_stmt|;
name|Feature
operator|.
name|FeatureWeight
name|scFW
init|=
operator|(
name|Feature
operator|.
name|FeatureWeight
operator|)
name|subScorer
operator|.
name|getWeight
argument_list|()
decl_stmt|;
specifier|final
name|int
name|featureId
init|=
name|scFW
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|featuresInfo
index|[
name|featureId
index|]
operator|.
name|setValue
argument_list|(
name|subScorer
operator|.
name|score
argument_list|()
argument_list|)
expr_stmt|;
name|featuresInfo
index|[
name|featureId
index|]
operator|.
name|setUsed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|makeNormalizedFeaturesAndScore
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|DisiWrapper
name|subMatches
init|=
name|subScorers
operator|.
name|topList
argument_list|()
decl_stmt|;
name|int
name|freq
init|=
literal|1
decl_stmt|;
for|for
control|(
name|DisiWrapper
name|w
init|=
name|subMatches
operator|.
name|next
init|;
name|w
operator|!=
literal|null
condition|;
name|w
operator|=
name|w
operator|.
name|next
control|)
block|{
name|freq
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|DocIdSetIterator
name|iterator
parameter_list|()
block|{
return|return
name|itr
return|;
block|}
annotation|@
name|Override
DECL|method|getChildren
specifier|public
specifier|final
name|Collection
argument_list|<
name|ChildScorer
argument_list|>
name|getChildren
parameter_list|()
block|{
specifier|final
name|ArrayList
argument_list|<
name|ChildScorer
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|DisiWrapper
name|scorer
range|:
name|subScorers
control|)
block|{
name|children
operator|.
name|add
argument_list|(
operator|new
name|ChildScorer
argument_list|(
name|scorer
operator|.
name|scorer
argument_list|,
literal|"SHOULD"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|children
return|;
block|}
DECL|class|ScoringQuerySparseIterator
specifier|private
class|class
name|ScoringQuerySparseIterator
extends|extends
name|DisjunctionDISIApproximation
block|{
DECL|method|ScoringQuerySparseIterator
specifier|public
name|ScoringQuerySparseIterator
parameter_list|(
name|DisiPriorityQueue
name|subIterators
parameter_list|)
block|{
name|super
argument_list|(
name|subIterators
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
specifier|final
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|activeDoc
operator|==
name|targetDoc
condition|)
block|{
name|activeDoc
operator|=
name|super
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|activeDoc
operator|<
name|targetDoc
condition|)
block|{
name|activeDoc
operator|=
name|super
operator|.
name|advance
argument_list|(
name|targetDoc
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|++
name|targetDoc
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
specifier|final
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If target doc we wanted to advance to matches the actual doc
comment|// the underlying features advanced to, perform the feature
comment|// calculations,
comment|// otherwise just continue with the model's scoring process with
comment|// empty features.
if|if
condition|(
name|activeDoc
operator|<
name|target
condition|)
block|{
name|activeDoc
operator|=
name|super
operator|.
name|advance
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
name|targetDoc
operator|=
name|target
expr_stmt|;
return|return
name|targetDoc
return|;
block|}
block|}
block|}
DECL|class|DenseModelScorer
specifier|private
class|class
name|DenseModelScorer
extends|extends
name|Scorer
block|{
DECL|field|activeDoc
specifier|private
name|int
name|activeDoc
init|=
operator|-
literal|1
decl_stmt|;
comment|// The doc that our scorer's are actually at
DECL|field|targetDoc
specifier|private
name|int
name|targetDoc
init|=
operator|-
literal|1
decl_stmt|;
comment|// The doc we were most recently told to go to
DECL|field|freq
specifier|private
name|int
name|freq
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|featureScorers
specifier|final
specifier|private
name|List
argument_list|<
name|Feature
operator|.
name|FeatureWeight
operator|.
name|FeatureScorer
argument_list|>
name|featureScorers
decl_stmt|;
DECL|method|DenseModelScorer
specifier|private
name|DenseModelScorer
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|List
argument_list|<
name|Feature
operator|.
name|FeatureWeight
operator|.
name|FeatureScorer
argument_list|>
name|featureScorers
parameter_list|)
block|{
name|super
argument_list|(
name|weight
argument_list|)
expr_stmt|;
name|this
operator|.
name|featureScorers
operator|=
name|featureScorers
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|targetDoc
return|;
block|}
annotation|@
name|Override
DECL|method|score
specifier|public
name|float
name|score
parameter_list|()
throws|throws
name|IOException
block|{
name|reset
argument_list|()
expr_stmt|;
name|freq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|targetDoc
operator|==
name|activeDoc
condition|)
block|{
for|for
control|(
specifier|final
name|Scorer
name|scorer
range|:
name|featureScorers
control|)
block|{
if|if
condition|(
name|scorer
operator|.
name|docID
argument_list|()
operator|==
name|activeDoc
condition|)
block|{
name|freq
operator|++
expr_stmt|;
name|Feature
operator|.
name|FeatureWeight
name|scFW
init|=
operator|(
name|Feature
operator|.
name|FeatureWeight
operator|)
name|scorer
operator|.
name|getWeight
argument_list|()
decl_stmt|;
specifier|final
name|int
name|featureId
init|=
name|scFW
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|featuresInfo
index|[
name|featureId
index|]
operator|.
name|setValue
argument_list|(
name|scorer
operator|.
name|score
argument_list|()
argument_list|)
expr_stmt|;
name|featuresInfo
index|[
name|featureId
index|]
operator|.
name|setUsed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|makeNormalizedFeaturesAndScore
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getChildren
specifier|public
specifier|final
name|Collection
argument_list|<
name|ChildScorer
argument_list|>
name|getChildren
parameter_list|()
block|{
specifier|final
name|ArrayList
argument_list|<
name|ChildScorer
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Scorer
name|scorer
range|:
name|featureScorers
control|)
block|{
name|children
operator|.
name|add
argument_list|(
operator|new
name|ChildScorer
argument_list|(
name|scorer
argument_list|,
literal|"SHOULD"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|children
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|DocIdSetIterator
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|DenseIterator
argument_list|()
return|;
block|}
DECL|class|DenseIterator
specifier|private
class|class
name|DenseIterator
extends|extends
name|DocIdSetIterator
block|{
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|targetDoc
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|activeDoc
operator|<=
name|targetDoc
condition|)
block|{
name|activeDoc
operator|=
name|NO_MORE_DOCS
expr_stmt|;
for|for
control|(
specifier|final
name|Scorer
name|scorer
range|:
name|featureScorers
control|)
block|{
if|if
condition|(
name|scorer
operator|.
name|docID
argument_list|()
operator|!=
name|NO_MORE_DOCS
condition|)
block|{
name|activeDoc
operator|=
name|Math
operator|.
name|min
argument_list|(
name|activeDoc
argument_list|,
name|scorer
operator|.
name|iterator
argument_list|()
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|++
name|targetDoc
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|activeDoc
operator|<
name|target
condition|)
block|{
name|activeDoc
operator|=
name|NO_MORE_DOCS
expr_stmt|;
for|for
control|(
specifier|final
name|Scorer
name|scorer
range|:
name|featureScorers
control|)
block|{
if|if
condition|(
name|scorer
operator|.
name|docID
argument_list|()
operator|!=
name|NO_MORE_DOCS
condition|)
block|{
name|activeDoc
operator|=
name|Math
operator|.
name|min
argument_list|(
name|activeDoc
argument_list|,
name|scorer
operator|.
name|iterator
argument_list|()
operator|.
name|advance
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|targetDoc
operator|=
name|target
expr_stmt|;
return|return
name|target
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
name|long
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|featureScorers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|+=
name|featureScorers
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|cost
argument_list|()
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

