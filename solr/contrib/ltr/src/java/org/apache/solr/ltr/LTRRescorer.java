begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.ltr
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|ltr
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ReaderUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Explanation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Rescorer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ScoreDoc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TopDocs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Weight
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import

begin_comment
comment|/**  * Implements the rescoring logic. The top documents returned by solr with their  * original scores, will be processed by a {@link LTRScoringQuery} that will assign a  * new score to each document. The top documents will be resorted based on the  * new score.  * */
end_comment

begin_class
DECL|class|LTRRescorer
specifier|public
class|class
name|LTRRescorer
extends|extends
name|Rescorer
block|{
DECL|field|scoringQuery
name|LTRScoringQuery
name|scoringQuery
decl_stmt|;
DECL|method|LTRRescorer
specifier|public
name|LTRRescorer
parameter_list|(
name|LTRScoringQuery
name|scoringQuery
parameter_list|)
block|{
name|this
operator|.
name|scoringQuery
operator|=
name|scoringQuery
expr_stmt|;
block|}
DECL|method|heapAdjust
specifier|private
name|void
name|heapAdjust
parameter_list|(
name|ScoreDoc
index|[]
name|hits
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|root
parameter_list|)
block|{
specifier|final
name|ScoreDoc
name|doc
init|=
name|hits
index|[
name|root
index|]
decl_stmt|;
specifier|final
name|float
name|score
init|=
name|doc
operator|.
name|score
decl_stmt|;
name|int
name|i
init|=
name|root
decl_stmt|;
while|while
condition|(
name|i
operator|<=
operator|(
operator|(
name|size
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
specifier|final
name|int
name|lchild
init|=
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
decl_stmt|;
specifier|final
name|ScoreDoc
name|ldoc
init|=
name|hits
index|[
name|lchild
index|]
decl_stmt|;
specifier|final
name|float
name|lscore
init|=
name|ldoc
operator|.
name|score
decl_stmt|;
name|float
name|rscore
init|=
name|Float
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|final
name|int
name|rchild
init|=
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|2
decl_stmt|;
name|ScoreDoc
name|rdoc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rchild
operator|<
name|size
condition|)
block|{
name|rdoc
operator|=
name|hits
index|[
name|rchild
index|]
expr_stmt|;
name|rscore
operator|=
name|rdoc
operator|.
name|score
expr_stmt|;
block|}
if|if
condition|(
name|lscore
operator|<
name|score
condition|)
block|{
if|if
condition|(
name|rscore
operator|<
name|lscore
condition|)
block|{
name|hits
index|[
name|i
index|]
operator|=
name|rdoc
expr_stmt|;
name|hits
index|[
name|rchild
index|]
operator|=
name|doc
expr_stmt|;
name|i
operator|=
name|rchild
expr_stmt|;
block|}
else|else
block|{
name|hits
index|[
name|i
index|]
operator|=
name|ldoc
expr_stmt|;
name|hits
index|[
name|lchild
index|]
operator|=
name|doc
expr_stmt|;
name|i
operator|=
name|lchild
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rscore
operator|<
name|score
condition|)
block|{
name|hits
index|[
name|i
index|]
operator|=
name|rdoc
expr_stmt|;
name|hits
index|[
name|rchild
index|]
operator|=
name|doc
expr_stmt|;
name|i
operator|=
name|rchild
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
block|}
block|}
DECL|method|heapify
specifier|private
name|void
name|heapify
parameter_list|(
name|ScoreDoc
index|[]
name|hits
parameter_list|,
name|int
name|size
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
operator|(
name|size
operator|>>
literal|1
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|heapAdjust
argument_list|(
name|hits
argument_list|,
name|size
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * rescores the documents:    *    * @param searcher    *          current IndexSearcher    * @param firstPassTopDocs    *          documents to rerank;    * @param topN    *          documents to return;    */
annotation|@
name|Override
DECL|method|rescore
specifier|public
name|TopDocs
name|rescore
parameter_list|(
name|IndexSearcher
name|searcher
parameter_list|,
name|TopDocs
name|firstPassTopDocs
parameter_list|,
name|int
name|topN
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|topN
operator|==
literal|0
operator|)
operator|||
operator|(
name|firstPassTopDocs
operator|.
name|totalHits
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|firstPassTopDocs
return|;
block|}
specifier|final
name|ScoreDoc
index|[]
name|hits
init|=
name|firstPassTopDocs
operator|.
name|scoreDocs
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|hits
argument_list|,
operator|new
name|Comparator
argument_list|<
name|ScoreDoc
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|ScoreDoc
name|a
parameter_list|,
name|ScoreDoc
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|doc
operator|-
name|b
operator|.
name|doc
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|topN
operator|=
name|Math
operator|.
name|min
argument_list|(
name|topN
argument_list|,
name|firstPassTopDocs
operator|.
name|totalHits
argument_list|)
expr_stmt|;
specifier|final
name|ScoreDoc
index|[]
name|reranked
init|=
operator|new
name|ScoreDoc
index|[
name|topN
index|]
decl_stmt|;
specifier|final
name|List
argument_list|<
name|LeafReaderContext
argument_list|>
name|leaves
init|=
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|leaves
argument_list|()
decl_stmt|;
specifier|final
name|LTRScoringQuery
operator|.
name|ModelWeight
name|modelWeight
init|=
operator|(
name|LTRScoringQuery
operator|.
name|ModelWeight
operator|)
name|searcher
operator|.
name|createNormalizedWeight
argument_list|(
name|scoringQuery
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|SolrIndexSearcher
name|solrIndexSearch
init|=
operator|(
name|SolrIndexSearcher
operator|)
name|searcher
decl_stmt|;
name|scoreFeatures
argument_list|(
name|solrIndexSearch
argument_list|,
name|firstPassTopDocs
argument_list|,
name|topN
argument_list|,
name|modelWeight
argument_list|,
name|hits
argument_list|,
name|leaves
argument_list|,
name|reranked
argument_list|)
expr_stmt|;
comment|// Must sort all documents that we reranked, and then select the top
name|Arrays
operator|.
name|sort
argument_list|(
name|reranked
argument_list|,
operator|new
name|Comparator
argument_list|<
name|ScoreDoc
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|ScoreDoc
name|a
parameter_list|,
name|ScoreDoc
name|b
parameter_list|)
block|{
comment|// Sort by score descending, then docID ascending:
if|if
condition|(
name|a
operator|.
name|score
operator|>
name|b
operator|.
name|score
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|score
operator|<
name|b
operator|.
name|score
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
comment|// This subtraction can't overflow int
comment|// because docIDs are>= 0:
return|return
name|a
operator|.
name|doc
operator|-
name|b
operator|.
name|doc
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
return|return
operator|new
name|TopDocs
argument_list|(
name|firstPassTopDocs
operator|.
name|totalHits
argument_list|,
name|reranked
argument_list|,
name|reranked
index|[
literal|0
index|]
operator|.
name|score
argument_list|)
return|;
block|}
DECL|method|scoreFeatures
specifier|public
name|void
name|scoreFeatures
parameter_list|(
name|SolrIndexSearcher
name|solrIndexSearch
parameter_list|,
name|TopDocs
name|firstPassTopDocs
parameter_list|,
name|int
name|topN
parameter_list|,
name|LTRScoringQuery
operator|.
name|ModelWeight
name|modelWeight
parameter_list|,
name|ScoreDoc
index|[]
name|hits
parameter_list|,
name|List
argument_list|<
name|LeafReaderContext
argument_list|>
name|leaves
parameter_list|,
name|ScoreDoc
index|[]
name|reranked
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|readerUpto
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|endDoc
init|=
literal|0
decl_stmt|;
name|int
name|docBase
init|=
literal|0
decl_stmt|;
name|LTRScoringQuery
operator|.
name|ModelWeight
operator|.
name|ModelScorer
name|scorer
init|=
literal|null
decl_stmt|;
name|int
name|hitUpto
init|=
literal|0
decl_stmt|;
specifier|final
name|FeatureLogger
name|featureLogger
init|=
name|scoringQuery
operator|.
name|getFeatureLogger
argument_list|()
decl_stmt|;
while|while
condition|(
name|hitUpto
operator|<
name|hits
operator|.
name|length
condition|)
block|{
specifier|final
name|ScoreDoc
name|hit
init|=
name|hits
index|[
name|hitUpto
index|]
decl_stmt|;
specifier|final
name|int
name|docID
init|=
name|hit
operator|.
name|doc
decl_stmt|;
name|LeafReaderContext
name|readerContext
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|docID
operator|>=
name|endDoc
condition|)
block|{
name|readerUpto
operator|++
expr_stmt|;
name|readerContext
operator|=
name|leaves
operator|.
name|get
argument_list|(
name|readerUpto
argument_list|)
expr_stmt|;
name|endDoc
operator|=
name|readerContext
operator|.
name|docBase
operator|+
name|readerContext
operator|.
name|reader
argument_list|()
operator|.
name|maxDoc
argument_list|()
expr_stmt|;
block|}
comment|// We advanced to another segment
if|if
condition|(
name|readerContext
operator|!=
literal|null
condition|)
block|{
name|docBase
operator|=
name|readerContext
operator|.
name|docBase
expr_stmt|;
name|scorer
operator|=
name|modelWeight
operator|.
name|scorer
argument_list|(
name|readerContext
argument_list|)
expr_stmt|;
block|}
comment|// Scorer for a LTRScoringQuery.ModelWeight should never be null since we always have to
comment|// call score
comment|// even if no feature scorers match, since a model might use that info to
comment|// return a
comment|// non-zero score. Same applies for the case of advancing a LTRScoringQuery.ModelWeight.ModelScorer
comment|// past the target
comment|// doc since the model algorithm still needs to compute a potentially
comment|// non-zero score from blank features.
assert|assert
operator|(
name|scorer
operator|!=
literal|null
operator|)
assert|;
specifier|final
name|int
name|targetDoc
init|=
name|docID
operator|-
name|docBase
decl_stmt|;
name|scorer
operator|.
name|docID
argument_list|()
expr_stmt|;
name|scorer
operator|.
name|iterator
argument_list|()
operator|.
name|advance
argument_list|(
name|targetDoc
argument_list|)
expr_stmt|;
name|scorer
operator|.
name|getDocInfo
argument_list|()
operator|.
name|setOriginalDocScore
argument_list|(
operator|new
name|Float
argument_list|(
name|hit
operator|.
name|score
argument_list|)
argument_list|)
expr_stmt|;
name|hit
operator|.
name|score
operator|=
name|scorer
operator|.
name|score
argument_list|()
expr_stmt|;
if|if
condition|(
name|hitUpto
operator|<
name|topN
condition|)
block|{
name|reranked
index|[
name|hitUpto
index|]
operator|=
name|hit
expr_stmt|;
comment|// if the heap is not full, maybe I want to log the features for this
comment|// document
if|if
condition|(
name|featureLogger
operator|!=
literal|null
condition|)
block|{
name|featureLogger
operator|.
name|log
argument_list|(
name|hit
operator|.
name|doc
argument_list|,
name|scoringQuery
argument_list|,
name|solrIndexSearch
argument_list|,
name|modelWeight
operator|.
name|getFeaturesInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hitUpto
operator|==
name|topN
condition|)
block|{
comment|// collected topN document, I create the heap
name|heapify
argument_list|(
name|reranked
argument_list|,
name|topN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hitUpto
operator|>=
name|topN
condition|)
block|{
comment|// once that heap is ready, if the score of this document is lower that
comment|// the minimum
comment|// i don't want to log the feature. Otherwise I replace it with the
comment|// minimum and fix the
comment|// heap.
if|if
condition|(
name|hit
operator|.
name|score
operator|>
name|reranked
index|[
literal|0
index|]
operator|.
name|score
condition|)
block|{
name|reranked
index|[
literal|0
index|]
operator|=
name|hit
expr_stmt|;
name|heapAdjust
argument_list|(
name|reranked
argument_list|,
name|topN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|featureLogger
operator|!=
literal|null
condition|)
block|{
name|featureLogger
operator|.
name|log
argument_list|(
name|hit
operator|.
name|doc
argument_list|,
name|scoringQuery
argument_list|,
name|solrIndexSearch
argument_list|,
name|modelWeight
operator|.
name|getFeaturesInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|hitUpto
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|explain
specifier|public
name|Explanation
name|explain
parameter_list|(
name|IndexSearcher
name|searcher
parameter_list|,
name|Explanation
name|firstPassExplanation
parameter_list|,
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|LeafReaderContext
argument_list|>
name|leafContexts
init|=
name|searcher
operator|.
name|getTopReaderContext
argument_list|()
operator|.
name|leaves
argument_list|()
decl_stmt|;
specifier|final
name|int
name|n
init|=
name|ReaderUtil
operator|.
name|subIndex
argument_list|(
name|docID
argument_list|,
name|leafContexts
argument_list|)
decl_stmt|;
specifier|final
name|LeafReaderContext
name|context
init|=
name|leafContexts
operator|.
name|get
argument_list|(
name|n
argument_list|)
decl_stmt|;
specifier|final
name|int
name|deBasedDoc
init|=
name|docID
operator|-
name|context
operator|.
name|docBase
decl_stmt|;
specifier|final
name|Weight
name|modelWeight
init|=
name|searcher
operator|.
name|createNormalizedWeight
argument_list|(
name|scoringQuery
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|modelWeight
operator|.
name|explain
argument_list|(
name|context
argument_list|,
name|deBasedDoc
argument_list|)
return|;
block|}
DECL|method|extractFeaturesInfo
specifier|public
specifier|static
name|LTRScoringQuery
operator|.
name|FeatureInfo
index|[]
name|extractFeaturesInfo
parameter_list|(
name|LTRScoringQuery
operator|.
name|ModelWeight
name|modelWeight
parameter_list|,
name|int
name|docid
parameter_list|,
name|Float
name|originalDocScore
parameter_list|,
name|List
argument_list|<
name|LeafReaderContext
argument_list|>
name|leafContexts
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|n
init|=
name|ReaderUtil
operator|.
name|subIndex
argument_list|(
name|docid
argument_list|,
name|leafContexts
argument_list|)
decl_stmt|;
specifier|final
name|LeafReaderContext
name|atomicContext
init|=
name|leafContexts
operator|.
name|get
argument_list|(
name|n
argument_list|)
decl_stmt|;
specifier|final
name|int
name|deBasedDoc
init|=
name|docid
operator|-
name|atomicContext
operator|.
name|docBase
decl_stmt|;
specifier|final
name|LTRScoringQuery
operator|.
name|ModelWeight
operator|.
name|ModelScorer
name|r
init|=
name|modelWeight
operator|.
name|scorer
argument_list|(
name|atomicContext
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|==
literal|null
operator|)
operator|||
operator|(
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|advance
argument_list|(
name|deBasedDoc
argument_list|)
operator|!=
name|deBasedDoc
operator|)
condition|)
block|{
return|return
operator|new
name|LTRScoringQuery
operator|.
name|FeatureInfo
index|[
literal|0
index|]
return|;
block|}
else|else
block|{
if|if
condition|(
name|originalDocScore
operator|!=
literal|null
condition|)
block|{
comment|// If results have not been reranked, the score passed in is the original query's
comment|// score, which some features can use instead of recalculating it
name|r
operator|.
name|getDocInfo
argument_list|()
operator|.
name|setOriginalDocScore
argument_list|(
name|originalDocScore
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|score
argument_list|()
expr_stmt|;
return|return
name|modelWeight
operator|.
name|getFeaturesInfo
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

