begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.solr.cloud.autoscaling
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|autoscaling
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|autoscaling
operator|.
name|Policy
operator|.
name|ReplicaInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|MapWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|StrUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|Utils
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singletonMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|autoscaling
operator|.
name|Clause
operator|.
name|TestStatus
operator|.
name|PASS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|autoscaling
operator|.
name|Operand
operator|.
name|EQUAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|autoscaling
operator|.
name|Operand
operator|.
name|GREATER_THAN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|autoscaling
operator|.
name|Operand
operator|.
name|LESS_THAN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|autoscaling
operator|.
name|Operand
operator|.
name|NOT_EQUAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|autoscaling
operator|.
name|Operand
operator|.
name|WILDCARD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|autoscaling
operator|.
name|Policy
operator|.
name|ANY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CoreAdminParams
operator|.
name|COLLECTION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CoreAdminParams
operator|.
name|REPLICA
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CoreAdminParams
operator|.
name|SHARD
import|;
end_import

begin_comment
comment|// a set of conditions in a policy
end_comment

begin_class
DECL|class|Clause
specifier|public
class|class
name|Clause
implements|implements
name|MapWriter
implements|,
name|Comparable
argument_list|<
name|Clause
argument_list|>
block|{
DECL|field|original
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|original
decl_stmt|;
DECL|field|collection
DECL|field|shard
DECL|field|replica
DECL|field|tag
DECL|field|globalTag
name|Condition
name|collection
decl_stmt|,
name|shard
decl_stmt|,
name|replica
decl_stmt|,
name|tag
decl_stmt|,
name|globalTag
decl_stmt|;
DECL|field|strict
name|boolean
name|strict
init|=
literal|true
decl_stmt|;
DECL|method|Clause
name|Clause
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|m
parameter_list|)
block|{
name|this
operator|.
name|original
operator|=
name|m
expr_stmt|;
name|strict
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|m
operator|.
name|getOrDefault
argument_list|(
literal|"strict"
argument_list|,
literal|"true"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Optional
argument_list|<
name|String
argument_list|>
name|globalTagName
init|=
name|m
operator|.
name|keySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|Policy
operator|.
name|GLOBAL_ONLY_TAGS
operator|::
name|contains
argument_list|)
operator|.
name|findFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|globalTagName
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|globalTag
operator|=
name|parse
argument_list|(
name|globalTagName
operator|.
name|get
argument_list|()
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Only one extra tag supported for the tag "
operator|+
name|globalTagName
operator|.
name|get
argument_list|()
operator|+
literal|" in "
operator|+
name|Utils
operator|.
name|toJSONString
argument_list|(
name|m
argument_list|)
argument_list|)
throw|;
block|}
name|tag
operator|=
name|parse
argument_list|(
name|m
operator|.
name|keySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|s
lambda|->
operator|(
operator|!
name|globalTagName
operator|.
name|get
argument_list|()
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|IGNORE_TAGS
operator|.
name|contains
argument_list|(
name|s
argument_list|)
operator|)
argument_list|)
operator|.
name|findFirst
argument_list|()
operator|.
name|get
argument_list|()
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|collection
operator|=
name|parse
argument_list|(
name|COLLECTION
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|shard
operator|=
name|parse
argument_list|(
name|SHARD
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|get
argument_list|(
name|REPLICA
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|StrUtils
operator|.
name|formatString
argument_list|(
literal|"'replica' is required"
operator|+
name|Utils
operator|.
name|toJSONString
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
name|Condition
name|replica
init|=
name|parse
argument_list|(
name|REPLICA
argument_list|,
name|m
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|replicaCount
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|replica
operator|.
name|val
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaCount
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"replica value sould be non null "
operator|+
name|Utils
operator|.
name|toJSONString
argument_list|(
name|m
argument_list|)
argument_list|)
throw|;
block|}
name|this
operator|.
name|replica
operator|=
operator|new
name|Condition
argument_list|(
name|replica
operator|.
name|name
argument_list|,
name|replicaCount
argument_list|,
name|replica
operator|.
name|op
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Only an integer value is supported for replica "
operator|+
name|Utils
operator|.
name|toJSONString
argument_list|(
name|m
argument_list|)
argument_list|)
throw|;
block|}
name|m
operator|.
name|forEach
argument_list|(
parameter_list|(
name|s
parameter_list|,
name|o
parameter_list|)
lambda|->
name|parseCondition
argument_list|(
name|s
argument_list|,
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tag
operator|==
literal|null
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid op, must have one and only one tag other than collection, shard,replica "
operator|+
name|Utils
operator|.
name|toJSONString
argument_list|(
name|m
argument_list|)
argument_list|)
throw|;
block|}
DECL|method|doesOverride
specifier|public
name|boolean
name|doesOverride
parameter_list|(
name|Clause
name|that
parameter_list|)
block|{
return|return
operator|(
name|collection
operator|.
name|equals
argument_list|(
name|that
operator|.
name|collection
argument_list|)
operator|&&
name|tag
operator|.
name|name
operator|.
name|equals
argument_list|(
name|that
operator|.
name|tag
operator|.
name|name
argument_list|)
operator|)
return|;
block|}
DECL|method|isPerCollectiontag
specifier|public
name|boolean
name|isPerCollectiontag
parameter_list|()
block|{
return|return
name|globalTag
operator|==
literal|null
return|;
block|}
DECL|method|parseCondition
name|void
name|parseCondition
parameter_list|(
name|String
name|s
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|IGNORE_TAGS
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
return|return;
if|if
condition|(
name|tag
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Only one tag other than collection, shard, replica is possible"
argument_list|)
throw|;
block|}
name|tag
operator|=
name|parse
argument_list|(
name|s
argument_list|,
name|singletonMap
argument_list|(
name|s
argument_list|,
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|Clause
name|that
parameter_list|)
block|{
try|try
block|{
name|int
name|v
init|=
name|Integer
operator|.
name|compare
argument_list|(
name|this
operator|.
name|tag
operator|.
name|op
operator|.
name|priority
argument_list|,
name|that
operator|.
name|tag
operator|.
name|op
operator|.
name|priority
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|0
condition|)
return|return
name|v
return|;
if|if
condition|(
name|this
operator|.
name|isPerCollectiontag
argument_list|()
operator|&&
name|that
operator|.
name|isPerCollectiontag
argument_list|()
condition|)
block|{
name|v
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|this
operator|.
name|replica
operator|.
name|op
operator|.
name|priority
argument_list|,
name|that
operator|.
name|replica
operator|.
name|op
operator|.
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
block|{
name|v
operator|=
name|Integer
operator|.
name|compare
argument_list|(
operator|(
name|Integer
operator|)
name|this
operator|.
name|replica
operator|.
name|val
argument_list|,
operator|(
name|Integer
operator|)
name|that
operator|.
name|replica
operator|.
name|val
argument_list|)
expr_stmt|;
name|v
operator|=
name|this
operator|.
name|replica
operator|.
name|op
operator|==
name|LESS_THAN
condition|?
name|v
else|:
name|v
operator|*
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|addTags
name|void
name|addTags
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|params
parameter_list|)
block|{
if|if
condition|(
name|globalTag
operator|!=
literal|null
operator|&&
operator|!
name|params
operator|.
name|contains
argument_list|(
name|globalTag
operator|.
name|name
argument_list|)
condition|)
name|params
operator|.
name|add
argument_list|(
name|globalTag
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
literal|null
operator|&&
operator|!
name|params
operator|.
name|contains
argument_list|(
name|tag
operator|.
name|name
argument_list|)
condition|)
name|params
operator|.
name|add
argument_list|(
name|tag
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
DECL|class|Condition
specifier|static
class|class
name|Condition
block|{
DECL|field|name
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|val
specifier|final
name|Object
name|val
decl_stmt|;
DECL|field|op
specifier|final
name|Operand
name|op
decl_stmt|;
DECL|method|Condition
name|Condition
parameter_list|(
name|String
name|name
parameter_list|,
name|Object
name|val
parameter_list|,
name|Operand
name|op
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|this
operator|.
name|op
operator|=
name|op
expr_stmt|;
block|}
DECL|method|match
name|TestStatus
name|match
parameter_list|(
name|Row
name|row
parameter_list|)
block|{
return|return
name|op
operator|.
name|match
argument_list|(
name|val
argument_list|,
name|row
operator|.
name|getVal
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
DECL|method|match
name|TestStatus
name|match
parameter_list|(
name|Object
name|testVal
parameter_list|)
block|{
return|return
name|op
operator|.
name|match
argument_list|(
name|this
operator|.
name|val
argument_list|,
name|testVal
argument_list|)
return|;
block|}
DECL|method|isPass
name|boolean
name|isPass
parameter_list|(
name|Object
name|inputVal
parameter_list|)
block|{
return|return
name|op
operator|.
name|match
argument_list|(
name|val
argument_list|,
name|inputVal
argument_list|)
operator|==
name|PASS
return|;
block|}
DECL|method|isPass
name|boolean
name|isPass
parameter_list|(
name|Row
name|row
parameter_list|)
block|{
return|return
name|op
operator|.
name|match
argument_list|(
name|val
argument_list|,
name|row
operator|.
name|getVal
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|PASS
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|that
parameter_list|)
block|{
if|if
condition|(
name|that
operator|instanceof
name|Condition
condition|)
block|{
name|Condition
name|c
init|=
operator|(
name|Condition
operator|)
name|that
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|c
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|c
operator|.
name|val
argument_list|,
name|val
argument_list|)
operator|&&
name|c
operator|.
name|op
operator|==
name|op
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|delta
specifier|public
name|Integer
name|delta
parameter_list|(
name|Object
name|val
parameter_list|)
block|{
return|return
name|op
operator|.
name|delta
argument_list|(
name|this
operator|.
name|val
argument_list|,
name|val
argument_list|)
return|;
block|}
block|}
DECL|method|parse
specifier|static
name|Condition
name|parse
parameter_list|(
name|String
name|s
parameter_list|,
name|Map
name|m
parameter_list|)
block|{
name|Object
name|expectedVal
init|=
literal|null
decl_stmt|;
name|Object
name|val
init|=
name|m
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
try|try
block|{
name|String
name|conditionName
init|=
name|s
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|val
operator|==
literal|null
condition|?
literal|null
else|:
name|String
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|Operand
name|operand
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|expectedVal
operator|=
name|WILDCARD
operator|.
name|parse
argument_list|(
name|value
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|operand
operator|=
name|WILDCARD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|expectedVal
operator|=
name|NOT_EQUAL
operator|.
name|parse
argument_list|(
name|value
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|operand
operator|=
name|NOT_EQUAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|expectedVal
operator|=
name|GREATER_THAN
operator|.
name|parse
argument_list|(
name|value
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|operand
operator|=
name|GREATER_THAN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|expectedVal
operator|=
name|LESS_THAN
operator|.
name|parse
argument_list|(
name|value
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|operand
operator|=
name|LESS_THAN
expr_stmt|;
block|}
else|else
block|{
name|operand
operator|=
name|EQUAL
expr_stmt|;
name|expectedVal
operator|=
name|EQUAL
operator|.
name|parse
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Condition
argument_list|(
name|conditionName
argument_list|,
name|expectedVal
argument_list|,
name|operand
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid tag : "
operator|+
name|s
operator|+
literal|":"
operator|+
name|val
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|class|Violation
specifier|public
class|class
name|Violation
implements|implements
name|MapWriter
block|{
DECL|field|shard
DECL|field|coll
DECL|field|node
specifier|final
name|String
name|shard
decl_stmt|,
name|coll
decl_stmt|,
name|node
decl_stmt|;
DECL|field|actualVal
specifier|final
name|Object
name|actualVal
decl_stmt|;
DECL|field|delta
specifier|final
name|Integer
name|delta
decl_stmt|;
comment|//how far is the actual value from the expected value
DECL|field|tagKey
specifier|final
name|Object
name|tagKey
decl_stmt|;
DECL|field|hash
specifier|private
specifier|final
name|int
name|hash
decl_stmt|;
DECL|method|Violation
specifier|private
name|Violation
parameter_list|(
name|String
name|coll
parameter_list|,
name|String
name|shard
parameter_list|,
name|String
name|node
parameter_list|,
name|Object
name|actualVal
parameter_list|,
name|Integer
name|delta
parameter_list|,
name|Object
name|tagKey
parameter_list|)
block|{
name|this
operator|.
name|shard
operator|=
name|shard
expr_stmt|;
name|this
operator|.
name|coll
operator|=
name|coll
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|delta
operator|=
name|delta
expr_stmt|;
name|this
operator|.
name|actualVal
operator|=
name|actualVal
expr_stmt|;
name|this
operator|.
name|tagKey
operator|=
name|tagKey
expr_stmt|;
name|hash
operator|=
operator|(
literal|""
operator|+
name|coll
operator|+
literal|" "
operator|+
name|shard
operator|+
literal|" "
operator|+
name|node
operator|+
literal|" "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|tagKey
argument_list|)
operator|+
literal|" "
operator|+
name|Utils
operator|.
name|toJSONString
argument_list|(
name|getClause
argument_list|()
operator|.
name|toMap
argument_list|(
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|)
argument_list|)
operator|)
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
DECL|method|getClause
specifier|public
name|Clause
name|getClause
parameter_list|()
block|{
return|return
name|Clause
operator|.
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
comment|//if the delta is lower , this violation is less serious
DECL|method|isLessSerious
specifier|public
name|boolean
name|isLessSerious
parameter_list|(
name|Violation
name|that
parameter_list|)
block|{
return|return
name|that
operator|.
name|delta
operator|!=
literal|null
operator|&&
name|delta
operator|!=
literal|null
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|delta
argument_list|)
operator|<
name|Math
operator|.
name|abs
argument_list|(
name|that
operator|.
name|delta
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|that
parameter_list|)
block|{
if|if
condition|(
name|that
operator|instanceof
name|Violation
condition|)
block|{
name|Violation
name|v
init|=
operator|(
name|Violation
operator|)
name|that
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|shard
argument_list|,
name|v
operator|.
name|shard
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|coll
argument_list|,
name|v
operator|.
name|coll
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|node
argument_list|,
name|v
operator|.
name|node
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|tagKey
argument_list|,
name|v
operator|.
name|tagKey
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|writeMap
specifier|public
name|void
name|writeMap
parameter_list|(
name|EntryWriter
name|ew
parameter_list|)
throws|throws
name|IOException
block|{
name|ew
operator|.
name|putIfNotNull
argument_list|(
literal|"collection"
argument_list|,
name|coll
argument_list|)
expr_stmt|;
name|ew
operator|.
name|putIfNotNull
argument_list|(
literal|"shard"
argument_list|,
name|shard
argument_list|)
expr_stmt|;
name|ew
operator|.
name|putIfNotNull
argument_list|(
literal|"node"
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|ew
operator|.
name|putIfNotNull
argument_list|(
literal|"tagKey"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|tagKey
argument_list|)
argument_list|)
expr_stmt|;
name|ew
operator|.
name|putIfNotNull
argument_list|(
literal|"violation"
argument_list|,
operator|(
name|MapWriter
operator|)
name|ew1
lambda|->
block|{
name|ew1
operator|.
name|put
argument_list|(
name|getClause
argument_list|()
operator|.
name|isPerCollectiontag
argument_list|()
condition|?
literal|"replica"
else|:
name|tag
operator|.
name|name
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|actualVal
argument_list|)
argument_list|)
expr_stmt|;
name|ew1
operator|.
name|putIfNotNull
argument_list|(
literal|"delta"
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|ew
operator|.
name|put
argument_list|(
literal|"clause"
argument_list|,
name|getClause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|test
specifier|public
name|List
argument_list|<
name|Violation
argument_list|>
name|test
parameter_list|(
name|List
argument_list|<
name|Row
argument_list|>
name|allRows
parameter_list|)
block|{
name|List
argument_list|<
name|Violation
argument_list|>
name|violations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|isPerCollectiontag
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
argument_list|>
argument_list|>
name|replicaCount
init|=
name|computeReplicaCounts
argument_list|(
name|allRows
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
argument_list|>
argument_list|>
name|e
range|:
name|replicaCount
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|isPass
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
argument_list|>
name|shardVsCount
range|:
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|shard
operator|.
name|isPass
argument_list|(
name|shardVsCount
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|counts
range|:
name|shardVsCount
operator|.
name|getValue
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|replica
operator|.
name|isPass
argument_list|(
name|counts
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|violations
operator|.
name|add
argument_list|(
operator|new
name|Violation
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|shardVsCount
operator|.
name|getKey
argument_list|()
argument_list|,
name|tag
operator|.
name|name
operator|.
name|equals
argument_list|(
literal|"node"
argument_list|)
condition|?
name|counts
operator|.
name|getKey
argument_list|()
else|:
literal|null
argument_list|,
name|counts
operator|.
name|getValue
argument_list|()
argument_list|,
name|replica
operator|.
name|delta
argument_list|(
name|counts
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|,
name|counts
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|Row
name|r
range|:
name|allRows
control|)
block|{
if|if
condition|(
operator|!
name|tag
operator|.
name|isPass
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|violations
operator|.
name|add
argument_list|(
operator|new
name|Violation
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|r
operator|.
name|node
argument_list|,
name|r
operator|.
name|getVal
argument_list|(
name|tag
operator|.
name|name
argument_list|)
argument_list|,
name|tag
operator|.
name|delta
argument_list|(
name|r
operator|.
name|getVal
argument_list|(
name|tag
operator|.
name|name
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|violations
return|;
block|}
DECL|method|computeReplicaCounts
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
argument_list|>
argument_list|>
name|computeReplicaCounts
parameter_list|(
name|List
argument_list|<
name|Row
argument_list|>
name|allRows
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
argument_list|>
argument_list|>
name|collVsShardVsTagVsCount
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Row
name|row
range|:
name|allRows
control|)
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ReplicaInfo
argument_list|>
argument_list|>
argument_list|>
name|colls
range|:
name|row
operator|.
name|collectionVsShardVsReplicas
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|collectionName
init|=
name|colls
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|isPass
argument_list|(
name|collectionName
argument_list|)
condition|)
continue|continue;
name|collVsShardVsTagVsCount
operator|.
name|putIfAbsent
argument_list|(
name|collectionName
argument_list|,
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
argument_list|>
name|collMap
init|=
name|collVsShardVsTagVsCount
operator|.
name|get
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ReplicaInfo
argument_list|>
argument_list|>
name|shards
range|:
name|colls
operator|.
name|getValue
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|shardName
init|=
name|shards
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|ANY
operator|.
name|equals
argument_list|(
name|shard
operator|.
name|val
argument_list|)
condition|)
name|shardName
operator|=
name|ANY
expr_stmt|;
if|if
condition|(
operator|!
name|shard
operator|.
name|isPass
argument_list|(
name|shardName
argument_list|)
condition|)
break|break;
name|collMap
operator|.
name|putIfAbsent
argument_list|(
name|shardName
argument_list|,
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|tagVsCount
init|=
name|collMap
operator|.
name|get
argument_list|(
name|shardName
argument_list|)
decl_stmt|;
name|Object
name|tagVal
init|=
name|row
operator|.
name|getVal
argument_list|(
name|tag
operator|.
name|name
argument_list|)
decl_stmt|;
name|tagVsCount
operator|.
name|putIfAbsent
argument_list|(
name|tag
operator|.
name|isPass
argument_list|(
name|tagVal
argument_list|)
condition|?
name|String
operator|.
name|valueOf
argument_list|(
name|tagVal
argument_list|)
else|:
literal|""
argument_list|,
operator|new
name|AtomicInteger
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|.
name|isPass
argument_list|(
name|tagVal
argument_list|)
condition|)
block|{
name|tagVsCount
operator|.
name|get
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|tagVal
argument_list|)
argument_list|)
operator|.
name|addAndGet
argument_list|(
name|shards
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|collVsShardVsTagVsCount
return|;
block|}
DECL|method|isStrict
specifier|public
name|boolean
name|isStrict
parameter_list|()
block|{
return|return
name|strict
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Utils
operator|.
name|toJSONString
argument_list|(
name|original
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|writeMap
specifier|public
name|void
name|writeMap
parameter_list|(
name|EntryWriter
name|ew
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|e
range|:
name|original
operator|.
name|entrySet
argument_list|()
control|)
name|ew
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|enum|TestStatus
enum|enum
name|TestStatus
block|{
DECL|enum constant|NOT_APPLICABLE
DECL|enum constant|FAIL
DECL|enum constant|PASS
name|NOT_APPLICABLE
block|,
name|FAIL
block|,
name|PASS
block|}
DECL|field|IGNORE_TAGS
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|IGNORE_TAGS
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|REPLICA
argument_list|,
name|COLLECTION
argument_list|,
name|SHARD
argument_list|,
literal|"strict"
argument_list|)
argument_list|)
decl_stmt|;
block|}
end_class

end_unit

